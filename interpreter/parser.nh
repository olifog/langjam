// Parser module - all parse_* functions
// Requires: lexer.nh (for TOK_* constants), ast.nh (for AST constructors)

// Parser error state (checked by bot after parsing)
parse_error := 0.
parse_error_line := 0.
parse_error_msg := "".

#set_parse_error(msg, tok) >
    parse_error = 1.
    parse_error_line = tok->line.
    parse_error_msg = msg.
<

#set_parse_error_at_line(msg, line) >
    parse_error = 1.
    parse_error_line = line.
    parse_error_msg = msg.
<

#peek(tokens, pos) >
    << /ds_list_get/tokens/pos.
<

#parse_paren(tokens, pos) >
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    
    res := /parse_expr/tokens/(pos + 1).
    // Expect RPAREN
    end := res->end.
    rparen := /peek/tokens/end.
    
    // Error if RPAREN missing
    /set_parse_error_at_line/"Missing ')' in expression"/start_line when rparen->type != TOK_RPAREN.
    
    end = end + 1 when rparen->type == TOK_RPAREN.
    << { node: res->node, end: end }.
<

#parse_array(tokens, pos) >
    pos = pos + 1. // Skip [
    
    elements := /ds_list_create/.
    max_iter := 100.
    iter := 0.
    loop >
        tok := /peek/tokens/pos.
        >> when tok->type == TOK_RBRACKET.
        >> when tok->type == TOK_EOF.
        >> when iter ge max_iter.
        
        // Safety: detect if we're not making progress
        old_pos := pos.
        
        elem_res := /parse_expr/tokens/pos.
        /ds_list_push/elements/elem_res->node.
        pos = elem_res->end.
        
        // Check for comma
        tok = /peek/tokens/pos.
        pos = pos + 1 when tok->type == TOK_COMMA.
        
        // If pos didn't advance, we're stuck - set error and break
        /set_parse_error/"Syntax error in array"/tok when pos == old_pos.
        >> when pos == old_pos.
        
        iter = iter + 1.
    <
    
    // Check for missing closing bracket
    close := /peek/tokens/pos.
    /set_parse_error/"Missing ']' in array"/close when close->type != TOK_RBRACKET.
    
    // Skip ] only if present
    pos = pos + 1 when close->type == TOK_RBRACKET.
    << { node: /arr_lit/elements, end: pos }.
<

#parse_object(tokens, pos) >
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    pos = pos + 1. // Skip {
    
    fields := /ds_list_create/.
    max_iter := 100.
    iter := 0.
    loop >
        tok := /peek/tokens/pos.
        >> when tok->type == TOK_RBRACE.
        >> when tok->type == TOK_EOF.
        >> when iter ge max_iter.
        
        // Validate key is identifier
        /set_parse_error_at_line/"Expected identifier as object key"/start_line when tok->type != TOK_IDENT.
        >> when tok->type != TOK_IDENT.
        
        // Get key
        key := tok->value.
        pos = pos + 1.
        
        // Expect : (TOK_COLON = 47)
        colon := /peek/tokens/pos.
        /set_parse_error_at_line/"Expected ':' after object key"/start_line when colon->type != TOK_COLON.
        >> when colon->type != TOK_COLON.
        pos = pos + 1.
        
        // Parse value
        val_res := /parse_expr/tokens/pos.
        pos = val_res->end.
        
        /ds_list_push/fields/(/obj_field/key/val_res->node).
        
        // Check for comma
        tok = /peek/tokens/pos.
        pos = pos + 1 when tok->type == TOK_COMMA.
        
        iter = iter + 1.
    <
    
    // Check for missing closing brace
    close := /peek/tokens/pos.
    /set_parse_error_at_line/"Missing '}' in object"/start_line when close->type != TOK_RBRACE.
    
    // Skip } only if present
    pos = pos + 1 when close->type == TOK_RBRACE.
    << { node: /obj_lit/fields, end: pos }.
<

// Lambda: \(x, y) => body
#parse_lambda(tokens, pos) >
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    pos = pos + 1. // Skip \
    
    // Validate (
    lparen := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected '(' after '\\'"/start_line when lparen->type != TOK_LPAREN.
    << { node: /lit/0, end: pos } when lparen->type != TOK_LPAREN.
    pos = pos + 1.
    
    // Parse parameters
    params := /ds_list_create/.
    max_iter := 50.
    iter := 0.
    loop >
        tok := /peek/tokens/pos.
        >> when tok->type == TOK_RPAREN.
        >> when tok->type == TOK_EOF.
        >> when iter ge max_iter.
        
        // Get param name
        /ds_list_push/params/tok->value.
        pos = pos + 1.
        
        // Check for comma
        tok = /peek/tokens/pos.
        pos = pos + 1 when tok->type == TOK_COMMA.
        iter = iter + 1.
    <
    
    // Validate )
    rparen := /peek/tokens/pos.
    /set_parse_error_at_line/"Missing ')' in lambda"/start_line when rparen->type != TOK_RPAREN.
    << { node: /lit/0, end: pos } when rparen->type != TOK_RPAREN.
    pos = pos + 1.
    
    // Validate =>
    arrow := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected '=>' in lambda"/start_line when arrow->type != TOK_ARROW.
    << { node: /lit/0, end: pos } when arrow->type != TOK_ARROW.
    pos = pos + 1.
    
    // Parse body expression
    body_res := /parse_expr/tokens/pos.
    
    << { node: /lambda_expr/params/body_res->node, end: body_res->end }.
<

#parse_primary_base(tokens, pos) >
    tok := /peek/tokens/pos.
    << tok->type | >
        1 => // INT
            { node: /lit/tok->value, end: pos + 1 }
        2 => // IDENT
            { node: /var/tok->value, end: pos + 1 }
        11 => /parse_paren/tokens/pos // LPAREN
        21 => // TOK_NOT
            /parse_not/tokens/pos
        4 => // TOK_MINUS (Unary)
            /parse_neg/tokens/pos
        6 => // TOK_SLASH - function call in expression context
            /parse_call_expr/tokens/pos
        38 => // TOK_UNDER - wildcard
            { node: /wildcard/, end: pos + 1 }
        39 => // TOK_STRING
            { node: /str_lit/tok->value, end: pos + 1 }
        40 => // TOK_LBRACKET - array literal
            /parse_array/tokens/pos
        42 => // TOK_LBRACE - object literal
            /parse_object/tokens/pos
        46 => // TOK_BACKSLASH - lambda
            /parse_lambda/tokens/pos
        _ => { node: /lit/0, end: pos } // Error
    <.
<

// Handle postfix: expr[index] and expr->key
#parse_primary(tokens, pos) >
    res := /parse_primary_base/tokens/pos.
    pos = res->end.
    node := res->node.
    
    loop >
        tok := /peek/tokens/pos.
        
        // Handle [ (index)
        is_index := tok->type == TOK_LBRACKET.
        << /parse_index_rest/tokens/pos/node when is_index.
        
        // Handle -> (property access)
        is_prop := tok->type == TOK_PROPACCESS.
        << /parse_prop_rest/tokens/pos/node when is_prop.
        
        // Neither, exit loop
        >> when 1.
    <
    
    << { node: node, end: pos }.
<

#parse_index_rest(tokens, pos, node) >
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    pos = pos + 1. // Skip [
    idx_res := /parse_expr/tokens/pos.
    pos = idx_res->end.
    
    // Validate ]
    rbracket := /peek/tokens/pos.
    /set_parse_error_at_line/"Missing ']' in index access"/start_line when rbracket->type != TOK_RBRACKET.
    pos = pos + 1 when rbracket->type == TOK_RBRACKET.
    
    new_node := /index_op/node/idx_res->node.
    << /parse_primary_postfix/tokens/pos/new_node.
<

#parse_prop_rest(tokens, pos, node) >
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    pos = pos + 1. // Skip ->
    key_tok := /peek/tokens/pos.
    
    // Validate property name is identifier
    /set_parse_error_at_line/"Expected property name after '->'"/start_line when key_tok->type != TOK_IDENT.
    
    key := key_tok->value.
    pos = pos + 1.
    new_node := /prop_op/node/key.
    << /parse_primary_postfix/tokens/pos/new_node.
<

#parse_primary_postfix(tokens, pos, node) >
    tok := /peek/tokens/pos.
    
    // Handle [ (index)
    << /parse_index_rest/tokens/pos/node when tok->type == TOK_LBRACKET.
    
    // Handle -> (property access)
    << /parse_prop_rest/tokens/pos/node when tok->type == TOK_PROPACCESS.
    
    // No more postfix operators
    << { node: node, end: pos }.
<





#parse_not(tokens, pos) >
    pos = pos + 1. // Skip not
    res := /parse_primary/tokens/pos.
    << { node: /not_op/res->node, end: res->end }.
<

#parse_neg(tokens, pos) >
    pos = pos + 1. // Skip -
    res := /parse_primary/tokens/pos.
    << { node: /neg_op/res->node, end: res->end }.
<

#parse_factor(tokens, pos) >
    left_res := /parse_primary/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    loop >
        tok := /peek/tokens/pos.
        type := tok->type.
        is_op := (type == TOK_STAR or type == TOK_SLASH or type == TOK_PERCENT).
        >> when not is_op.
        
        // Detect accidental function call in expression context: /identifier/
        // If we see / followed by identifier followed by /, it's probably meant as a function call
        // Note: /identifier. is valid division, only /identifier/ is suspicious
        next := /peek/tokens/(pos + 1).
        after := /peek/tokens/(pos + 2).
        is_func_pattern := (type == TOK_SLASH and next->type == TOK_IDENT and after->type == TOK_SLASH).
        /set_parse_error/"Possible missing '.' before function call"/tok when is_func_pattern.
        >> when is_func_pattern.
        
        pos = pos + 1.
        right_res := /parse_primary/tokens/pos.
        pos = right_res->end.
        right := right_res->node.
        
        left = type | >
            5 => /mul/left/right
            6 => /ast_div/left/right
            7 => /mod/left/right
            _ => left
        <.
    <
    << { node: left, end: pos }.
<

#parse_term(tokens, pos) >
    left_res := /parse_factor/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    loop >
        tok := /peek/tokens/pos.
        type := tok->type.
        is_op := (type == TOK_PLUS or type == TOK_MINUS).
        >> when not is_op.
        
        pos = pos + 1.
        right_res := /parse_factor/tokens/pos.
        pos = right_res->end.
        right := right_res->node.
        
        left = type | >
            3 => /add/left/right
            4 => /sub/left/right
            _ => left
        <.
    <
    << { node: left, end: pos }.
<

#parse_comp(tokens, pos) >
    left_res := /parse_term/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    loop >
        tok := /peek/tokens/pos.
        type := tok->type.
        is_op := (type ge TOK_LT and type le TOK_NE).
        >> when not is_op.
        
        pos = pos + 1.
        right_res := /parse_term/tokens/pos.
        pos = right_res->end.
        right := right_res->node.
        
        left = type | >
            13 => /lt_op/left/right
            14 => /gt_op/left/right
            15 => /le_op/left/right
            16 => /ge_op/left/right
            17 => /eq_op/left/right
            18 => /ne_op/left/right
            _ => left
        <.
    <
    << { node: left, end: pos }.
<

#parse_logic(tokens, pos) >
    left_res := /parse_comp/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    loop >
        tok := /peek/tokens/pos.
        type := tok->type.
        is_op := (type == TOK_AND or type == TOK_OR).
        >> when not is_op.
        
        pos = pos + 1.
        right_res := /parse_comp/tokens/pos.
        pos = right_res->end.
        right := right_res->node.
        
        left = type | >
            19 => /and_op/left/right
            20 => /or_op/left/right
            _ => left
        <.
    <
    << { node: left, end: pos }.
<

#parse_if_rest(tokens, pos, left) >
    // Parse condition
    cond_res := /parse_logic/tokens/(pos + 1).
    // Expect ELSE
    else_pos := cond_res->end.
    else_tok := /peek/tokens/else_pos.
    
    else_res := (else_tok->type == TOK_ELSE) | >
        1 => /parse_logic/tokens/(else_pos + 1)
        0 => { node: /lit/0, end: else_pos }
    <.
    
    << { node: /if_expr/cond_res->node/left/else_res->node, end: else_res->end }.
<

#parse_match(tokens, pos, left) >
    // pos is at |, left is the value to match
    pos = pos + 1. // Skip |
    pos = pos + 1. // Skip >
    
    arms := /ds_list_create/.
    loop >
        tok := /peek/tokens/pos.
        // Check for < (TOK_SCOPE_OUT)
        >> when tok->type == TOK_SCOPE_OUT.
        
        // Parse pattern (literal or wildcard)
        pattern_res := /parse_primary/tokens/pos.
        pos = pattern_res->end.
        
        // Expect =>
        pos = pos + 1.
        
        // Parse body expression
        body_res := /parse_logic/tokens/pos.
        pos = body_res->end.
        
        /ds_list_push/arms/(/match_arm/pattern_res->node/body_res->node).
    <
    
    // Skip <
    pos = pos + 1.
    << { node: /match_expr/left/arms, end: pos }.
<

#parse_match_expr(tokens, pos) >
    left_res := /parse_logic/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    tok := /peek/tokens/pos.
    << tok->type | >
        TOK_PIPE => /parse_match/tokens/pos/left
        TOK_IF => /parse_if_rest/tokens/pos/left
        _ => left_res
    <.
<

#parse_expr(tokens, pos) >
    << /parse_match_expr/tokens/pos.
<

#parse_stmt_assign(tokens, pos, tok) >
    name := tok->value.
    line := tok->line.
    res := /parse_expr/tokens/(pos + 2).
    // Expect DOT
    dot := /peek/tokens/res->end.
    
    // Error if DOT is missing (but allow when/unless modifiers)
    // Use line from start of statement for error highlighting
    /set_parse_error_at_line/"Missing '.' after assignment"/line when dot->type != TOK_DOT and dot->type != TOK_WHEN and dot->type != TOK_UNLESS.
    
    end := (dot->type == TOK_DOT) | >
        1 => res->end + 1
        0 => res->end
    <.
    
    << { node: /decl/name/res->node/line, end: end }.
<

#parse_stmt_expr_stmt(tokens, pos) >
    // Get starting token for error line
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    
    res := /parse_expr/tokens/pos.
    // Expect DOT
    dot := /peek/tokens/res->end.
    
    // Error if DOT is missing (but allow when/unless modifiers)
    // Use line from start of statement for error highlighting
    /set_parse_error_at_line/"Missing '.' after expression"/start_line when dot->type != TOK_DOT and dot->type != TOK_WHEN and dot->type != TOK_UNLESS.
    
    end := (dot->type == TOK_DOT) | >
        1 => res->end + 1
        0 => res->end
    <.
    << { node: res->node, end: end }.
<

#parse_stmt_ident(tokens, pos, tok) >
    next := /peek/tokens/(pos + 1).
    << next->type | >
        8 => /parse_stmt_assign/tokens/pos/tok
        _ => /parse_stmt_expr_stmt/tokens/pos
    <.
<

#parse_block(tokens, pos) >
    // Track start line for error reporting
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    // Adjust for the > that was consumed before calling this
    start_line = start_line - 1 when start_line gt 0.
    
    prog := 0.
    max_iter := 500.
    iter := 0.
    
    loop >
        tok := /peek/tokens/pos.
        // Check for < (TOK_SCOPE_OUT)
        >> when tok->type == TOK_SCOPE_OUT.
        >> when tok->type == TOK_EOF.
        >> when iter ge max_iter.
        // Exit early on parse error
        >> when parse_error == 1.
        
        old_pos := pos.
        res := /parse_stmt/tokens/pos.
        pos = res->end.
        
        // Exit if statement parsing set an error
        >> when parse_error == 1.
        
        // Safety: prevent infinite loop
        pos = pos + 1 when pos == old_pos.
        >> when pos == old_pos.
        
        prog = (prog == 0) | >
            1 => res->node
            0 => /seq/prog/res->node
        <.
        
        iter = iter + 1.
    <
    
    // Validate closing < exists
    close_tok := /peek/tokens/pos.
    /set_parse_error_at_line/"Missing '<' to close block"/start_line when close_tok->type != TOK_SCOPE_OUT.
    
    // Skip < only if present
    pos = pos + 1 when close_tok->type == TOK_SCOPE_OUT.
    << { node: prog, end: pos }.
<

#parse_loop(tokens, pos) >
    // Expect loop > ... <
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    pos = pos + 1. // Skip loop
    
    // Validate > (TOK_SCOPE_IN)
    scope_in := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected '>' after 'loop'"/start_line when scope_in->type != TOK_SCOPE_IN.
    << { node: /lit/0, end: pos } when scope_in->type != TOK_SCOPE_IN.
    pos = pos + 1.
    
    body := /parse_block/tokens/pos.
    << { node: /loop_stmt/body->node, end: body->end }.
<

#parse_modifier(tokens, res, type) >
    pos := res->end + 1. // Skip when/unless
    cond_res := /parse_expr/tokens/pos.
    
    cond := cond_res->node.
    cond = (type == TOK_UNLESS) | >
        1 => /not_op/cond
        0 => cond
    <.
    
    // Get line from inner statement
    line := res->node->line.
    line = 0 when line == 0.
    
    << { node: /when_stmt/res->node/cond/line, end: cond_res->end }.
<

#parse_for(tokens, pos) >
    // Expect for x in start..end > ... <
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    pos = pos + 1. // Skip for
    
    // Validate variable identifier
    var_tok := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected variable name after 'for'"/start_line when var_tok->type != TOK_IDENT.
    << { node: /lit/0, end: pos } when var_tok->type != TOK_IDENT.
    var := var_tok->value.
    pos = pos + 1.
    
    // Validate IN keyword
    in_tok := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected 'in' in for loop"/start_line when in_tok->type != TOK_IN.
    << { node: /lit/0, end: pos } when in_tok->type != TOK_IN.
    pos = pos + 1.
    
    // Parse start expression
    start_res := /parse_expr/tokens/pos.
    pos = start_res->end.
    start := start_res->node.
    
    // Validate .. (TOK_RANGE)
    range_tok := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected '..' in for loop range"/start_line when range_tok->type != TOK_RANGE.
    << { node: /lit/0, end: pos } when range_tok->type != TOK_RANGE.
    pos = pos + 1.
    
    // Parse end expression
    end_res := /parse_expr/tokens/pos.
    pos = end_res->end.
    end := end_res->node.
    
    // Validate > (TOK_SCOPE_IN)
    scope_in := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected '>' after for loop range"/start_line when scope_in->type != TOK_SCOPE_IN.
    << { node: /lit/0, end: pos } when scope_in->type != TOK_SCOPE_IN.
    pos = pos + 1.
    
    body := /parse_block/tokens/pos.
    << { node: /for_stmt/var/start/end/body->node, end: body->end }.
<

// Parse function definition: #name(param1, param2) > body <
#parse_func(tokens, pos) >
    start_tok := /peek/tokens/pos.
    start_line := start_tok->line.
    pos = pos + 1. // Skip #
    
    // Get function name
    tok := /peek/tokens/pos.
    name := tok->value.
    pos = pos + 1.
    
    // Validate (
    lparen := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected '(' after function name"/start_line when lparen->type != TOK_LPAREN.
    << { node: /lit/0, end: pos } when lparen->type != TOK_LPAREN.
    pos = pos + 1.
    
    // Parse parameters
    params := /ds_list_create/.
    max_iter := 50.
    iter := 0.
    loop >
        tok = /peek/tokens/pos.
        >> when tok->type == TOK_RPAREN.
        >> when tok->type == TOK_EOF.
        >> when iter ge max_iter.
        
        // Get param name
        /ds_list_push/params/tok->value.
        pos = pos + 1.
        
        // Check for comma
        tok = /peek/tokens/pos.
        pos = pos + 1 when tok->type == TOK_COMMA.
        iter = iter + 1.
    <
    
    // Validate )
    rparen := /peek/tokens/pos.
    /set_parse_error_at_line/"Missing ')' in function definition"/start_line when rparen->type != TOK_RPAREN.
    << { node: /lit/0, end: pos } when rparen->type != TOK_RPAREN.
    pos = pos + 1.
    
    // Validate > (TOK_SCOPE_IN)
    scope_in := /peek/tokens/pos.
    /set_parse_error_at_line/"Expected '>' after function parameters"/start_line when scope_in->type != TOK_SCOPE_IN.
    << { node: /lit/0, end: pos } when scope_in->type != TOK_SCOPE_IN.
    pos = pos + 1.
    
    // Parse body
    body := /parse_block/tokens/pos.
    
    << { node: /func_def/name/params/body->node, end: body->end }.
<

// Parse function call: /name/arg1/arg2
#parse_call(tokens, pos) >
    pos = pos + 1. // Skip first /
    
    // Get function name
    tok := /peek/tokens/pos.
    
    // Check for missing function name
    /set_parse_error/"Expected function name after /"/tok when tok->type == TOK_SLASH or tok->type == TOK_DOT.
    
    name := tok->value.
    line := tok->line.
    pos = pos + 1.
    
    // Parse arguments (each preceded by /)
    args := /ds_list_create/.
    loop >
        tok = /peek/tokens/pos.
        >> when tok->type != TOK_SLASH.
        
        pos = pos + 1. // Skip /
        
        // Check for empty argument (// or /. or /)
        next := /peek/tokens/pos.
        
        // Allow trailing slash if followed by statement terminator
        >> when next->type == TOK_DOT.
        >> when next->type == TOK_WHEN.
        >> when next->type == TOK_UNLESS.
        
        // Use function call's line for error highlighting
        /set_parse_error_at_line/"Empty argument in function call"/line when next->type == TOK_SLASH.
        >> when next->type == TOK_SLASH.
        /set_parse_error_at_line/"Empty argument in function call"/line when next->type == TOK_DOT.
        >> when next->type == TOK_DOT.
        /set_parse_error_at_line/"Empty argument in function call"/line when next->type == TOK_EOF.
        >> when next->type == TOK_EOF.
        
        // Parse argument expression
        arg_res := /parse_primary/tokens/pos.
        /ds_list_push/args/arg_res->node.
        pos = arg_res->end.
    <
    
    // Check for trailing .
    dot := /peek/tokens/pos.
    // Use function call's line for error highlighting
    /set_parse_error_at_line/"Missing '.' after function call"/line when dot->type != TOK_DOT and dot->type != TOK_WHEN and dot->type != TOK_UNLESS.
    pos = pos + 1 when dot->type == TOK_DOT.
    
    << { node: /func_call/name/args/line, end: pos }.
<

// Parse function call in expression context (no trailing dot)
#parse_call_expr(tokens, pos) >
    pos = pos + 1. // Skip first /

    // Get function name
    tok := /peek/tokens/pos.
    
    // Check for missing function name
    /set_parse_error/"Expected function name after /"/tok when tok->type == TOK_SLASH or tok->type == TOK_DOT.
    
    name := tok->value.
    line := tok->line.
    pos = pos + 1.

    // Parse arguments (each preceded by /)
    args := /ds_list_create/.
    loop >
        tok = /peek/tokens/pos.
        >> when tok->type != TOK_SLASH.

        pos = pos + 1. // Skip /

        // Check for empty argument
        next := /peek/tokens/pos.
        // Use function call's line for error highlighting
        /set_parse_error_at_line/"Empty argument in function call"/line when next->type == TOK_SLASH.
        >> when next->type == TOK_SLASH.
        /set_parse_error_at_line/"Empty argument in function call"/line when next->type == TOK_DOT.
        >> when next->type == TOK_DOT.
        /set_parse_error_at_line/"Empty argument in function call"/line when next->type == TOK_EOF.
        >> when next->type == TOK_EOF.

        // Parse argument expression
        arg_res := /parse_primary/tokens/pos.
        /ds_list_push/args/arg_res->node.
        pos = arg_res->end.
    <

    // Don't consume trailing . in expression context
    << { node: /func_call/name/args/line, end: pos }.
<

// Parse return: << expr
#parse_return(tokens, pos) >
    pos = pos + 1. // Skip <<
    
    res := /parse_expr/tokens/pos.
    << { node: /return_stmt/res->node, end: res->end }.
<

// Parse standalone block: > ... <
#parse_standalone_block(tokens, pos) >
    pos = pos + 1. // Skip >
    << /parse_block/tokens/pos.
<

#parse_stmt(tokens, pos) >
    tok := /peek/tokens/pos.
    
    // Reject tokens that can't start a valid statement
    // These are expression-only tokens that shouldn't appear at statement level
    /set_parse_error/"Unexpected token in statement"/tok when tok->type == TOK_LBRACKET.
    /set_parse_error/"Unexpected token in statement"/tok when tok->type == TOK_LBRACE.
    /set_parse_error/"Unexpected token in statement"/tok when tok->type == TOK_RBRACKET.
    /set_parse_error/"Unexpected token in statement"/tok when tok->type == TOK_RBRACE.
    /set_parse_error/"Unexpected token in statement"/tok when tok->type == TOK_INT.
    /set_parse_error/"Unexpected token in statement"/tok when tok->type == TOK_STRING.
    
    res := tok->type | >
        TOK_LOOP => /parse_loop/tokens/pos
        TOK_FOR => /parse_for/tokens/pos
        TOK_BREAK => { node: /break_stmt/, end: pos + 1 }
        TOK_CONTINUE => { node: /continue_stmt/, end: pos + 1 }
        TOK_HASH => /parse_func/tokens/pos
        TOK_RETURN => /parse_return/tokens/pos
        TOK_SLASH => /parse_call/tokens/pos
        TOK_IDENT => /parse_stmt_ident/tokens/pos/tok
        TOK_SCOPE_IN => /parse_standalone_block/tokens/pos
        _ => /parse_stmt_expr_stmt/tokens/pos
    <.
    
    // Check for trailing modifiers (works for blocks too now!)
    next := /peek/tokens/res->end.
    
    << next->type | >
        TOK_WHEN => /parse_modifier/tokens/res/TOK_WHEN
        TOK_UNLESS => /parse_modifier/tokens/res/TOK_UNLESS
        _ => res
    <.
<

#parse_program(tokens) >
    pos := 0.
    prog := 0.
    
    loop >
        tok := /peek/tokens/pos.
        >> when tok->type == TOK_EOF.
        // Exit on parse error
        >> when parse_error == 1.
        
        res := /parse_stmt/tokens/pos.
        pos = res->end.
        
        // Exit if statement parsing set an error
        >> when parse_error == 1.
        
        prog = (prog == 0) | >
            1 => res->node
            0 => /seq/prog/res->node
        <.
    <
    
    << prog.
<
