// AST Tags
TAG_LIT := 1.
TAG_VAR := 2.
TAG_ADD := 3.
TAG_SUB := 8.
TAG_MUL := 9.
TAG_DIV := 10.
TAG_MOD := 11.
TAG_LT := 12.
TAG_GT := 13.
TAG_LE := 14.
TAG_GE := 15.
TAG_EQ := 16.
TAG_NE := 17.
TAG_AND := 18.
TAG_OR := 19.
TAG_NOT := 20.
TAG_DECL := 4.
TAG_SEQ := 5.
TAG_BLOCK := 6.
TAG_ASSIGN := 7.
TAG_LOOP := 21.
TAG_BREAK := 22.
TAG_IF := 23.
TAG_WHEN := 24. // For trailing when/unless (unless is when not)
TAG_FOR := 25.
TAG_FUNC := 26.    // Function definition
TAG_CALL := 27.    // Function call
TAG_RETURN := 28.  // Return statement
TAG_MATCH := 29.   // Match expression
TAG_MATCH_ARM := 30.  // Match arm
TAG_WILDCARD := 31.   // Wildcard pattern (_)
TAG_STRING := 32.     // String literal
TAG_ARRAY := 33.      // Array literal
TAG_INDEX := 34.      // Array/String index
TAG_OBJECT := 35.     // Object literal { key: value }
TAG_FIELD := 36.      // Object field (key-value pair)
TAG_PROP := 37.       // Property access (obj->key)
TAG_LAMBDA := 38.     // Lambda expression \(x) => expr
TAG_INVOKE := 39.     // Lambda invocation expr/(args)
TAG_NEG := 40.        // Unary negation

// AST Constructors
#lit(value) => { tag: TAG_LIT, value: value }.
#var(name)  => { tag: TAG_VAR, name: name }.
#add(a, b)  => { tag: TAG_ADD, a: a, b: b }.
#sub(a, b)  => { tag: TAG_SUB, a: a, b: b }.
#mul(a, b)  => { tag: TAG_MUL, a: a, b: b }.
#ast_div(a, b)  => { tag: TAG_DIV, a: a, b: b }.
#mod(a, b)  => { tag: TAG_MOD, a: a, b: b }.
#neg_op(a)  => { tag: TAG_NEG, a: a }.
#lt_op(a, b)   => { tag: TAG_LT, a: a, b: b }.
#gt_op(a, b)   => { tag: TAG_GT, a: a, b: b }.
#le_op(a, b)   => { tag: TAG_LE, a: a, b: b }.
#ge_op(a, b)   => { tag: TAG_GE, a: a, b: b }.
#eq_op(a, b)   => { tag: TAG_EQ, a: a, b: b }.
#ne_op(a, b)   => { tag: TAG_NE, a: a, b: b }.
#and_op(a, b) => { tag: TAG_AND, a: a, b: b }.
#or_op(a, b)  => { tag: TAG_OR, a: a, b: b }.
#not_op(a)    => { tag: TAG_NOT, a: a }.
#decl(name, expr, line) => { tag: TAG_DECL, name: name, expr: expr, line: line }.
#seq(a, b)  => { tag: TAG_SEQ, a: a, b: b }.
#assign(name, expr) => { tag: TAG_ASSIGN, name: name, expr: expr }.
#loop_stmt(body) => { tag: TAG_LOOP, body: body }.
#break_stmt() => { tag: TAG_BREAK }.
#if_expr(cond, then_br, else_br) => { tag: TAG_IF, cond: cond, then_br: then_br, else_br: else_br }.
#when_stmt(stmt, cond, line) => { tag: TAG_WHEN, stmt: stmt, cond: cond, line: line }.
#for_stmt(var, start, end, body) => { tag: TAG_FOR, var: var, start: start, end: end, body: body }.
#func_def(name, params, body) => { tag: TAG_FUNC, name: name, params: params, body: body }.
#func_call(name, args, line) => { tag: TAG_CALL, name: name, args: args, line: line }.
#return_stmt(expr) => { tag: TAG_RETURN, expr: expr }.
#match_expr(value, arms) => { tag: TAG_MATCH, value: value, arms: arms }.
#match_arm(pattern, body) => { tag: TAG_MATCH_ARM, pattern: pattern, body: body }.
#wildcard() => { tag: TAG_WILDCARD }.
#str_lit(value) => { tag: TAG_STRING, value: value }.
#arr_lit(elements) => { tag: TAG_ARRAY, elements: elements }.
#index_op(arr, idx) => { tag: TAG_INDEX, arr: arr, idx: idx }.
#obj_lit(fields) => { tag: TAG_OBJECT, fields: fields }.
#obj_field(key, value) => { tag: TAG_FIELD, key: key, value: value }.
#prop_op(obj, key) => { tag: TAG_PROP, obj: obj, key: key }.
#lambda_expr(params, body) => { tag: TAG_LAMBDA, params: params, body: body }.
#invoke_op(func, args) => { tag: TAG_INVOKE, func: func, args: args }.
