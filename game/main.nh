// nh - A NetHack-style Dungeon Crawler with Code Editor
// The player writes code to control the @ character

@use "intro.nh".
@use "audio.nh".
@use "bgshader.nh".
@use "editor.nh".
@use "player.nh".
@use "entity.nh".
@use "tech.nh".
@use "dungeon.nh".
@use "render.nh".
@use "particles.nh".
@use "combat.nh".
@use "bot.nh".

// ============================================================================
// Screen Layout - Responsive Two-Pane Layout
// ============================================================================

SCREEN_W := 1280.
SCREEN_H := 720.

ANIM_DURATION := 200.   // Animation duration in ms (base, scaled by speed)

// Split position (0.0 to 1.0, represents fraction of width for left pane)
split_ratio := 50.      // Stored as 0-100 (represents 0.0-1.0)
split_min_ratio := 20.  // Minimum left pane is 20%
split_max_ratio := 80.  // Maximum left pane is 80%

// Divider state
divider_x := 0.
divider_width := 12.
divider_padding := 6.  // Padding on each side of divider
divider_dragging := 0.
divider_hovered := 0.
divider_drag_start_x := 0.      // Mouse X when drag started
divider_drag_start_ratio := 0.  // Split ratio when drag started

// Left pane bounds
left_pane_x := 0.
left_pane_y := 0.
left_pane_w := 0.
left_pane_h := 0.

// Dungeon panel bounds (top of left pane, right-aligned)
dungeon_x := 0.
dungeon_y := 0.
dungeon_w := 0.
dungeon_h := 0.

// Tech tree bounds (bottom of left pane)
tech_tree_x := 0.
tech_tree_y := 0.
tech_tree_w := 0.
tech_tree_h := 0.
TECH_TREE_HEIGHT := 380.  // Height for tech tree panel (needs more room for 3 branches)

// Right pane / Editor bounds
panel_editor_x := 0.
panel_editor_y := 0.
panel_editor_w := 0.
panel_editor_h := 0.

// ============================================================================
// Game State
// ============================================================================

game_initialized := 0.

// ============================================================================
// Layout Calculation - Two-Pane Layout with Resizable Divider
// ============================================================================

// Button bar height
BUTTON_BAR_HEIGHT := 44.
LAYOUT_PADDING := 16.

#calculate_layout() >
    w := /get_screen_width/.
    h := /get_screen_height/.
    
    SCREEN_W = w.
    SCREEN_H = h.
    
    /setup_two_pane_layout/w/h.
<

#setup_two_pane_layout(w, h) >
    // Calculate split point based on ratio
    split_x := w * split_ratio / 100.
    
    // Clamp to minimum/maximum
    min_x := w * split_min_ratio / 100.
    max_x := w * split_max_ratio / 100.
    split_x = min_x when split_x lt min_x.
    split_x = max_x when split_x gt max_x.
    
    // Divider position (centered on split point)
    divider_x = split_x - divider_width / 2.
    
    // =========== LEFT PANE ===========
    left_pane_x = LAYOUT_PADDING.
    left_pane_y = LAYOUT_PADDING.
    left_pane_w = split_x - LAYOUT_PADDING - divider_width / 2 - divider_padding.
    left_pane_h = h - LAYOUT_PADDING * 2.
    
    // Split left pane into two equal halves vertically
    half_height := (left_pane_h - LAYOUT_PADDING) / 2.
    
    // ===== SHARED CONTENT WIDTH =====
    // Dungeon content width: map tiles + status bar (which extends further)
    // Status bar has attributes starting at +350 and extending to ~+700
    content_pix_w := 700.  // Wide enough for status bar
    
    // Use content width or pane width, whichever is smaller
    shared_pane_w := content_pix_w.
    shared_pane_w = left_pane_w when left_pane_w lt content_pix_w.
    
    // Calculate shared X position (right-aligned within left pane)
    shared_pane_x := left_pane_x + left_pane_w - shared_pane_w.
    shared_pane_x = left_pane_x when shared_pane_x lt left_pane_x.
    
    // ===== TOP HALF: Dungeon (bottom-right aligned within top half) =====
    top_half_y := left_pane_y.
    top_half_h := half_height.
    
    // Dungeon actual pixel dimensions (for vertical alignment)
    dungeon_pix_h := MAP_HEIGHT * TILE_H + 120.  // Include header + status lines
    
    dungeon_w = shared_pane_w.
    dungeon_h = top_half_h.
    dungeon_x = shared_pane_x.
    
    // Bottom-align within top half: push down if content is shorter
    dungeon_y = top_half_y.
    dungeon_y = top_half_y + top_half_h - dungeon_pix_h when dungeon_pix_h lt top_half_h.
    dungeon_y = top_half_y when dungeon_y lt top_half_y.  // Clamp to half
    
    // ===== BOTTOM HALF: Tech tree (uses full left pane width for 3 branches) =====
    bottom_half_y := left_pane_y + half_height + LAYOUT_PADDING.
    bottom_half_h := half_height.
    
    // Tech tree uses full left pane width (need room for 3 branches)
    tech_tree_w = left_pane_w.
    tech_tree_h = bottom_half_h.
    tech_tree_h = TECH_TREE_HEIGHT when bottom_half_h gt TECH_TREE_HEIGHT.
    
    // Position at left edge
    tech_tree_x = left_pane_x.
    
    // Vertically position within bottom half
    tech_tree_y = bottom_half_y + (bottom_half_h - tech_tree_h) / 2.
    tech_tree_y = bottom_half_y when tech_tree_y lt bottom_half_y.  // Clamp
    
    // =========== RIGHT PANE (EDITOR) ===========
    right_pane_x := split_x + divider_width / 2 + divider_padding.
    right_pane_y := LAYOUT_PADDING.
    right_pane_w := w - right_pane_x - LAYOUT_PADDING.
    right_pane_h := h - LAYOUT_PADDING * 2.
    
    // Button bar at top of right pane
    /set_button_positions/right_pane_x/right_pane_y.
    
    // Editor fills rest of right pane (below buttons)
    panel_editor_x = right_pane_x.
    panel_editor_y = right_pane_y + BUTTON_BAR_HEIGHT.
    panel_editor_w = right_pane_w.
    panel_editor_h = right_pane_h - BUTTON_BAR_HEIGHT.
    
    /set_editor_bounds/panel_editor_x/panel_editor_y/panel_editor_w/panel_editor_h.
<

// ============================================================================
// Game Init
// ============================================================================

#game_init() >
    /console_log/"nh dungeon with editor initializing...".
    seed := /time_ms/.
    /rng_seed/seed.
    /init_particles/.
    /init_entities/.
    /init_upgrades/.
    /init_background_shader/.
    /calculate_layout/.
    /generate_dungeon/.
    
    /init_editor/.
    /init_intro/.
    game_initialized = 1.
    /console_log/"Ready! Write code and click Play to run the bot.".
<

// ============================================================================
// Game Update
// ============================================================================

#game_update(dt) >
    // Skip if not initialized
    can_run := game_initialized.
    
    // Update intro if active
    /update_intro/dt when can_run == 1 and intro_active == 1.
    can_run = 0 when intro_active == 1.
    
    // Normal game update
    /do_update/dt when can_run == 1.
    /update_particles/ when can_run == 1.
<

#do_update(dt) >
    /calculate_layout/.
    
    // If dead, wait for restart (use buttons on death screen)
    can_update := 1.
    can_update = 0 when player_is_dead == 1.
    
    // Normal Update
    /do_normal_update/dt when can_update == 1.
<

#do_normal_update(dt) >
    // Update animation timer
    anim_timer = anim_timer - dt.
    anim_timer = 0 when anim_timer lt 0.
    
    // Update divider dragging (must be before other mouse handlers)
    /update_divider/.
    
    // Update buttons and slider (must be before editor to intercept clicks)
    /update_slider/.
    /update_buttons/.
    /update_tech_tree/.
    
    // Update editor (handles all input)
    /editor_update/dt.
    
    // Bot execution with timing
    /update_bot_runner/dt when bot_is_running == 1.
    
    // Check for death (manual or bot)
    died := /check_player_death/.
    /bot_stop/ when died == 1.
<

// ============================================================================
// Divider Update - Handle Resizing
// ============================================================================

#update_divider() >
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    down := /input_mouse_down/.
    just_pressed := /input_mouse_just_pressed/.
    
    // Check if mouse is over divider (with some padding for easier grabbing)
    grab_padding := 8.
    in_divider := mx ge divider_x - grab_padding and mx lt divider_x + divider_width + grab_padding.
    in_divider = in_divider * (my ge LAYOUT_PADDING and my lt SCREEN_H - LAYOUT_PADDING).
    
    // Update hover state
    divider_hovered = 0.
    divider_hovered = 1 when in_divider == 1.
    
    // Start dragging - store starting position and ratio
    divider_drag_start_x = mx when just_pressed == 1 and in_divider == 1.
    divider_drag_start_ratio = split_ratio when just_pressed == 1 and in_divider == 1.
    divider_dragging = 1 when just_pressed == 1 and in_divider == 1.
    
    // Stop dragging
    divider_dragging = 0 when down == 0.
    
    // Update split ratio based on mouse movement delta
    /update_split_from_drag/mx when divider_dragging == 1.
<

#update_split_from_drag(mx) >
    // Calculate how far mouse moved from drag start
    delta_x := mx - divider_drag_start_x.
    
    // Convert pixel delta to ratio delta (percentage of screen width)
    delta_ratio := delta_x * 100 / SCREEN_W.
    
    // New ratio = starting ratio + delta
    new_ratio := divider_drag_start_ratio + delta_ratio.
    
    // Clamp to min/max
    new_ratio = split_min_ratio when new_ratio lt split_min_ratio.
    new_ratio = split_max_ratio when new_ratio gt split_max_ratio.
    
    split_ratio = new_ratio.
<

#update_bot_runner(dt) >
    bot_step_timer = bot_step_timer + dt.
    
    // Cap ticks per frame to prevent freeze on very high speeds
    max_ticks := 100.
    ticks := 0.
    
    loop >
        << 0 when bot_step_timer lt bot_step_delay.
        << 0 when bot_is_running == 0.
        << 0 when ticks ge max_ticks.
        
        bot_step_timer = bot_step_timer - bot_step_delay.
        /bot_run_tick/.
        ticks = ticks + 1.
        
        // Check for death inside loop too?
        // Yes, if bot kills us, stop immediately
        died := /check_player_death/.
        /bot_stop/ when died == 1.
        // Break loop (by setting ticks = max)
        ticks = max_ticks when died == 1.
    <
<

// ============================================================================
// Rendering
// ============================================================================

#game_render() >
    // Skip if not initialized
    can_run := game_initialized.
    
    // Render intro if active (no CRT effects)
    /text_clear/ when can_run == 1 and intro_active == 1.
    /render_intro/ when can_run == 1 and intro_active == 1.
    can_run = 0 when intro_active == 1.
    
    // Normal game render
    /do_render/ when can_run == 1.
<

#do_render() >
    // Calculate player position for torch effect shader
    px := dungeon_x + player_x * TILE_W.
    py := dungeon_y + 12 + player_y * TILE_H.

    // Render swirly background shader with player position for torch effect
    /render_background/px/py.

    /text_clear/.
    
    // Draw the divider between panes
    /draw_divider/.
    
    // Draw tech tree placeholder (bottom of left pane)
    /draw_tech_tree/.
    
    /render_dungeon/.
    /draw_entities/.
    /draw_player/.
    /draw_particles/.
    /draw_buttons/.
    /draw_slider/.
    /render_editor/.
    
    // Tombstone on top
    /draw_tombstone/ when player_is_dead == 1.
<

// ============================================================================
// Divider Rendering
// ============================================================================

#draw_divider() >
    dx := divider_x.
    dy := LAYOUT_PADDING.
    dw := divider_width.
    dh := SCREEN_H - LAYOUT_PADDING * 2.
    
    // Base color (darker when not hovered)
    r := 40. g := 45. b := 55.
    
    // Highlight when hovered or dragging
    r = 60 when divider_hovered == 1. g = 70 when divider_hovered == 1. b = 85 when divider_hovered == 1.
    r = 80 when divider_dragging == 1. g = 100 when divider_dragging == 1. b = 130 when divider_dragging == 1.
    
    // Draw divider background
    /draw_rect/dx/dy/dw/dh/r/g/b/255.
    
    // Draw grip icon in center (three horizontal lines)
    icon_x := dx + dw / 2 - 3.
    icon_y := SCREEN_H / 2 - 15.
    grip_r := 100. grip_g := 110. grip_b := 130.
    grip_r = 140 when divider_hovered == 1. grip_g = 160 when divider_hovered == 1. grip_b = 190 when divider_hovered == 1.
    grip_r = 180 when divider_dragging == 1. grip_g = 200 when divider_dragging == 1. grip_b = 230 when divider_dragging == 1.
    
    /draw_rect/icon_x/icon_y/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 6)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 12)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 18)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 24)/6/2/grip_r/grip_g/grip_b/255.
<

// ============================================================================
// Tech Tree UI - Clean Implementation with Clipping
// ============================================================================

// Layout constants - increased sizes for better readability
TREE_PADDING := 24.
TREE_HEADER_H := 36.
NODE_PAD_X := 10.
NODE_PAD_Y := 8.
NODE_W := 110.     // Wide enough for all text with padding
NODE_H := 42.
NODE_GAP_X := 10.
NODE_GAP_Y := 14.
BRANCH_GAP := 35.

// Scroll state
tech_scroll_x := 0.
tech_scroll_y := 0.
tech_dragging := 0.
tech_drag_start_x := 0.
tech_drag_start_y := 0.
tech_drag_scroll_x := 0.
tech_drag_scroll_y := 0.

// Interaction state
tech_hovered := -1.
tech_clicked := -1.

// Clipping bounds (set during draw)
clip_x := 0.
clip_y := 0.
clip_w := 0.
clip_h := 0.

#draw_tech_tree() >
    tx := tech_tree_x.
    ty := tech_tree_y.
    tw := tech_tree_w.
    th := tech_tree_h.
    
    // Reset hover state
    tech_hovered = -1.
    
    // ===== BACKGROUND & BORDER =====
    /draw_rect/tx/ty/tw/th/12/14/18/255.
    /draw_panel_border/tx/ty/tw/th.
    
    // ===== HEADER =====
    /draw_rect/tx/ty/tw/TREE_HEADER_H/20/22/28/255.
    /draw_rect/tx/(ty + TREE_HEADER_H - 1)/tw/1/35/40/50/255.
    
    /text_draw/(tx + TREE_PADDING)/(ty + 12)/13/180/160/100/"UPGRADES".
    
    // Bank (right side)
    /text_draw/(tx + tw - 100)/(ty + 12)/12/80/180/80/"Bank: $".
    /text_draw_int/(tx + tw - 40)/(ty + 12)/12/100/220/100/player_bank.
    
    // Center button
    /draw_center_btn/(tx + tw / 2 - 30)/(ty + 8).
    
    // ===== CONTENT AREA (clipped) =====
    clip_x = tx + 2.
    clip_y = ty + TREE_HEADER_H.
    clip_w = tw - 4.
    clip_h = th - TREE_HEADER_H - 2.
    
    /set_clip_rect/clip_x/clip_y/clip_w/clip_h.
    
    // Base position for tree (scrollable)
    bx := clip_x + TREE_PADDING + tech_scroll_x.
    by := clip_y + clip_h - TREE_PADDING + tech_scroll_y.
    
    // Calculate branch widths
    branch_w := NODE_W * 3 + NODE_GAP_X * 2.
    
    // ===== DRAW BRANCHES =====
    // Each branch: draw lines first, then nodes
    
    // BUFF branch
    /draw_buff_tree/bx/by.
    
    // DIFFICULTY branch
    diff_x := bx + branch_w + BRANCH_GAP.
    /draw_diff_tree/diff_x/by.
    
    // LANGUAGE branch
    lang_x := diff_x + branch_w + BRANCH_GAP.
    /draw_lang_tree/lang_x/by.
    
    /clear_clip_rect/.
    
    // ===== TOOLTIP (drawn on top, outside clip) =====
    /draw_node_tooltip/ when tech_hovered != -1.
    
    // ===== TUTORIAL POPUP =====
    /draw_tutorial_popup/ when tutorial_active == 1.
<

// ============================================================================
// Panel Border Helper
// ============================================================================

#draw_panel_border(x, y, w, h) >
    /draw_rect/x/y/w/2/35/40/50/255.
    /draw_rect/x/(y + h - 2)/w/2/25/28/35/255.
    /draw_rect/x/y/2/h/35/40/50/255.
    /draw_rect/(x + w - 2)/y/2/h/25/28/35/255.
<

// ============================================================================
// Center Button
// ============================================================================

#draw_center_btn(x, y) >
    bw := 60.
    bh := 20.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    hovered := mx ge x and mx lt x + bw and my ge y and my lt y + bh.
    
    bg := 25.
    bg = 40 when hovered == 1.
    /draw_rect/x/y/bw/bh/bg/(bg + 5)/(bg + 10)/255.
    
    br := 50.
    br = 80 when hovered == 1.
    /draw_rect/x/y/bw/1/br/(br + 10)/(br + 20)/255.
    /draw_rect/x/(y + bh - 1)/bw/1/(br - 10)/br/(br + 5)/255.
    
    tc := 120.
    tc = 180 when hovered == 1.
    /text_draw/(x + 10)/(y + 4)/10/tc/tc/(tc + 20)/"Center".
    
    // Handle click
    just_clicked := /input_mouse_just_pressed/.
    >
        tech_scroll_x = 0.
        tech_scroll_y = 0.
    < when just_clicked == 1 and hovered == 1.
<

// ============================================================================
// Tree Drawing - Simplified Data-Driven Approach
// ============================================================================

// Each tree is drawn as a grid of nodes with explicit connections
// Using draw_line for proper bezier-like connections

#draw_buff_tree(bx, by) >
    // Grid positions: col 0-2, row 0-5 (bottom to top)
    nw := NODE_W.
    nh := NODE_H.
    gx := NODE_GAP_X.
    gy := NODE_GAP_Y + 8.
    
    // Calculate node positions
    row0 := by - nh.
    row1 := row0 - nh - gy.
    row2 := row1 - nh - gy.
    row3 := row2 - nh - gy.
    row4 := row3 - nh - gy.
    row5 := row4 - nh - gy.
    
    col0 := bx.
    col1 := bx + nw + gx.
    col2 := bx + (nw + gx) * 2.
    
    // Draw connections first (behind nodes)
    lr := 45. lg := 55. lb := 70.
    
    // Row 0 -> Row 1 (1->3)
    /draw_tree_conn/(col1 + nw / 2)/(row0 - 2)/(col0 + nw / 2)/(row1 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row0 - 2)/(col1 + nw / 2)/(row1 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row0 - 2)/(col2 + nw / 2)/(row1 + nh + 2)/lr/lg/lb.
    
    // Row 1 col 0,1 -> Row 2 col 0 (Gold Drop)
    /draw_tree_conn/(col0 + nw / 2)/(row1 - 2)/(col0 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row1 - 2)/(col0 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    
    // Row 1 col 2 -> Row 2 col 2 (speed)
    /draw_tree_conn/(col2 + nw / 2)/(row1 - 2)/(col2 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    
    // Vertical chains
    /draw_tree_conn/(col0 + nw / 2)/(row2 - 2)/(col0 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col0 + nw / 2)/(row3 - 2)/(col0 + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col0 + nw / 2)/(row4 - 2)/(col0 + nw / 2)/(row5 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row2 - 2)/(col2 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row3 - 2)/(col2 + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    
    // Draw nodes
    /draw_node/col1/row0/UPGRADE_BUFF_START.
    /draw_node/col0/row1/UPGRADE_BUFF_HP_1.
    /draw_node/col1/row1/UPGRADE_BUFF_STR_1.
    /draw_node/col2/row1/UPGRADE_BUFF_SPEED_5.
    /draw_node/col0/row2/UPGRADE_BUFF_GOLD_DROP.
    /draw_node/col2/row2/UPGRADE_BUFF_SPEED_10.
    /draw_node/col0/row3/UPGRADE_BUFF_HP_2.
    /draw_node/col2/row3/UPGRADE_BUFF_SPEED_100.
    /draw_node/col0/row4/UPGRADE_BUFF_GOLD_SPAWN.
    /draw_node/col2/row4/UPGRADE_BUFF_SPEED_1000.
    /draw_node/col0/row5/UPGRADE_BUFF_HEAL_STAIRS.
<

#draw_diff_tree(bx, by) >
    nw := NODE_W.
    nh := NODE_H.
    gx := NODE_GAP_X.
    gy := NODE_GAP_Y + 8.
    
    row0 := by - nh.
    row1 := row0 - nh - gy.
    row2 := row1 - nh - gy.
    row3 := row2 - nh - gy.
    row4 := row3 - nh - gy.
    row5 := row4 - nh - gy.
    
    col0 := bx.
    col1 := bx + nw + gx.
    colm := bx + (nw + gx) / 2.
    
    lr := 45. lg := 55. lb := 70.
    
    // Root -> split
    /draw_tree_conn/(colm + nw / 2)/(row0 - 2)/(col0 + nw / 2)/(row1 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row0 - 2)/(col1 + nw / 2)/(row1 + nh + 2)/lr/lg/lb.
    
    // Parallel chains
    /draw_tree_conn/(col0 + nw / 2)/(row1 - 2)/(col0 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row1 - 2)/(col1 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    
    // Merge to center
    /draw_tree_conn/(col0 + nw / 2)/(row2 - 2)/(colm + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row2 - 2)/(colm + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    
    // Split again
    /draw_tree_conn/(colm + nw / 2)/(row3 - 2)/(col0 + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row3 - 2)/(col1 + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    
    // Final merge
    /draw_tree_conn/(col0 + nw / 2)/(row4 - 2)/(colm + nw / 2)/(row5 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row4 - 2)/(colm + nw / 2)/(row5 + nh + 2)/lr/lg/lb.
    
    // Draw nodes
    /draw_node/colm/row0/UPGRADE_DIFF_ROOM_2.
    /draw_node/col0/row1/UPGRADE_DIFF_VAR_SIZE.
    /draw_node/col1/row1/UPGRADE_DIFF_MONSTER_1.
    /draw_node/col0/row2/UPGRADE_DIFF_ROOM_3.
    /draw_node/col1/row2/UPGRADE_DIFF_STAIRS_RANDOM.
    /draw_node/colm/row3/UPGRADE_DIFF_MONSTER_2.
    /draw_node/col0/row4/UPGRADE_DIFF_ROOM_4.
    /draw_node/col1/row4/UPGRADE_DIFF_MONSTER_3.
    /draw_node/colm/row5/UPGRADE_DIFF_ROOM_MANY.
<

#draw_lang_tree(bx, by) >
    nw := NODE_W.
    nh := NODE_H.
    gx := NODE_GAP_X.
    gy := NODE_GAP_Y + 8.
    
    row0 := by - nh.
    row1 := row0 - nh - gy.
    row2 := row1 - nh - gy.
    row3 := row2 - nh - gy.
    row4 := row3 - nh - gy.
    row5 := row4 - nh - gy.
    
    col0 := bx.
    col1 := bx + nw + gx.
    colm := bx + (nw + gx) / 2.
    
    lr := 45. lg := 55. lb := 70.
    
    // Straight down
    /draw_tree_conn/(colm + nw / 2)/(row0 - 2)/(colm + nw / 2)/(row1 + nh + 2)/lr/lg/lb.
    
    // Split
    /draw_tree_conn/(colm + nw / 2)/(row1 - 2)/(col0 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row1 - 2)/(col1 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    
    // Parallel
    /draw_tree_conn/(col0 + nw / 2)/(row2 - 2)/(col0 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row2 - 2)/(col1 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    
    // Merge
    /draw_tree_conn/(col0 + nw / 2)/(row3 - 2)/(colm + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row3 - 2)/(colm + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    
    // Split
    /draw_tree_conn/(colm + nw / 2)/(row4 - 2)/(col0 + nw / 2)/(row5 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row4 - 2)/(col1 + nw / 2)/(row5 + nh + 2)/lr/lg/lb.
    
    // Draw nodes
    /draw_node/colm/row0/UPGRADE_LANG_VARIABLES.
    /draw_node/colm/row1/UPGRADE_LANG_FUNCTIONS.
    /draw_node/col0/row2/UPGRADE_LANG_LOOPS.
    /draw_node/col1/row2/UPGRADE_LANG_CONDITIONS.
    /draw_node/col0/row3/UPGRADE_LANG_ARRAYS.
    /draw_node/col1/row3/UPGRADE_LANG_PIPES.
    /draw_node/colm/row4/UPGRADE_LANG_STRUCTS.
    /draw_node/col0/row5/UPGRADE_LANG_PATTERN.
    /draw_node/col1/row5/UPGRADE_LANG_LAMBDA.
<

// Draw connection line between nodes (top of lower node to bottom of upper node)
#draw_tree_conn(x1, y1, x2, y2, r, g, b) >
    // Check if line is at all visible in clip region
    min_x := x1.
    min_x = x2 when x2 lt x1.
    max_x := x1.
    max_x = x2 when x2 gt x1.
    min_y := y1.
    min_y = y2 when y2 lt y1.
    max_y := y1.
    max_y = y2 when y2 gt y1.
    
    // Skip if completely outside clip
    << 0 when max_x lt clip_x.
    << 0 when min_x gt clip_x + clip_w.
    << 0 when max_y lt clip_y.
    << 0 when min_y gt clip_y + clip_h.
    
    // Use runtime draw_line for proper anti-aliased line
    /draw_line/x1/y1/x2/y2/2/r/g/b/200.
<

// ============================================================================
// Node Drawing - Fixed width for consistent layout
// ============================================================================

#draw_node(x, y, upgrade_id) >
    nw := NODE_W.
    nh := NODE_H.
    
    // Clip check
    << 0 when x + nw lt clip_x.
    << 0 when x gt clip_x + clip_w.
    << 0 when y + nh lt clip_y.
    << 0 when y gt clip_y + clip_h.
    
    // State
    has := /has_upgrade/upgrade_id.
    can := /can_unlock_upgrade/upgrade_id.
    cost := /get_upgrade_cost/upgrade_id.
    affordable := player_bank ge cost.
    available := can * affordable.
    branch := /get_upgrade_branch/upgrade_id.
    
    // Check hover (only if mouse in content area)
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    in_node := mx ge x and mx lt x + nw and my ge y and my lt y + nh.
    in_clip := mx ge clip_x and mx lt clip_x + clip_w and my ge clip_y and my lt clip_y + clip_h.
    hovered := in_node * in_clip.
    tech_hovered = upgrade_id when hovered == 1.
    
    // Base colors by branch
    // 0 = buff (warm), 1 = diff (green), 2 = lang (blue)
    bg_r := 28. bg_g := 30. bg_b := 35.
    br_r := 50. br_g := 55. br_b := 65.
    
    // Tint by branch when locked
    br_r = 90 when branch == 0 and has == 0. br_g = 55 when branch == 0 and has == 0. br_b = 45 when branch == 0 and has == 0.
    br_r = 55 when branch == 1 and has == 0. br_g = 75 when branch == 1 and has == 0. br_b = 55 when branch == 1 and has == 0.
    br_r = 45 when branch == 2 and has == 0. br_g = 65 when branch == 2 and has == 0. br_b = 90 when branch == 2 and has == 0.
    
    // Available = brighter border
    br_r = 170 when available == 1 and branch == 0. br_g = 110 when available == 1 and branch == 0. br_b = 70 when available == 1 and branch == 0.
    br_r = 100 when available == 1 and branch == 1. br_g = 150 when available == 1 and branch == 1. br_b = 100 when available == 1 and branch == 1.
    br_r = 70 when available == 1 and branch == 2. br_g = 140 when available == 1 and branch == 2. br_b = 190 when available == 1 and branch == 2.
    bg_r = 38 when available == 1. bg_g = 42 when available == 1. bg_b = 48 when available == 1.
    
    // Can unlock but can't afford = dimmer
    just_can := can * (1 - affordable).
    br_r = 120 when just_can == 1. br_g = 80 when just_can == 1. br_b = 50 when just_can == 1.
    
    // Owned = filled with branch color
    bg_r = 55 when has == 1 and branch == 0. bg_g = 40 when has == 1 and branch == 0. bg_b = 35 when has == 1 and branch == 0.
    br_r = 200 when has == 1 and branch == 0. br_g = 150 when has == 1 and branch == 0. br_b = 100 when has == 1 and branch == 0.
    bg_r = 35 when has == 1 and branch == 1. bg_g = 50 when has == 1 and branch == 1. bg_b = 35 when has == 1 and branch == 1.
    br_r = 100 when has == 1 and branch == 1. br_g = 180 when has == 1 and branch == 1. br_b = 100 when has == 1 and branch == 1.
    bg_r = 35 when has == 1 and branch == 2. bg_g = 45 when has == 1 and branch == 2. bg_b = 60 when has == 1 and branch == 2.
    br_r = 90 when has == 1 and branch == 2. br_g = 160 when has == 1 and branch == 2. br_b = 220 when has == 1 and branch == 2.
    
    // Hover boost
    bg_r = bg_r + 15 when hovered == 1.
    bg_g = bg_g + 15 when hovered == 1.
    bg_b = bg_b + 15 when hovered == 1.
    
    // Draw node
    /draw_rect/x/y/nw/nh/bg_r/bg_g/bg_b/255.
    
    // Border - consistent 2px on all sides
    /draw_rect/x/y/nw/2/br_r/br_g/br_b/255.
    /draw_rect/x/(y + nh - 2)/nw/2/(br_r * 7 / 10)/(br_g * 7 / 10)/(br_b * 7 / 10)/255.
    /draw_rect/x/y/2/nh/br_r/br_g/br_b/255.
    /draw_rect/(x + nw - 2)/y/2/nh/(br_r * 7 / 10)/(br_g * 7 / 10)/(br_b * 7 / 10)/255.
    
    // Text - upgrade name
    name := /get_upgrade_name/upgrade_id.
    tx := x + NODE_PAD_X.
    ty := y + 8.
    
    tr := 130. tg := 135. tb := 145.
    tr = 220 when available == 1. tg = 200 when available == 1. tb = 150 when available == 1.
    tr = 190 when has == 1. tg = 210 when has == 1. tb = 220 when has == 1.
    
    /text_draw/tx/ty/10/tr/tg/tb/name.
    
    // Cost or status - on second line
    cy := y + 26.
    >
        /text_draw/(x + nw / 2 - 12)/cy/11/100/180/100/"OK".
    < when has == 1.
    >
        cr := 95. cg := 100. cb := 110.
        cr = 100 when available == 1. cg = 190 when available == 1. cb = 100 when available == 1.
        cr = 190 when just_can == 1. cg = 140 when just_can == 1. cb = 80 when just_can == 1.
        /text_draw/(x + NODE_PAD_X)/cy/10/cr/cg/cb/"$".
        /text_draw_int/(x + NODE_PAD_X + 12)/cy/10/cr/cg/cb/cost.
    < when has == 0.
<

#draw_node_tooltip() >
    upgrade_id := tech_hovered.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    
    // Get text
    name := /get_upgrade_name/upgrade_id.
    desc := /get_upgrade_desc/upgrade_id.
    
    // Fixed width - large enough for longest description
    // "Floors have 5+ rooms (+$2)" = 26 chars
    tw := 240.
    th := 55.
    
    // Position offset from mouse
    tx := mx + 18.
    ty := my - 60.
    
    // Keep on screen
    tx = tech_tree_x + tech_tree_w - tw - 10 when tx + tw gt tech_tree_x + tech_tree_w.
    ty = tech_tree_y + TREE_HEADER_H + 5 when ty lt tech_tree_y + TREE_HEADER_H.
    
    // Background
    /draw_rect/tx/ty/tw/th/22/25/32/245.
    
    // Border - consistent 2px
    /draw_rect/tx/ty/tw/2/70/80/100/255.
    /draw_rect/tx/(ty + th - 2)/tw/2/35/40/50/255.
    /draw_rect/tx/ty/2/th/60/70/90/255.
    /draw_rect/(tx + tw - 2)/ty/2/th/35/40/50/255.
    
    // Name
    /text_draw/(tx + 10)/(ty + 10)/11/220/210/170/name.
    
    // Description
    /text_draw/(tx + 10)/(ty + 30)/9/155/160/175/desc.
<

#draw_tutorial_popup() >
    // Draw centered tutorial popup
    cx := tech_tree_x + tech_tree_w / 2.
    cy := tech_tree_y + tech_tree_h / 2.
    
    pw := 280.
    ph := 200.
    px := cx - pw / 2.
    py := cy - ph / 2.
    
    // Background with border
    /draw_rect/px/py/pw/ph/20/25/35/250.
    /draw_rect/px/py/pw/2/80/160/200/255.
    /draw_rect/px/(py + ph - 2)/pw/2/40/80/100/255.
    /draw_rect/px/py/2/ph/60/120/160/255.
    /draw_rect/(px + pw - 2)/py/2/ph/60/120/160/255.
    
    // Title
    /text_draw/(px + 10)/(py + 10)/14/100/200/255/tutorial_line_1.
    
    // Tutorial text
    /text_draw/(px + 10)/(py + 35)/10/200/200/210/tutorial_line_2.
    /text_draw/(px + 10)/(py + 50)/10/200/200/210/tutorial_line_3.
    /text_draw/(px + 10)/(py + 65)/10/200/200/210/tutorial_line_4.
    
    // Code examples
    /text_draw/(px + 10)/(py + 90)/10/255/220/100/tutorial_code_1.
    /text_draw/(px + 10)/(py + 105)/10/255/220/100/tutorial_code_2.
    /text_draw/(px + 10)/(py + 120)/10/255/220/100/tutorial_code_3.
    
    // Close button
    btn_x := px + pw / 2 - 40.
    btn_y := py + ph - 35.
    btn_w := 80.
    btn_h := 25.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    btn_hover := mx ge btn_x and mx lt btn_x + btn_w and my ge btn_y and my lt btn_y + btn_h.
    
    bg_r := 40. bg_g := 80. bg_b := 100.
    bg_r = 60 when btn_hover == 1. bg_g = 120 when btn_hover == 1. bg_b = 150 when btn_hover == 1.
    
    /draw_rect/btn_x/btn_y/btn_w/btn_h/bg_r/bg_g/bg_b/255.
    /draw_rect/btn_x/btn_y/btn_w/1/100/180/220/255.
    
    /text_draw/(btn_x + 22)/(btn_y + 6)/12/220/240/255/"GOT IT".
    
    // Handle click
    just_clicked := /input_mouse_just_pressed/.
    /close_tutorial/ when just_clicked == 1 and btn_hover == 1.
<

#update_tech_tree() >
    // Skip if tutorial is active
    << 0 when tutorial_active == 1.
    
    // Handle drag scrolling
    /update_tech_drag/.
    
    // Check for click (only if not dragging)
    just_clicked := /input_mouse_just_pressed/.
    << 0 when just_clicked == 0.
    
    // Skip if we were dragging
    drag_dx := /input_mouse_x/ - tech_drag_start_x.
    drag_dy := /input_mouse_y/ - tech_drag_start_y.
    drag_dx = 0 - drag_dx when drag_dx lt 0.
    drag_dy = 0 - drag_dy when drag_dy lt 0.
    << 0 when drag_dx gt 5 or drag_dy gt 5.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    
    // Check if in content area
    in_x := mx ge clip_x and mx lt clip_x + clip_w.
    in_y := my ge clip_y and my lt clip_y + clip_h.
    << 0 when in_x * in_y == 0.
    
    // Calculate positions (must match draw_*_tree)
    nw := NODE_W.
    nh := NODE_H.
    gx := NODE_GAP_X.
    gy := NODE_GAP_Y + 8.
    branch_w := NODE_W * 3 + NODE_GAP_X * 2.
    
    bx := clip_x + TREE_PADDING + tech_scroll_x.
    by := clip_y + clip_h - TREE_PADDING + tech_scroll_y.
    
    // Row positions
    row0 := by - nh.
    row1 := row0 - nh - gy.
    row2 := row1 - nh - gy.
    row3 := row2 - nh - gy.
    row4 := row3 - nh - gy.
    row5 := row4 - nh - gy.
    
    // BUFF tree columns
    col0 := bx.
    col1 := bx + nw + gx.
    col2 := bx + (nw + gx) * 2.
    
    /try_node_click/col1/row0/UPGRADE_BUFF_START/mx/my.
    /try_node_click/col0/row1/UPGRADE_BUFF_HP_1/mx/my.
    /try_node_click/col1/row1/UPGRADE_BUFF_STR_1/mx/my.
    /try_node_click/col2/row1/UPGRADE_BUFF_SPEED_5/mx/my.
    /try_node_click/col0/row2/UPGRADE_BUFF_GOLD_DROP/mx/my.
    /try_node_click/col2/row2/UPGRADE_BUFF_SPEED_10/mx/my.
    /try_node_click/col0/row3/UPGRADE_BUFF_HP_2/mx/my.
    /try_node_click/col2/row3/UPGRADE_BUFF_SPEED_100/mx/my.
    /try_node_click/col0/row4/UPGRADE_BUFF_GOLD_SPAWN/mx/my.
    /try_node_click/col2/row4/UPGRADE_BUFF_SPEED_1000/mx/my.
    /try_node_click/col0/row5/UPGRADE_BUFF_HEAL_STAIRS/mx/my.
    
    // DIFF tree
    diff_x := bx + branch_w + BRANCH_GAP.
    dcol0 := diff_x.
    dcol1 := diff_x + nw + gx.
    dcolm := diff_x + (nw + gx) / 2.
    
    /try_node_click/dcolm/row0/UPGRADE_DIFF_ROOM_2/mx/my.
    /try_node_click/dcol0/row1/UPGRADE_DIFF_VAR_SIZE/mx/my.
    /try_node_click/dcol1/row1/UPGRADE_DIFF_MONSTER_1/mx/my.
    /try_node_click/dcol0/row2/UPGRADE_DIFF_ROOM_3/mx/my.
    /try_node_click/dcol1/row2/UPGRADE_DIFF_STAIRS_RANDOM/mx/my.
    /try_node_click/dcolm/row3/UPGRADE_DIFF_MONSTER_2/mx/my.
    /try_node_click/dcol0/row4/UPGRADE_DIFF_ROOM_4/mx/my.
    /try_node_click/dcol1/row4/UPGRADE_DIFF_MONSTER_3/mx/my.
    /try_node_click/dcolm/row5/UPGRADE_DIFF_ROOM_MANY/mx/my.
    
    // LANG tree
    lang_x := diff_x + branch_w + BRANCH_GAP.
    lcol0 := lang_x.
    lcol1 := lang_x + nw + gx.
    lcolm := lang_x + (nw + gx) / 2.
    
    /try_node_click/lcolm/row0/UPGRADE_LANG_VARIABLES/mx/my.
    /try_node_click/lcolm/row1/UPGRADE_LANG_FUNCTIONS/mx/my.
    /try_node_click/lcol0/row2/UPGRADE_LANG_LOOPS/mx/my.
    /try_node_click/lcol1/row2/UPGRADE_LANG_CONDITIONS/mx/my.
    /try_node_click/lcol0/row3/UPGRADE_LANG_ARRAYS/mx/my.
    /try_node_click/lcol1/row3/UPGRADE_LANG_PIPES/mx/my.
    /try_node_click/lcolm/row4/UPGRADE_LANG_STRUCTS/mx/my.
    /try_node_click/lcol0/row5/UPGRADE_LANG_PATTERN/mx/my.
    /try_node_click/lcol1/row5/UPGRADE_LANG_LAMBDA/mx/my.
<

#update_tech_drag() >
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    down := /input_mouse_down/.
    just := /input_mouse_just_pressed/.
    
    // In content area?
    in_x := mx ge clip_x and mx lt clip_x + clip_w.
    in_y := my ge clip_y and my lt clip_y + clip_h.
    in_content := in_x * in_y.
    
    // Start drag
    >
        tech_drag_start_x = mx.
        tech_drag_start_y = my.
        tech_drag_scroll_x = tech_scroll_x.
        tech_drag_scroll_y = tech_scroll_y.
        tech_dragging = 1.
    < when just == 1 and in_content == 1.
    
    // Stop drag
    tech_dragging = 0 when down == 0.
    
    // Update scroll while dragging
    >
        tech_scroll_x = tech_drag_scroll_x + (mx - tech_drag_start_x).
        tech_scroll_y = tech_drag_scroll_y + (my - tech_drag_start_y).
    < when tech_dragging == 1.
<

#try_node_click(x, y, upgrade_id, mx, my) >
    nw := NODE_W.
    nh := NODE_H.
    in_x := mx ge x and mx lt x + nw.
    in_y := my ge y and my lt y + nh.
    << 0 when in_x * in_y == 0.
    
    result := /try_purchase_upgrade/upgrade_id.
    // Restart bot and regenerate dungeon when purchased
    >
        /generate_dungeon/.
        /bot_reset_on_change/.
    < when result == 1.
<
