// nh - A NetHack-style Dungeon Crawler with Code Editor
// The player writes code to control the @ character

@use "bgshader.nh".
@use "editor.nh".
@use "player.nh".
@use "entity.nh".
@use "dungeon.nh".
@use "render.nh".
@use "particles.nh".
@use "combat.nh".
@use "bot.nh".

// ============================================================================
// Screen Layout - Responsive
// ============================================================================

SCREEN_W := 1280.
SCREEN_H := 720.

// Layout mode: 0 = side by side, 1 = stacked (editor below)
layout_mode := 0.

ANIM_DURATION := 200.   // Animation duration in ms (base, scaled by speed)

// Panel bounds
dungeon_x := 0.
dungeon_y := 0.
dungeon_w := 0.
dungeon_h := 0.

panel_editor_x := 0.
panel_editor_y := 0.
panel_editor_w := 0.
panel_editor_h := 0.

// ============================================================================
// Game State
// ============================================================================

game_initialized := 0.

// ============================================================================
// Layout Calculation - Truly Responsive
// ============================================================================

#calculate_layout() >
    w := /get_screen_width/.
    h := /get_screen_height/.
    
    SCREEN_W = w.
    SCREEN_H = h.
    
    // Stacked layout if height > width (portrait mode)
    layout_mode = 1 when h gt w.
    layout_mode = 0 when w ge h.
    
    /setup_side_layout/w/h when layout_mode == 0.
    /setup_stacked_layout/w/h when layout_mode == 1.
<

// Button bar height
BUTTON_BAR_HEIGHT := 44.

#setup_side_layout(w, h) >
    // Calculate split point
    split_x := w / 2.

    // Calculate dungeon size (just for reference or centering)
    dw := MAP_WIDTH * TILE_W + 40.
    
    // Dungeon on left (centered in left half?)
    // For now keep at 20, or maybe center it? 
    // Let's keep it at 20 for simplicity unless requested.
    dungeon_x = 20.
    dungeon_y = 20.
    dungeon_w = split_x - 40.
    dungeon_h = h - 40.
    
    // Editor fills right half
    panel_editor_x = split_x + 20.
    panel_editor_y = 20 + BUTTON_BAR_HEIGHT.
    panel_editor_w = (w - split_x) - 40.
    panel_editor_h = h - 40 - BUTTON_BAR_HEIGHT.
    
    /set_editor_bounds/panel_editor_x/panel_editor_y/panel_editor_w/panel_editor_h.
    /set_button_positions/(split_x + 20)/20.
<

#setup_stacked_layout(w, h) >
    half_h := h / 2.
    
    // Dungeon on top
    dungeon_x = 20.
    dungeon_y = 10.
    dungeon_w = w - 40.
    dungeon_h = half_h - 20.
    
    // Editor on bottom (with button bar above)
    panel_editor_x = 20.
    panel_editor_y = half_h + 10 + BUTTON_BAR_HEIGHT.
    panel_editor_w = w - 40.
    panel_editor_h = half_h - 20 - BUTTON_BAR_HEIGHT.
    
    /set_editor_bounds/panel_editor_x/panel_editor_y/panel_editor_w/panel_editor_h.
    /set_button_positions/20/(half_h + 10).
<

// ============================================================================
// Game Init
// ============================================================================

#game_init() >
    /console_log/"nh dungeon with editor initializing...".
    seed := /time_ms/.
    /rng_seed/seed.
    /init_particles/.
    /init_entities/.
    /init_background_shader/.
    /calculate_layout/.
    /generate_dungeon/.
    

    /init_editor/.
    game_initialized = 1.
    /console_log/"Ready! Write code and click Play to run the bot.".
<

// ============================================================================
// Game Update
// ============================================================================

#game_update(dt) >
    /do_update/dt when game_initialized == 1.
    /update_particles/ when game_initialized == 1.
<

#do_update(dt) >
    /calculate_layout/.
    
    // If dead, wait for restart
    can_update := 1.
    can_update = 0 when player_is_dead == 1.
    
    // Restart Check
    spc := /input_key_just_pressed/KEY_SPACE. // SPACE
    /restart_game/ when player_is_dead == 1 and spc == 1.
    
    // Normal Update
    /do_normal_update/dt when can_update == 1.
<

#do_normal_update(dt) >
    // Update animation timer
    anim_timer = anim_timer - dt.
    anim_timer = 0 when anim_timer lt 0.
    
    // Update buttons and slider (must be before editor to intercept clicks)
    /update_slider/.
    /update_buttons/.
    
    // Update editor (handles all input)
    /editor_update/dt.
    
    // Bot execution with timing
    /update_bot_runner/dt when bot_is_running == 1.
    
    // Check for death (manual or bot)
    died := /check_player_death/.
    /bot_stop/ when died == 1.
<

#update_bot_runner(dt) >
    bot_step_timer = bot_step_timer + dt.
    
    // Cap ticks per frame to prevent freeze on very high speeds
    max_ticks := 100.
    ticks := 0.
    
    loop >
        << 0 when bot_step_timer lt bot_step_delay.
        << 0 when bot_is_running == 0.
        << 0 when ticks ge max_ticks.
        
        bot_step_timer = bot_step_timer - bot_step_delay.
        /bot_run_tick/.
        ticks = ticks + 1.
        
        // Check for death inside loop too?
        // Yes, if bot kills us, stop immediately
        died := /check_player_death/.
        /bot_stop/ when died == 1.
        // Break loop (by setting ticks = max)
        ticks = max_ticks when died == 1.
    <
<

// ============================================================================
// Rendering
// ============================================================================

#game_render() >
    /do_render/ when game_initialized == 1.
<

#do_render() >
    // Calculate player position for torch effect shader
    px := dungeon_x + player_x * TILE_W.
    py := dungeon_y + 12 + player_y * TILE_H.

    // Render swirly background shader with player position for torch effect
    /render_background/px/py.

    /text_clear/.
    /render_dungeon/.
    /draw_entities/.
    /draw_player/.
    /draw_particles/.
    /draw_buttons/.
    /draw_slider/.
    /render_editor/.
    
    // Tombstone on top
    /draw_tombstone/ when player_is_dead == 1.
<
