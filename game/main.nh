// nh - A NetHack-style Dungeon Crawler with Code Editor
// The player writes code to control the @ character

@use "intro.nh".
@use "audio.nh".
@use "bgshader.nh".
@use "editor.nh".
@use "player.nh".
@use "entity.nh".
@use "tech.nh".
@use "dungeon.nh".
@use "render.nh".
@use "particles.nh".
@use "combat.nh".
@use "bot.nh".

// ============================================================================
// Screen Layout - Responsive Two-Pane Layout
// ============================================================================

SCREEN_W := 1280.
SCREEN_H := 720.

ANIM_DURATION := 200.   // Animation duration in ms (base, scaled by speed)

// Split position (0.0 to 1.0, represents fraction of width for left pane)
split_ratio := 50.      // Stored as 0-100 (represents 0.0-1.0)
split_min_ratio := 20.  // Minimum left pane is 20%
split_max_ratio := 80.  // Maximum left pane is 80%

// Divider state
divider_x := 0.
divider_width := 12.
divider_padding := 6.  // Padding on each side of divider
divider_dragging := 0.
divider_hovered := 0.
divider_drag_start_x := 0.      // Mouse X when drag started
divider_drag_start_ratio := 0.  // Split ratio when drag started

// Left pane bounds
left_pane_x := 0.
left_pane_y := 0.
left_pane_w := 0.
left_pane_h := 0.

// Dungeon panel bounds (top of left pane, right-aligned)
dungeon_x := 0.
dungeon_y := 0.
dungeon_w := 0.
dungeon_h := 0.

// Tech tree placeholder bounds (bottom of left pane)
tech_tree_x := 0.
tech_tree_y := 0.
tech_tree_w := 0.
tech_tree_h := 0.
TECH_TREE_HEIGHT := 280.  // Height for tech tree panel

// Right pane / Editor bounds
panel_editor_x := 0.
panel_editor_y := 0.
panel_editor_w := 0.
panel_editor_h := 0.

// ============================================================================
// Game State
// ============================================================================

game_initialized := 0.

// ============================================================================
// Layout Calculation - Two-Pane Layout with Resizable Divider
// ============================================================================

// Button bar height
BUTTON_BAR_HEIGHT := 44.
LAYOUT_PADDING := 16.

#calculate_layout() >
    w := /get_screen_width/.
    h := /get_screen_height/.
    
    SCREEN_W = w.
    SCREEN_H = h.
    
    /setup_two_pane_layout/w/h.
<

#setup_two_pane_layout(w, h) >
    // Calculate split point based on ratio
    split_x := w * split_ratio / 100.
    
    // Clamp to minimum/maximum
    min_x := w * split_min_ratio / 100.
    max_x := w * split_max_ratio / 100.
    split_x = min_x when split_x lt min_x.
    split_x = max_x when split_x gt max_x.
    
    // Divider position (centered on split point)
    divider_x = split_x - divider_width / 2.
    
    // =========== LEFT PANE ===========
    left_pane_x = LAYOUT_PADDING.
    left_pane_y = LAYOUT_PADDING.
    left_pane_w = split_x - LAYOUT_PADDING - divider_width / 2 - divider_padding.
    left_pane_h = h - LAYOUT_PADDING * 2.
    
    // Split left pane into two equal halves vertically
    half_height := (left_pane_h - LAYOUT_PADDING) / 2.
    
    // ===== SHARED CONTENT WIDTH =====
    // Dungeon content width: map tiles + status bar (which extends further)
    // Status bar has attributes starting at +350 and extending to ~+700
    content_pix_w := 700.  // Wide enough for status bar
    
    // Use content width or pane width, whichever is smaller
    shared_pane_w := content_pix_w.
    shared_pane_w = left_pane_w when left_pane_w lt content_pix_w.
    
    // Calculate shared X position (right-aligned within left pane)
    shared_pane_x := left_pane_x + left_pane_w - shared_pane_w.
    shared_pane_x = left_pane_x when shared_pane_x lt left_pane_x.
    
    // ===== TOP HALF: Dungeon (bottom-right aligned within top half) =====
    top_half_y := left_pane_y.
    top_half_h := half_height.
    
    // Dungeon actual pixel dimensions (for vertical alignment)
    dungeon_pix_h := MAP_HEIGHT * TILE_H + 120.  // Include header + status lines
    
    dungeon_w = shared_pane_w.
    dungeon_h = top_half_h.
    dungeon_x = shared_pane_x.
    
    // Bottom-align within top half: push down if content is shorter
    dungeon_y = top_half_y.
    dungeon_y = top_half_y + top_half_h - dungeon_pix_h when dungeon_pix_h lt top_half_h.
    dungeon_y = top_half_y when dungeon_y lt top_half_y.  // Clamp to half
    
    // ===== BOTTOM HALF: Tech tree (centered within shared pane width) =====
    bottom_half_y := left_pane_y + half_height + LAYOUT_PADDING.
    bottom_half_h := half_height.
    
    // Tech tree has a max width, centered within the shared pane
    tech_tree_max_w := 600.
    tech_tree_w = tech_tree_max_w.
    tech_tree_w = shared_pane_w when shared_pane_w lt tech_tree_max_w.
    tech_tree_h = TECH_TREE_HEIGHT.
    
    // Center horizontally within the shared pane area
    tech_tree_x = shared_pane_x + (shared_pane_w - tech_tree_w) / 2.
    tech_tree_x = shared_pane_x when tech_tree_x lt shared_pane_x.
    
    // Vertically center within bottom half
    tech_tree_y = bottom_half_y + (bottom_half_h - tech_tree_h) / 2.
    tech_tree_y = bottom_half_y when tech_tree_y lt bottom_half_y.  // Clamp
    
    // =========== RIGHT PANE (EDITOR) ===========
    right_pane_x := split_x + divider_width / 2 + divider_padding.
    right_pane_y := LAYOUT_PADDING.
    right_pane_w := w - right_pane_x - LAYOUT_PADDING.
    right_pane_h := h - LAYOUT_PADDING * 2.
    
    // Button bar at top of right pane
    /set_button_positions/right_pane_x/right_pane_y.
    
    // Editor fills rest of right pane (below buttons)
    panel_editor_x = right_pane_x.
    panel_editor_y = right_pane_y + BUTTON_BAR_HEIGHT.
    panel_editor_w = right_pane_w.
    panel_editor_h = right_pane_h - BUTTON_BAR_HEIGHT.
    
    /set_editor_bounds/panel_editor_x/panel_editor_y/panel_editor_w/panel_editor_h.
<

// ============================================================================
// Game Init
// ============================================================================

#game_init() >
    /console_log/"nh dungeon with editor initializing...".
    seed := /time_ms/.
    /rng_seed/seed.
    /init_particles/.
    /init_entities/.
    /init_upgrades/.
    /init_background_shader/.
    /calculate_layout/.
    /generate_dungeon/.
    
    /init_editor/.
    /init_intro/.
    game_initialized = 1.
    /console_log/"Ready! Write code and click Play to run the bot.".
<

// ============================================================================
// Game Update
// ============================================================================

#game_update(dt) >
    // Skip if not initialized
    can_run := game_initialized.
    
    // Update intro if active
    /update_intro/dt when can_run == 1 and intro_active == 1.
    can_run = 0 when intro_active == 1.
    
    // Normal game update
    /do_update/dt when can_run == 1.
    /update_particles/ when can_run == 1.
<

#do_update(dt) >
    /calculate_layout/.
    
    // If dead, wait for restart (use buttons on death screen)
    can_update := 1.
    can_update = 0 when player_is_dead == 1.
    
    // Normal Update
    /do_normal_update/dt when can_update == 1.
<

#do_normal_update(dt) >
    // Update animation timer
    anim_timer = anim_timer - dt.
    anim_timer = 0 when anim_timer lt 0.
    
    // Update divider dragging (must be before other mouse handlers)
    /update_divider/.
    
    // Update buttons and slider (must be before editor to intercept clicks)
    /update_slider/.
    /update_buttons/.
    /update_tech_tree/.
    
    // Update editor (handles all input)
    /editor_update/dt.
    
    // Bot execution with timing
    /update_bot_runner/dt when bot_is_running == 1.
    
    // Check for death (manual or bot)
    died := /check_player_death/.
    /bot_stop/ when died == 1.
<

// ============================================================================
// Divider Update - Handle Resizing
// ============================================================================

#update_divider() >
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    down := /input_mouse_down/.
    just_pressed := /input_mouse_just_pressed/.
    
    // Check if mouse is over divider (with some padding for easier grabbing)
    grab_padding := 8.
    in_divider := mx ge divider_x - grab_padding and mx lt divider_x + divider_width + grab_padding.
    in_divider = in_divider * (my ge LAYOUT_PADDING and my lt SCREEN_H - LAYOUT_PADDING).
    
    // Update hover state
    divider_hovered = 0.
    divider_hovered = 1 when in_divider == 1.
    
    // Start dragging - store starting position and ratio
    divider_drag_start_x = mx when just_pressed == 1 and in_divider == 1.
    divider_drag_start_ratio = split_ratio when just_pressed == 1 and in_divider == 1.
    divider_dragging = 1 when just_pressed == 1 and in_divider == 1.
    
    // Stop dragging
    divider_dragging = 0 when down == 0.
    
    // Update split ratio based on mouse movement delta
    /update_split_from_drag/mx when divider_dragging == 1.
<

#update_split_from_drag(mx) >
    // Calculate how far mouse moved from drag start
    delta_x := mx - divider_drag_start_x.
    
    // Convert pixel delta to ratio delta (percentage of screen width)
    delta_ratio := delta_x * 100 / SCREEN_W.
    
    // New ratio = starting ratio + delta
    new_ratio := divider_drag_start_ratio + delta_ratio.
    
    // Clamp to min/max
    new_ratio = split_min_ratio when new_ratio lt split_min_ratio.
    new_ratio = split_max_ratio when new_ratio gt split_max_ratio.
    
    split_ratio = new_ratio.
<

#update_bot_runner(dt) >
    bot_step_timer = bot_step_timer + dt.
    
    // Cap ticks per frame to prevent freeze on very high speeds
    max_ticks := 100.
    ticks := 0.
    
    loop >
        << 0 when bot_step_timer lt bot_step_delay.
        << 0 when bot_is_running == 0.
        << 0 when ticks ge max_ticks.
        
        bot_step_timer = bot_step_timer - bot_step_delay.
        /bot_run_tick/.
        ticks = ticks + 1.
        
        // Check for death inside loop too?
        // Yes, if bot kills us, stop immediately
        died := /check_player_death/.
        /bot_stop/ when died == 1.
        // Break loop (by setting ticks = max)
        ticks = max_ticks when died == 1.
    <
<

// ============================================================================
// Rendering
// ============================================================================

#game_render() >
    // Skip if not initialized
    can_run := game_initialized.
    
    // Render intro if active (no CRT effects)
    /text_clear/ when can_run == 1 and intro_active == 1.
    /render_intro/ when can_run == 1 and intro_active == 1.
    can_run = 0 when intro_active == 1.
    
    // Normal game render
    /do_render/ when can_run == 1.
<

#do_render() >
    // Calculate player position for torch effect shader
    px := dungeon_x + player_x * TILE_W.
    py := dungeon_y + 12 + player_y * TILE_H.

    // Render swirly background shader with player position for torch effect
    /render_background/px/py.

    /text_clear/.
    
    // Draw the divider between panes
    /draw_divider/.
    
    // Draw tech tree placeholder (bottom of left pane)
    /draw_tech_tree/.
    
    /render_dungeon/.
    /draw_entities/.
    /draw_player/.
    /draw_particles/.
    /draw_buttons/.
    /draw_slider/.
    /render_editor/.
    
    // Tombstone on top
    /draw_tombstone/ when player_is_dead == 1.
<

// ============================================================================
// Divider Rendering
// ============================================================================

#draw_divider() >
    dx := divider_x.
    dy := LAYOUT_PADDING.
    dw := divider_width.
    dh := SCREEN_H - LAYOUT_PADDING * 2.
    
    // Base color (darker when not hovered)
    r := 40. g := 45. b := 55.
    
    // Highlight when hovered or dragging
    r = 60 when divider_hovered == 1. g = 70 when divider_hovered == 1. b = 85 when divider_hovered == 1.
    r = 80 when divider_dragging == 1. g = 100 when divider_dragging == 1. b = 130 when divider_dragging == 1.
    
    // Draw divider background
    /draw_rect/dx/dy/dw/dh/r/g/b/255.
    
    // Draw grip icon in center (three horizontal lines)
    icon_x := dx + dw / 2 - 3.
    icon_y := SCREEN_H / 2 - 15.
    grip_r := 100. grip_g := 110. grip_b := 130.
    grip_r = 140 when divider_hovered == 1. grip_g = 160 when divider_hovered == 1. grip_b = 190 when divider_hovered == 1.
    grip_r = 180 when divider_dragging == 1. grip_g = 200 when divider_dragging == 1. grip_b = 230 when divider_dragging == 1.
    
    /draw_rect/icon_x/icon_y/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 6)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 12)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 18)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 24)/6/2/grip_r/grip_g/grip_b/255.
<

// ============================================================================
// Tech Tree UI
// ============================================================================

// Upgrade node dimensions
UPGRADE_NODE_W := 80.
UPGRADE_NODE_H := 50.
UPGRADE_NODE_SPACING_X := 100.
UPGRADE_NODE_SPACING_Y := 65.

// Hovered upgrade
tech_hovered_upgrade := -1.

#draw_tech_tree() >
    tx := tech_tree_x.
    ty := tech_tree_y.
    tw := tech_tree_w.
    th := tech_tree_h.
    
    // Background panel
    /draw_rect/tx/ty/tw/th/20/22/28/240.
    
    // Border
    /draw_rect/tx/ty/tw/2/40/50/65/255.
    /draw_rect/tx/ty/2/th/40/50/65/255.
    /draw_rect/tx/(ty + th - 2)/tw/2/40/50/65/255.
    /draw_rect/(tx + tw - 2)/ty/2/th/40/50/65/255.
    
    // Header
    hx := tx + 12.
    hy := ty + 10.
    /text_draw/hx/hy/12/200/180/100/"[UPGRADES]".
    
    // Bank display
    bank_x := tx + tw - 100.
    /text_draw/bank_x/hy/12/100/200/100/"Bank: $".
    /text_draw_int/(bank_x + 60)/hy/12/100/200/100/player_bank.
    
    // Calculate tree layout starting position
    tree_x := tx + 20.
    tree_y := ty + 35.
    
    // Draw connection lines first (behind nodes)
    /draw_tech_lines/tree_x/tree_y.
    
    // Draw upgrade nodes
    // Row 0: Random Stairs (tier 1 - first unlock)
    /draw_upgrade_node/(tree_x)/(tree_y)/UPGRADE_STAIRS_RANDOM.
    
    // Row 1: Variable Rooms
    /draw_upgrade_node/(tree_x + UPGRADE_NODE_SPACING_X)/(tree_y)/UPGRADE_ROOM_VARIABLE.
    
    // Row 2: Second Room (unlocks branches)
    /draw_upgrade_node/(tree_x + UPGRADE_NODE_SPACING_X * 2)/(tree_y)/UPGRADE_ROOM_2.
    
    // Row 3: Branches split here
    // Room branch (top)
    /draw_upgrade_node/(tree_x + UPGRADE_NODE_SPACING_X * 3)/(tree_y - UPGRADE_NODE_SPACING_Y)/UPGRADE_ROOM_3.
    /draw_upgrade_node/(tree_x + UPGRADE_NODE_SPACING_X * 4)/(tree_y - UPGRADE_NODE_SPACING_Y)/UPGRADE_ROOM_4.
    /draw_upgrade_node/(tree_x + UPGRADE_NODE_SPACING_X * 5)/(tree_y - UPGRADE_NODE_SPACING_Y)/UPGRADE_ROOM_5PLUS.
    
    // Monster branch (middle)
    /draw_upgrade_node/(tree_x + UPGRADE_NODE_SPACING_X * 3)/(tree_y)/UPGRADE_MONSTER_1.
    /draw_upgrade_node/(tree_x + UPGRADE_NODE_SPACING_X * 4)/(tree_y)/UPGRADE_MONSTER_MORE.
    
    // Feature branch (bottom)
    /draw_upgrade_node/(tree_x + UPGRADE_NODE_SPACING_X * 3)/(tree_y + UPGRADE_NODE_SPACING_Y)/UPGRADE_GOLD_SPAWNS.
    
    // Draw tooltip for hovered upgrade
    /draw_upgrade_tooltip/ when tech_hovered_upgrade != -1.
<

#draw_tech_lines(tree_x, tree_y) >
    // Draw connection lines between nodes
    // Line color
    lr := 50. lg := 60. lb := 80.
    
    // Stairs -> Variable
    x1 := tree_x + UPGRADE_NODE_W.
    y1 := tree_y + UPGRADE_NODE_H / 2.
    x2 := tree_x + UPGRADE_NODE_SPACING_X.
    y2 := y1.
    /draw_rect/x1/y1/20/2/lr/lg/lb/255.
    
    // Variable -> Room2
    x1 = tree_x + UPGRADE_NODE_SPACING_X + UPGRADE_NODE_W.
    x2 = tree_x + UPGRADE_NODE_SPACING_X * 2.
    /draw_rect/x1/y1/20/2/lr/lg/lb/255.
    
    // Room2 -> Branches (vertical connector)
    x1 = tree_x + UPGRADE_NODE_SPACING_X * 2 + UPGRADE_NODE_W.
    y1 = tree_y + UPGRADE_NODE_H / 2.
    /draw_rect/x1/y1/10/2/lr/lg/lb/255.
    
    // Vertical line for branches
    vx := tree_x + UPGRADE_NODE_SPACING_X * 2 + UPGRADE_NODE_W + 10.
    vy_top := tree_y - UPGRADE_NODE_SPACING_Y + UPGRADE_NODE_H / 2.
    vy_bot := tree_y + UPGRADE_NODE_SPACING_Y + UPGRADE_NODE_H / 2.
    vh := vy_bot - vy_top.
    /draw_rect/vx/vy_top/2/vh/lr/lg/lb/255.
    
    // Horizontal lines to each branch
    // Top (rooms)
    /draw_rect/vx/(tree_y - UPGRADE_NODE_SPACING_Y + UPGRADE_NODE_H / 2)/8/2/lr/lg/lb/255.
    // Middle (monsters)
    /draw_rect/vx/(tree_y + UPGRADE_NODE_H / 2)/8/2/lr/lg/lb/255.
    // Bottom (features)
    /draw_rect/vx/(tree_y + UPGRADE_NODE_SPACING_Y + UPGRADE_NODE_H / 2)/8/2/lr/lg/lb/255.
    
    // Room chain: Room3 -> Room4 -> Room5+
    x1 = tree_x + UPGRADE_NODE_SPACING_X * 3 + UPGRADE_NODE_W.
    y1 = tree_y - UPGRADE_NODE_SPACING_Y + UPGRADE_NODE_H / 2.
    /draw_rect/x1/y1/20/2/lr/lg/lb/255.
    
    x1 = tree_x + UPGRADE_NODE_SPACING_X * 4 + UPGRADE_NODE_W.
    /draw_rect/x1/y1/20/2/lr/lg/lb/255.
    
    // Monster chain: Monster1 -> MonsterMore
    x1 = tree_x + UPGRADE_NODE_SPACING_X * 3 + UPGRADE_NODE_W.
    y1 = tree_y + UPGRADE_NODE_H / 2.
    /draw_rect/x1/y1/20/2/lr/lg/lb/255.
<

#draw_upgrade_node(x, y, upgrade_id) >
    // Determine node state
    has := /has_upgrade/upgrade_id.
    can := /can_unlock_upgrade/upgrade_id.
    cost := /get_upgrade_cost/upgrade_id.
    can_afford := 0.
    can_afford = 1 when player_bank ge cost.
    
    // Available = can unlock AND can afford
    available := can * can_afford.
    
    // Check hover
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    in_x := mx ge x and mx lt x + UPGRADE_NODE_W.
    in_y := my ge y and my lt y + UPGRADE_NODE_H.
    hovered := in_x * in_y.
    
    // Update global hovered
    tech_hovered_upgrade = upgrade_id when hovered == 1.
    
    // Colors based on state
    bg_r := 35. bg_g := 40. bg_b := 50.    // Locked (dark)
    br_r := 60. br_g := 70. br_b := 85.    // Border
    
    // Available (can buy)
    bg_r = 40 when available == 1. bg_g = 55 when available == 1. bg_b = 45 when available == 1.
    br_r = 80 when available == 1. br_g = 140 when available == 1. br_b = 100 when available == 1.
    
    // Can unlock but can't afford
    just_can := can * (1 - can_afford).
    bg_r = 50 when just_can == 1. bg_g = 45 when just_can == 1. bg_b = 40 when just_can == 1.
    br_r = 120 when just_can == 1. br_g = 100 when just_can == 1. br_b = 60 when just_can == 1.
    
    // Unlocked
    bg_r = 30 when has == 1. bg_g = 50 when has == 1. bg_b = 70 when has == 1.
    br_r = 80 when has == 1. br_g = 130 when has == 1. br_b = 180 when has == 1.
    
    // Hover highlight
    bg_r = bg_r + 15 when hovered == 1.
    bg_g = bg_g + 15 when hovered == 1.
    bg_b = bg_b + 15 when hovered == 1.
    
    // Draw background
    /draw_rect/x/y/UPGRADE_NODE_W/UPGRADE_NODE_H/bg_r/bg_g/bg_b/255.
    
    // Draw border
    /draw_rect/x/y/UPGRADE_NODE_W/2/br_r/br_g/br_b/255.
    /draw_rect/x/y/2/UPGRADE_NODE_H/br_r/br_g/br_b/255.
    /draw_rect/x/(y + UPGRADE_NODE_H - 2)/UPGRADE_NODE_W/2/br_r/br_g/br_b/255.
    /draw_rect/(x + UPGRADE_NODE_W - 2)/y/2/UPGRADE_NODE_H/br_r/br_g/br_b/255.
    
    // Draw name (shortened)
    name := /get_upgrade_name/upgrade_id.
    tx := x + 4.
    ty := y + 6.
    
    text_r := 150. text_g := 150. text_b := 160.
    text_r = 180 when available == 1. text_g = 220 when available == 1. text_b = 180 when available == 1.
    text_r = 140 when has == 1. text_g = 180 when has == 1. text_b = 220 when has == 1.
    
    /text_draw/tx/ty/10/text_r/text_g/text_b/name.
    
    // Draw cost or checkmark
    cost_y := y + 28.
    
    // If unlocked, show checkmark
    /text_draw/(x + 30)/cost_y/14/100/180/100/"OK" when has == 1.
    
    // If locked, show cost
    cost_r := 100. cost_g := 100. cost_b := 110.
    cost_r = 100 when available == 1. cost_g = 200 when available == 1. cost_b = 100 when available == 1.
    cost_r = 200 when just_can == 1. cost_g = 150 when just_can == 1. cost_b = 80 when just_can == 1.
    /text_draw/(x + 20)/cost_y/12/cost_r/cost_g/cost_b/"$" when has == 0.
    /text_draw_int/(x + 32)/cost_y/12/cost_r/cost_g/cost_b/cost when has == 0.
<

#draw_upgrade_tooltip() >
    // Draw tooltip for hovered upgrade
    upgrade_id := tech_hovered_upgrade.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    
    // Tooltip position (offset from mouse)
    tx := mx + 15.
    ty := my - 50.
    tw := 160.
    th := 45.
    
    // Keep on screen
    tx = tech_tree_x + tech_tree_w - tw - 10 when tx + tw gt tech_tree_x + tech_tree_w.
    ty = tech_tree_y + 5 when ty lt tech_tree_y.
    
    // Background
    /draw_rect/tx/ty/tw/th/30/35/45/250.
    /draw_rect/tx/ty/tw/1/80/90/110/255.
    
    // Name
    name := /get_upgrade_name/upgrade_id.
    /text_draw/(tx + 5)/(ty + 5)/11/220/220/180/name.
    
    // Description
    desc := /get_upgrade_desc/upgrade_id.
    /text_draw/(tx + 5)/(ty + 22)/9/160/160/170/desc.
<

#update_tech_tree() >
    // Reset hovered
    tech_hovered_upgrade = -1.
    
    // Check for clicks
    just_clicked := /input_mouse_just_pressed/.
    << 0 when just_clicked == 0.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    
    // Check if in tech tree bounds
    in_bounds := mx ge tech_tree_x and mx lt tech_tree_x + tech_tree_w.
    in_bounds = in_bounds * (my ge tech_tree_y and my lt tech_tree_y + tech_tree_h).
    << 0 when in_bounds == 0.
    
    // Check each upgrade node for click
    tree_x := tech_tree_x + 20.
    tree_y := tech_tree_y + 35.
    
    // Check clicks on each node
    /check_upgrade_click/(tree_x)/(tree_y)/UPGRADE_STAIRS_RANDOM/mx/my.
    /check_upgrade_click/(tree_x + UPGRADE_NODE_SPACING_X)/(tree_y)/UPGRADE_ROOM_VARIABLE/mx/my.
    /check_upgrade_click/(tree_x + UPGRADE_NODE_SPACING_X * 2)/(tree_y)/UPGRADE_ROOM_2/mx/my.
    /check_upgrade_click/(tree_x + UPGRADE_NODE_SPACING_X * 3)/(tree_y - UPGRADE_NODE_SPACING_Y)/UPGRADE_ROOM_3/mx/my.
    /check_upgrade_click/(tree_x + UPGRADE_NODE_SPACING_X * 4)/(tree_y - UPGRADE_NODE_SPACING_Y)/UPGRADE_ROOM_4/mx/my.
    /check_upgrade_click/(tree_x + UPGRADE_NODE_SPACING_X * 5)/(tree_y - UPGRADE_NODE_SPACING_Y)/UPGRADE_ROOM_5PLUS/mx/my.
    /check_upgrade_click/(tree_x + UPGRADE_NODE_SPACING_X * 3)/(tree_y)/UPGRADE_MONSTER_1/mx/my.
    /check_upgrade_click/(tree_x + UPGRADE_NODE_SPACING_X * 4)/(tree_y)/UPGRADE_MONSTER_MORE/mx/my.
    /check_upgrade_click/(tree_x + UPGRADE_NODE_SPACING_X * 3)/(tree_y + UPGRADE_NODE_SPACING_Y)/UPGRADE_GOLD_SPAWNS/mx/my.
<

#check_upgrade_click(x, y, upgrade_id, mx, my) >
    in_x := mx ge x and mx lt x + UPGRADE_NODE_W.
    in_y := my ge y and my lt y + UPGRADE_NODE_H.
    clicked := in_x * in_y.
    
    << 0 when clicked == 0.
    
    // Try to purchase
    result := /try_purchase_upgrade/upgrade_id.
    
    // Regenerate dungeon if purchased (to apply new params)
    /generate_dungeon/ when result == 1.
<
