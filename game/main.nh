// nh - A NetHack-style Dungeon Crawler with Code Editor
// The player writes code to control the @ character

@use "bgshader.nh".
@use "editor.nh".

// ============================================================================
// Screen Layout - Responsive
// ============================================================================

SCREEN_W := 1280.
SCREEN_H := 720.

// Layout mode: 0 = side by side, 1 = stacked (editor below)
layout_mode := 0.

// Panel bounds
dungeon_x := 0.
dungeon_y := 0.
dungeon_w := 0.
dungeon_h := 0.

panel_editor_x := 0.
panel_editor_y := 0.
panel_editor_w := 0.
panel_editor_h := 0.

// ============================================================================
// Display Constants
// ============================================================================

TILE_W := 10.
TILE_H := 16.
MAP_WIDTH := 50.
MAP_HEIGHT := 20.

// Tile characters
CHAR_FLOOR := 46.       // '.'
CHAR_WALL_H := 45.      // '-'
CHAR_WALL_V := 124.     // '|'
CHAR_PLAYER := 64.      // '@'
CHAR_DOOR := 43.        // '+'
CHAR_CORRIDOR := 35.    // '#'
CHAR_STAIRS_DOWN := 62. // '>'
CHAR_GOLD := 36.        // '$'

// Tile types
TILE_EMPTY := 0.
TILE_FLOOR := 1.
TILE_WALL_H := 2.
TILE_WALL_V := 3.
TILE_CORRIDOR := 4.
TILE_DOOR := 5.
TILE_STAIRS := 6.
TILE_GOLD := 7.

// ============================================================================
// Colors
// ============================================================================

COL_GRAY_R := 170.
COL_GRAY_G := 170.
COL_GRAY_B := 170.

COL_WHITE_R := 255.
COL_WHITE_G := 255.
COL_WHITE_B := 255.

COL_GOLD_R := 255.
COL_GOLD_G := 255.
COL_GOLD_B := 0.

COL_BROWN_R := 180.
COL_BROWN_G := 100.
COL_BROWN_B := 40.

COL_CYAN_R := 0.
COL_CYAN_G := 255.
COL_CYAN_B := 255.

COL_GREEN_R := 100.
COL_GREEN_G := 255.
COL_GREEN_B := 100.

// ============================================================================
// Dungeon Map
// ============================================================================

dungeon := [].

// ============================================================================
// Player State
// ============================================================================

player_x := 5.
player_y := 4.
player_hp := 16.
player_max_hp := 16.
player_gold := 0.
dungeon_level := 1.
turns := 0.

// Bot state
bot_running := 0.
bot_timer := 0.
bot_step_delay := 300.  // ms between bot moves

// Message
last_message := "Write code to control @. Press F5 to run.".

// ============================================================================
// Game State
// ============================================================================

game_initialized := 0.

// ============================================================================
// Dungeon Access
// ============================================================================

#get_tile(x, y) >
    << TILE_EMPTY when x lt 0.
    << TILE_EMPTY when y lt 0.
    << TILE_EMPTY when x ge MAP_WIDTH.
    << TILE_EMPTY when y ge MAP_HEIGHT.
    idx := y * MAP_WIDTH + x.
    << dungeon[idx].
<

#set_tile(x, y, val) >
    << 0 when x lt 0.
    << 0 when y lt 0.
    << 0 when x ge MAP_WIDTH.
    << 0 when y ge MAP_HEIGHT.
    idx := y * MAP_WIDTH + x.
    dungeon[idx] = val.
<

// ============================================================================
// Room Generation
// ============================================================================

#make_room_in_sector(sx, sy, sw, sh, force) >
    // 20% chance to skip (unless forced)
    skip := /rng_int/100.
    not_forced := 0.
    not_forced = 1 when force == 0.
    
    rng_skip := 0.
    rng_skip = 1 when skip lt 20.
    
    do_skip := not_forced * rng_skip.
    << 0 when do_skip == 1.
    
    // Padding
    pad := 2.
    
    // Available space
    avail_w := sw - pad * 2.
    avail_h := sh - pad * 2.
    
    // Random size (min 6x4, max available)
    rw := /rng_int/(avail_w - 6) + 6.
    rh := /rng_int/(avail_h - 4) + 4.
    
    // Random position
    rx := sx + pad + /rng_int/(avail_w - rw).
    ry := sy + pad + /rng_int/(avail_h - rh).
    
    /make_room/rx/ry/rw/rh.
    
    // Return center packed: y * 1000 + x (assuming x < 1000)
    cx := rx + rw / 2.
    cy := ry + rh / 2.
    << cy * 1000 + cx.
<



// Arrays for MST
parents := [].
centers := [].

#find_set(i) >
    // Simple path compression or just recursion
    // Since recursion limit is tight, use loop?
    // Max depth 6. Recursion is fine.
    
    // Iterative find
    curr := i.
    p := parents[curr].
    
    loop when p != curr >
        curr = p.
        p = parents[curr].
    <
    << curr.
<

#union_sets(i, j) >
    root_i := /find_set/i.
    root_j := /find_set/j.
    
    // Union by setting parent
    parents[root_i] = root_j when root_i != root_j.
<

#generate_dungeon() >
    size := MAP_WIDTH * MAP_HEIGHT.
    for i in 0..size >
        dungeon[i] = TILE_EMPTY.
    <
    
    // Initialize MST arrays
    for i in 0..6 >
        parents[i] = i.
        centers[i] = 0.
    <
    
    // Generate Rows
    // Row 0
    centers[0] = /make_room_in_sector/0/0/25/10/1.
    centers[1] = /make_room_in_sector/25/0/25/10/0.
    centers[2] = /make_room_in_sector/50/0/26/10/0.
    // Row 1
    centers[3] = /make_room_in_sector/0/10/25/11/0.
    centers[4] = /make_room_in_sector/25/10/25/11/0.
    centers[5] = /make_room_in_sector/50/10/26/11/0.
    
    // Define Edges (u, v)
    // 7 edges max
    edges := [].
    // Horizontal
    edges[0] = 0. edges[1] = 1.
    edges[2] = 1. edges[3] = 2.
    edges[4] = 3. edges[5] = 4.
    edges[6] = 4. edges[7] = 5.
    // Vertical
    edges[8] = 0. edges[9] = 3.
    edges[10] = 1. edges[11] = 4.
    edges[12] = 2. edges[13] = 5.
    
    edge_count := 7.
    
    // Shuffle Edges
    // Swap 10 times
    for k in 0..10 >
        i1 := /rng_int/edge_count.
        i2 := /rng_int/edge_count.
        
        // Swap pairs
        idx1 := i1 * 2.
        idx2 := i2 * 2.
        
        u1 := edges[idx1].
        v1 := edges[idx1 + 1].
        
        u2 := edges[idx2].
        v2 := edges[idx2 + 1].
        
        edges[idx1] = u2.
        edges[idx1 + 1] = v2.
        edges[idx2] = u1.
        edges[idx2 + 1] = v1.
    <
    
    // Build MST
    // Iterate all edges
    for k in 0..edge_count >
        idx := k * 2.
        u := edges[idx].
        v := edges[idx + 1].
        
        c_u := centers[u].
        c_v := centers[v].
        
        // Check validity
        is_valid := 0.
        is_valid = 1 when c_u != 0.
        is_valid = 0 when c_v == 0.
        
        // Calculate conditions
        root_u := /find_set/u.
        root_v := /find_set/v.
        
        // Tree edge?
        is_diff := 0.
        is_diff = 1 when root_u != root_v.
        
        // Loop edge?
        chance := /rng_int/100.
        is_loop := 0.
        is_loop = 1 when root_u == root_v.
        lucky := 0.
        lucky = 1 when chance lt 40.
        add_loop := is_loop * lucky.
        
        // Decision
        do_it := 0.
        do_it = 1 when is_diff == 1.
        do_it = 1 when add_loop == 1.
        
        // Ensure valid rooms (from above)
        final_do := do_it * is_valid.
        
        /union_sets/u/v when final_do == 1.
        /connect_points/c_u/c_v when final_do == 1.
    <
    
    // Extract player start from c0
    c0 := centers[0].
    y0 := c0 / 1000.
    x0 := c0 - y0 * 1000.
    player_x = x0.
    player_y = y0.
    
    // Place Stairs in random VALID and CONNECTED room
    sp := 0.
    tries := 0.
    // Try 50 times
    loop when tries lt 50 >
        stairs_room := /rng_int/6.
        cand := centers[stairs_room].
        
        // Check connectivity to room 0
        root_s := /find_set/stairs_room.
        root_0 := /find_set/0.
        
        is_connected := 0.
        is_connected = 1 when root_s == root_0.
        
        // Also must exist (cand != 0), implicit if connected to 0 (since 0 exists) 
        // but explicit check helps if 0 is somehow isolated? (0 is always root_0)
        
        // Accept if connected
        sp = cand when is_connected == 1.
        
        // Break if found (sp != 0)
        break_loop := 0.
        break_loop = 1 when sp != 0.
        
        // Force break by setting tries to 100
        tries = 100 when break_loop == 1.
        
        tries = tries + 1.
    <
    
    // Fallback to c0 if failed
    sp = c0 when sp == 0.
    
    sy := sp / 1000.
    sx := sp - sy * 1000.
    /set_tile/sx/sy/TILE_STAIRS.
    
    /make_branches/.

    // Scatter Gold
    // Try 10 times to place gold in valid floor spots
    for k in 0..10 >
        gx := /rng_int/MAP_WIDTH.
        gy := /rng_int/MAP_HEIGHT.
        tile := /get_tile/gx/gy.
        /set_tile/gx/gy/TILE_GOLD when tile == TILE_FLOOR.
    <
<

#make_branches() >
    // Attempt to make random spurs/branches with wandering paths
    // Increase count for messiness
    pass_max := 40.
    
    for k in 0..pass_max >
        // Random start point
        sx := /rng_int/MAP_WIDTH.
        sy := /rng_int/MAP_HEIGHT.
        
        tile := /get_tile/sx/sy.
        
        // Start from walkable (Room or Corridor)
        walk := /can_walk/tile.
        
        // Initialize digging based on walk
        digging := walk.
        
        // Initial direction
        dir := /rng_int/4.
        dx := /get_delta_x/dir.
        dy := /get_delta_y/dir.
        
        // Dig length - slightly longer for wandering
        len := /rng_int/8 + 4. // 4 to 11
        
        cx := sx.
        cy := sy.
        
        for s in 0..len >
            // Chance to change direction (Wandering)
            // e.g. 30% chance each step
            roll := /rng_int/100.
            change := 0.
            change = 1 when roll lt 30.
            
            // Apply change only if digging
            do_change := change * digging.
            
            // We can't use 'if' easily inside 'when' logic without blocks
            // But we can re-roll and assignment if do_change is 1
            
            new_dir := /rng_int/4.
            ndx := /get_delta_x/new_dir.
            ndy := /get_delta_y/new_dir.
            
            // Update dx/dy if changing
            dx = ndx when do_change == 1.
            dy = ndy when do_change == 1.
            
            // Only move if still digging
            cx = cx + dx when digging == 1.
            cy = cy + dy when digging == 1.
            
            // Check bounds
            ok := 1.
            ok = 0 when cx lt 1.
            ok = 0 when cy lt 1.
            ok = 0 when cx ge 75. // MAP_WIDTH - 1
            ok = 0 when cy ge 20. // MAP_HEIGHT - 1
            
            digging = 0 when ok == 0.
            
            check_dig := digging.
            
            ct := /get_tile/cx/cy.
            
            // Only dig into EMPTY
            is_empty := 0.
            is_empty = 1 when ct == TILE_EMPTY.
            
            do_dig := check_dig * is_empty.
            /set_tile/cx/cy/TILE_CORRIDOR when do_dig == 1.
            
            // Stop if hit non-empty (collision with other room/corridor)
            // This prevents overwriting walls or floors
            hit_something := 1.
            hit_something = 0 when ct == TILE_EMPTY.
            should_stop := check_dig * hit_something.
            digging = 0 when should_stop == 1.
        <
    <
<

#get_delta_x(dir) >
    ret := 0.
    ret = 1 when dir == 0.      // Right
    ret = 0 - 1 when dir == 1.  // Left
    // Up/Down are x=0
    << ret.
<

#get_delta_y(dir) >
    ret := 0.
    ret = 1 when dir == 2.      // Down
    ret = 0 - 1 when dir == 3.  // Up
    // Right/Left are y=0
    << ret.
<

#connect_points(start, end) >
    y1 := start / 1000.
    x1 := start - y1 * 1000.
    y2 := end / 1000.
    x2 := end - y2 * 1000.
    
    // Messy "drunkard's walk" from P1 to P2
    cx := x1.
    cy := y1.
    
    // Loop limit to prevent hang
    max_steps := 200.
    steps := 0.
    prev_group := 0. // Start as Inside (Room center)
    
    loop when steps lt max_steps >
        // Check arrival
        arrived := 0.
        arrived_x := 0. arrived_y := 0.
        arrived_x = 1 when cx == x2.
        arrived_y = 1 when cy == y2.
        arrived = arrived_x * arrived_y.
        
        break_loop := 0.
        break_loop = 1 when arrived == 1.
        steps = max_steps when break_loop == 1.
        
        // Continue if not done
        running := 0.
        running = 1 when steps lt max_steps.
        
        // --- DIG LOGIC ---
        
        ct := /get_tile/cx/cy.
        
        // Is Wall?
        is_wall := 0.
        is_wall = 1 when ct == TILE_WALL_H.
        is_wall = 1 when ct == TILE_WALL_V.
        
        // Dig Door
        do_door := running * is_wall.
        /set_tile/cx/cy/TILE_DOOR when do_door == 1.
        
        // Dig Corridor if empty
        is_empty := 0.
        is_empty = 1 when ct == TILE_EMPTY.
        do_corridor := running * is_empty.
        // Prevent overwriting door we just made (is_wall was 1, so is_empty was 0. Safe.)
        /set_tile/cx/cy/TILE_CORRIDOR when do_corridor == 1.
        
        
        // --- MOVE LOGIC ---
        
        // Goal deltas
        gdx := x2 - cx.
        gdy := y2 - cy.
        
        // Primary Axes (5 = invalid)
        p1 := 5. 
        p2 := 5.
        
        // X Bias
        p1 = 0 when gdx gt 0.
        p1 = 1 when gdx lt 0.
        
        // Y Bias
        y_dir := 5.
        y_dir = 2 when gdy gt 0.
        y_dir = 3 when gdy lt 0.
        
        // Assign Y to p2 (or p1 if p1 invalid)
        p1_invalid := 0.
        p1_invalid = 1 when p1 == 5.
        
        p1 = y_dir when p1_invalid == 1.
        // Else assign to p2
        // If p1 valid (p1_invalid=0) AND y_dir valid
        y_valid := 0.
        y_valid = 1 when y_dir != 5.
        
        assign_p2 := y_valid * (1 - p1_invalid).
        p2 = y_dir when assign_p2 == 1.
        
        // Selection
        roll := /rng_int/100.
        messy_threshold := 40.
        
        is_random := 0.
        is_random = 1 when roll lt messy_threshold.
        
        chosen_dir := 0.
        
        // Case: Random
        rand_dir := /rng_int/4.
        chosen_dir = rand_dir when is_random == 1.
        
        // Case: Targeted (is_random == 0)
        // Check if p2 is valid (5 is invalid)
        p2_valid := 0.
        p2_valid = 1 when p2 != 5.
        
        // If 2 primaries
        coin := /rng_int/2.
        pick_p1 := 0. pick_p2 := 0.
        pick_p1 = 1 when coin == 0.
        pick_p2 = 1 when coin == 1.
        
        // If p2 invalid, force p1
        pick_p1 = 1 when p2_valid == 0.
        pick_p2 = 0 when p2_valid == 0. // clear p2 pick
        
        // If p1 is ALSO invalid (already at target? but loop break handles that)
        // Just pick 0 default.
        
        target_dir := 0.
        target_dir = p1 when pick_p1 == 1.
        target_dir = p2 when pick_p2 == 1.
        
        // Apply target choice if not random
        chosen_dir = target_dir when is_random == 0.
        
        // --- VALIDATE MOVE (Anti-Slide & Anti-Bounce) ---
        // Groups: 0=Inside, 1=Outside, 2=Boundary
        
        is_door_cur := 0.
        is_door_cur = 1 when ct == TILE_DOOR.
        
        // Current Group (refined)
        // We know 'ct' is current tile.
        curr_g := 1. // Default Outside
        
        is_in := 0.
        is_in = 1 when ct == TILE_FLOOR.
        is_in = 1 when ct == TILE_GOLD.
        is_in = 1 when ct == TILE_STAIRS.
        curr_g = 0 when is_in == 1.
        
        is_bd := 0.
        is_bd = 1 when is_wall == 1. // is_wall set above
        is_bd = 1 when is_door_cur == 1.
        curr_g = 2 when is_bd == 1.
        
        // Retry Loop
        attempts := 0.
        loop when attempts lt 100 >
            dx := /get_delta_x/chosen_dir.
            dy := /get_delta_y/chosen_dir.
            nx := cx + dx.
            ny := cy + dy.
            
            nt := /get_tile/nx/ny.
            
            // Next Group
            ng := 1.
            n_in := 0.
            n_in = 1 when nt == TILE_FLOOR.
            n_in = 1 when nt == TILE_GOLD.
            n_in = 1 when nt == TILE_STAIRS.
            ng = 0 when n_in == 1.
            
            n_bd := 0.
            n_bd = 1 when nt == TILE_WALL_H.
            n_bd = 1 when nt == TILE_WALL_V.
            n_bd = 1 when nt == TILE_DOOR.
            ng = 2 when n_bd == 1.
            
            // Rules:
            // 1. Never move to Boundary if currently Boundary (Anti-Slide)
            //    Exception: If we are STUCK? No, 100 tries should find exit.
            fail_slide := 0.
            fail_slide = 1 when curr_g == 2.
            // Only fail if next is ALSO 2
            fail_slide = fail_slide * n_bd. 
            // n_bd is equivalent to ng==2 check
            
            // 2. Anti-Bounce: If currently Boundary, Next must differ from Prev
            //    If prev was 0 (Inside), Next must be 1 (Outside).
            //    If prev was 1 (Outside), Next must be 0 (Inside).
            //    (If prev was 2? Impossible due to rule 1, but assume valid)
            fail_bounce := 0.
            
            // Flattened Anti-Bounce Logic
            check_bounce := 0.
            check_bounce = 1 when curr_g == 2.
            
            // Check vs prev_group (pg)
            // If pg==0, forbid ng==0
            bounce_in := 0.
            bounce_in = 1 when prev_group == 0.
            is_ng_0 := 0.
            is_ng_0 = 1 when ng == 0.
            bad_in := bounce_in * is_ng_0.
            
            // If pg==1, forbid ng==1
            bounce_out := 0.
            bounce_out = 1 when prev_group == 1.
            is_ng_1 := 0.
            is_ng_1 = 1 when ng == 1.
            bad_out := bounce_out * is_ng_1.
            
            total_bad := bad_in + bad_out.
            fail_bounce = total_bad * check_bounce.
            
            is_bad := 0.
            is_bad = 1 when fail_slide gt 0.
            is_bad = 1 when fail_bounce gt 0.
            
            // Allow override if strictly invalid? No, keep trying.
            
            // If bad, retry
            break_loop_chk := 0.
            break_loop_chk = 1 when is_bad == 0.
            
            // Exit loop if good
            attempts = 1000 when break_loop_chk == 1.
            
            // Else retry
             // Retry logic flattened
            do_retry := 0.
            do_retry = 1 when attempts lt 100.
            
            new_rand := /rng_int/4.
            chosen_dir = new_rand when do_retry == 1.
            attempts = attempts + 1 when do_retry == 1.
        <
        
        // Update prev_group for NEXT step
        prev_group = curr_g.
        
        // --- EXECUTE MOVE ---
        
        dx := /get_delta_x/chosen_dir.
        dy := /get_delta_y/chosen_dir.
        
        // Update pos if running
        cx = cx + dx when running == 1.
        cy = cy + dy when running == 1.
        
        // Clamp
        cx = 1 when cx lt 1.
        cy = 1 when cy lt 1.
        cx = 75 when cx gt 75.
        cy = 20 when cy gt 20.
        
        steps = steps + 1.
    <
<

#make_room(rx, ry, rw, rh) >
    for dy in 1..(rh - 1) >
        for dx in 1..(rw - 1) >
            /set_tile/(rx + dx)/(ry + dy)/TILE_FLOOR.
        <
    <
    
    for dx in 0..rw >
        /set_tile/(rx + dx)/ry/TILE_WALL_H.
        /set_tile/(rx + dx)/(ry + rh - 1)/TILE_WALL_H.
    <
    
    for dy in 1..(rh - 1) >
        /set_tile/rx/(ry + dy)/TILE_WALL_V.
        /set_tile/(rx + rw - 1)/(ry + dy)/TILE_WALL_V.
    <
<

// ============================================================================
// Movement
// ============================================================================

#can_walk(tile) >
    << 1 when tile == TILE_FLOOR.
    << 1 when tile == TILE_CORRIDOR.
    << 1 when tile == TILE_DOOR.
    << 1 when tile == TILE_STAIRS.
    << 1 when tile == TILE_GOLD.
    << 0.
<

#try_move(dx, dy) >
    new_x := player_x + dx.
    new_y := player_y + dy.
    
    tile := /get_tile/new_x/new_y.
    walkable := /can_walk/tile.
    
    << 0 when walkable == 0.
    
    // Collect gold
    last_message = "You pick up gold!" when tile == TILE_GOLD.
    player_gold = player_gold + /rng_int/20 + 5 when tile == TILE_GOLD.
    /set_tile/new_x/new_y/TILE_FLOOR when tile == TILE_GOLD.
    
    // Stairs
    last_message = "You found the stairs! Level complete!" when tile == TILE_STAIRS.
    
    player_x = new_x.
    player_y = new_y.
    turns = turns + 1.
    
    << 1.
<

// ============================================================================
// Layout Calculation - Truly Responsive
// ============================================================================

#calculate_layout() >
    w := /get_screen_width/.
    h := /get_screen_height/.
    
    SCREEN_W = w.
    SCREEN_H = h.
    
    // Stacked layout if height > width (portrait mode)
    layout_mode = 1 when h gt w.
    layout_mode = 0 when w ge h.
    
    /setup_side_layout/w/h when layout_mode == 0.
    /setup_stacked_layout/w/h when layout_mode == 1.
<

#setup_side_layout(w, h) >
    // Calculate dungeon size
    dw := MAP_WIDTH * TILE_W + 40.
    dh := MAP_HEIGHT * TILE_H + 100.
    
    // Dungeon on left
    dungeon_x = 20.
    dungeon_y = 20.
    dungeon_w = dw.
    dungeon_h = h - 40.
    
    // Editor fills remaining space on right
    panel_editor_x = dw + 40.
    panel_editor_y = 20.
    panel_editor_w = w - dw - 60.
    panel_editor_h = h - 40.
    
    /set_editor_bounds/panel_editor_x/panel_editor_y/panel_editor_w/panel_editor_h.
<

#setup_stacked_layout(w, h) >
    half_h := h / 2.
    
    // Dungeon on top
    dungeon_x = 20.
    dungeon_y = 10.
    dungeon_w = w - 40.
    dungeon_h = half_h - 20.
    
    // Editor on bottom
    panel_editor_x = 20.
    panel_editor_y = half_h + 10.
    panel_editor_w = w - 40.
    panel_editor_h = half_h - 20.
    
    /set_editor_bounds/panel_editor_x/panel_editor_y/panel_editor_w/panel_editor_h.
<

// ============================================================================
// Bot Execution (Simple Demo)
// ============================================================================

#bot_step() >
    // For now, just move right as a demo
    // In a full implementation, we'd parse and execute the editor code
    dir := /rng_int/4.
    
    neg1 := 0 - 1.
    /try_move/neg1/0 when dir == 0.  // left
    /try_move/1/0 when dir == 1.     // right
    /try_move/0/neg1 when dir == 2.  // up
    /try_move/0/1 when dir == 3.     // down
<

// ============================================================================
// Game Init
// ============================================================================

#game_init() >
    /console_log/"nh dungeon with editor initializing...".
    seed := /time_ms/.
    /rng_seed/seed.
    /init_background_shader/.
    /calculate_layout/.
    /generate_dungeon/.
    /init_editor/.
    game_initialized = 1.
    /console_log/"Ready! Write code and press F5 to run the bot.".
<

// ============================================================================
// Game Update
// ============================================================================

#game_update(dt) >
    /do_update/dt when game_initialized == 1.
<

#change_level(delta) >
    new_depth := dungeon_level + delta.
    dungeon_level = new_depth.
    
    // Regenerate
    /generate_dungeon/.
    
    last_message = "You descend deeper...".
    << 1.
<

#do_update(dt) >
    /calculate_layout/.
    
    // Update editor (handles all input)
    /editor_update/dt.
    
    // Bot execution
    /update_bot/dt when bot_running == 1.
    
    // Bot toggle removed - will add button later
<

#toggle_bot() >
    bot_running = 0 when bot_running == 1.
    bot_running = 1 when bot_running == 0.
    last_message = "Bot started! Watch @ move." when bot_running == 1.
    last_message = "Bot stopped." when bot_running == 0.
    bot_timer = 0.
<

#update_bot(dt) >
    bot_timer = bot_timer + dt.
    
    << 0 when bot_timer lt bot_step_delay.
    
    bot_timer = 0.
    /bot_step/.
<

// ============================================================================
// Rendering
// ============================================================================

#game_render() >
    /do_render/ when game_initialized == 1.
<

#do_render() >
    /render_background/.
    /text_clear/.
    /render_dungeon/.
    /render_editor/.
<

#render_dungeon() >
    map_offset_x := dungeon_x.
    map_offset_y := dungeon_y + 12.
    
    // Draw tiles
    for y in 0..MAP_HEIGHT >
        for x in 0..MAP_WIDTH >
            /draw_tile/x/y/map_offset_x/map_offset_y.
        <
    <
    
    // Draw player
    px := map_offset_x + player_x * TILE_W.
    py := map_offset_y + player_y * TILE_H.
    /text_char/px/py/TILE_H/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/CHAR_PLAYER.
    
    // Status
    /draw_status/map_offset_x/map_offset_y.
    
    // Message
    msg_y := map_offset_y + MAP_HEIGHT * TILE_H + 60.
    /text_draw/map_offset_x/msg_y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/last_message.
    
    // Header
    /text_draw/map_offset_x/dungeon_y/12/COL_CYAN_R/COL_CYAN_G/COL_CYAN_B/"[DUNGEON]".
    
    // Bot status
    bot_x := map_offset_x + 100.
    /text_draw/bot_x/dungeon_y/12/COL_GREEN_R/COL_GREEN_G/COL_GREEN_B/"BOT: RUNNING" when bot_running == 1.
    /text_draw/bot_x/dungeon_y/12/COL_GRAY_R/COL_GRAY_G/COL_GRAY_B/"BOT: STOPPED" when bot_running == 0.
<

#draw_tile(x, y, offset_x, offset_y) >
    tile := /get_tile/x/y.
    << 0 when tile == TILE_EMPTY.
    
    sx := offset_x + x * TILE_W.
    sy := offset_y + y * TILE_H.
    
    /text_char/sx/sy/TILE_H/COL_GRAY_R/COL_GRAY_G/COL_GRAY_B/CHAR_FLOOR when tile == TILE_FLOOR.
    /text_char/sx/sy/TILE_H/COL_BROWN_R/COL_BROWN_G/COL_BROWN_B/CHAR_WALL_H when tile == TILE_WALL_H.
    /text_char/sx/sy/TILE_H/COL_BROWN_R/COL_BROWN_G/COL_BROWN_B/CHAR_WALL_V when tile == TILE_WALL_V.
    /text_char/sx/sy/TILE_H/COL_GRAY_R/COL_GRAY_G/COL_GRAY_B/CHAR_CORRIDOR when tile == TILE_CORRIDOR.
    /text_char/sx/sy/TILE_H/COL_BROWN_R/COL_BROWN_G/COL_BROWN_B/CHAR_DOOR when tile == TILE_DOOR.
    /text_char/sx/sy/TILE_H/COL_CYAN_R/COL_CYAN_G/COL_CYAN_B/CHAR_STAIRS_DOWN when tile == TILE_STAIRS.
    /text_char/sx/sy/TILE_H/COL_GOLD_R/COL_GOLD_G/COL_GOLD_B/CHAR_GOLD when tile == TILE_GOLD.
<

#draw_status(offset_x, offset_y) >
    y := offset_y + MAP_HEIGHT * TILE_H + 10.
    
    /text_draw/offset_x/y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"Player the Adventurer".
    
    y2 := y + 20.
    /text_draw/offset_x/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"Dlvl:".
    /text_draw_int/(offset_x + 50)/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/dungeon_level.
    
    /text_draw/(offset_x + 80)/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"$:".
    /text_draw_int/(offset_x + 100)/y2/14/COL_GOLD_R/COL_GOLD_G/COL_GOLD_B/player_gold.
    
    /text_draw/(offset_x + 150)/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"HP:".
    /text_draw_int/(offset_x + 180)/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/player_hp.
    
    /text_draw/(offset_x + 220)/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"T:".
    /text_draw_int/(offset_x + 240)/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/turns.
<
