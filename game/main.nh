// nh - A NetHack-style Dungeon Crawler with Code Editor
// The player writes code to control the @ character

@use "intro.nh".
@use "menu.nh".
@use "audio.nh".
@use "bgshader.nh".
@use "editor.nh".
@use "player.nh".
@use "entity.nh".
@use "tech.nh".
@use "dungeon.nh".
@use "render.nh".
@use "particles.nh".
@use "floating_text.nh".
@use "combat.nh".
@use "bot.nh".
@use "docs_content.nh".
@use "docs.nh".
@use "tutorial.nh".
@use "messages.nh".

// ============================================================================
// Screen Layout - Responsive Two-Pane Layout
// ============================================================================

SCREEN_W := 1280.
SCREEN_H := 720.

ANIM_DURATION := 200.   // Animation duration in ms (base, scaled by speed)

// Split position (0.0 to 1.0, represents fraction of width for left pane)
split_ratio := 50.      // Stored as 0-100 (represents 0.0-1.0)
split_min_ratio := 20.  // Minimum left pane is 20%
split_max_ratio := 80.  // Maximum left pane is 80%

// Divider state
divider_x := 0.
divider_width := 12.
divider_padding := 6.  // Padding on each side of divider
divider_dragging := 0.
divider_hovered := 0.
divider_drag_start_x := 0.      // Mouse X when drag started
divider_drag_start_ratio := 0.  // Split ratio when drag started

// Left pane bounds
left_pane_x := 0.
left_pane_y := 0.
left_pane_w := 0.
left_pane_h := 0.

// Dungeon panel bounds (top of left pane, right-aligned)
dungeon_x := 0.
dungeon_y := 0.
dungeon_w := 0.
dungeon_h := 0.

// Tech tree bounds (bottom of left pane)
tech_tree_x := 0.
tech_tree_y := 0.
tech_tree_w := 0.
tech_tree_h := 0.

// Right pane / Editor bounds
panel_editor_x := 0.
panel_editor_y := 0.
panel_editor_w := 0.
panel_editor_h := 0.

// ============================================================================
// Game State
// ============================================================================

game_initialized := 0.

// ============================================================================
// Layout Calculation - Two-Pane Layout with Resizable Divider
// ============================================================================

// Button bar height
BUTTON_BAR_HEIGHT := 44.
LAYOUT_PADDING := 16.

#calculate_layout() >
    w := /get_screen_width/.
    h := /get_screen_height/.
    
    SCREEN_W = w.
    SCREEN_H = h.
    
    /setup_two_pane_layout/w/h.
<

#setup_two_pane_layout(w, h) >
    // Calculate split point based on ratio
    split_x := w * split_ratio / 100.
    
    // Clamp to minimum/maximum
    min_x := w * split_min_ratio / 100.
    max_x := w * split_max_ratio / 100.
    split_x = min_x when split_x lt min_x.
    split_x = max_x when split_x gt max_x.
    
    // Divider position (centered on split point)
    divider_x = split_x - divider_width / 2.
    
    // =========== LEFT PANE ===========
    left_pane_x = LAYOUT_PADDING.
    left_pane_y = LAYOUT_PADDING.
    left_pane_w = split_x - LAYOUT_PADDING - divider_width / 2 - divider_padding.
    left_pane_h = h - LAYOUT_PADDING * 2.
    
    // Split left pane into two equal halves vertically
    half_height := (left_pane_h - LAYOUT_PADDING) / 2.
    
    // ===== SHARED CONTENT WIDTH =====
    // Dungeon content width: map tiles + status bar (which extends further)
    // Status bar has attributes starting at +350 and extending to ~+700
    content_pix_w := 700.  // Wide enough for status bar
    
    // Use content width or pane width, whichever is smaller
    shared_pane_w := content_pix_w.
    shared_pane_w = left_pane_w when left_pane_w lt content_pix_w.
    
    // Calculate shared X position (right-aligned within left pane)
    shared_pane_x := left_pane_x + left_pane_w - shared_pane_w.
    shared_pane_x = left_pane_x when shared_pane_x lt left_pane_x.
    
    // ===== TOP HALF: Dungeon (bottom-right aligned within top half) =====
    top_half_y := left_pane_y.
    top_half_h := half_height.
    
    // Dungeon actual pixel dimensions (for vertical alignment)
    dungeon_pix_h := MAP_HEIGHT * TILE_H + 120.  // Include header + status lines
    
    dungeon_w = shared_pane_w.
    dungeon_h = top_half_h.
    dungeon_x = shared_pane_x.
    
    // Bottom-align within top half: push down if content is shorter
    dungeon_y = top_half_y.
    dungeon_y = top_half_y + top_half_h - dungeon_pix_h when dungeon_pix_h lt top_half_h.
    dungeon_y = top_half_y when dungeon_y lt top_half_y.  // Clamp to half
    
    // ===== BOTTOM HALF: Tech tree (uses full left pane width and height) =====
    bottom_half_y := left_pane_y + half_height + LAYOUT_PADDING.
    bottom_half_h := half_height.
    
    // Tech tree fills the entire bottom half
    tech_tree_w = left_pane_w.
    tech_tree_h = bottom_half_h.
    tech_tree_x = left_pane_x.
    tech_tree_y = bottom_half_y.
    
    // =========== RIGHT PANE (EDITOR) ===========
    right_pane_x := split_x + divider_width / 2 + divider_padding.
    right_pane_y := LAYOUT_PADDING.
    right_pane_w := w - right_pane_x - LAYOUT_PADDING.
    right_pane_h := h - LAYOUT_PADDING * 2.
    
    // Button bar at top of right pane
    /set_button_positions/right_pane_x/right_pane_y.
    
    // Editor fills rest of right pane (below buttons)
    panel_editor_x = right_pane_x.
    panel_editor_y = right_pane_y + BUTTON_BAR_HEIGHT.
    panel_editor_w = right_pane_w.
    panel_editor_h = right_pane_h - BUTTON_BAR_HEIGHT.
    
    /set_editor_bounds/panel_editor_x/panel_editor_y/panel_editor_w/panel_editor_h.
<

// ============================================================================
// Game Init
// ============================================================================

#game_init() >
    /console_log/"nh dungeon with editor initializing...".
    seed := /time_ms/.
    /rng_seed/seed.
    /init_particles/.
    /init_floating_text/.
    /init_entities/.
    /init_upgrades/.
    /init_contacts/.  // Initialize chat contacts
    /init_background_shader/.
    /calculate_layout/.
    /init_editor/.
    /init_intro/.
    /init_menu/.
    
    // Generate dungeon AFTER init_menu - menu generation uses the dungeon array
    // and we need to overwrite it with the actual game dungeon
    /generate_dungeon/.
    
    // Set initial bonus display to what player would earn for completing floor
    dngn_bonus = /calculate_floor_bonus/.
    
    game_initialized = 1.
    /console_log/"Ready! Write code and click Play to run the bot.".
<

// ============================================================================
// Game Update
// ============================================================================

#game_update(dt) >
    // Skip if not initialized
    can_run := game_initialized.
    
    // Update menu if active
    /update_menu/dt when can_run == 1 and menu_active == 1.
    can_run = 0 when menu_active == 1.
    
    // Update intro if active
    /update_intro/dt when can_run == 1 and intro_active == 1.
    can_run = 0 when intro_active == 1.
    
    // Normal game update
    /do_update/dt when can_run == 1.
    /update_particles/ when can_run == 1.
    /update_floating_text/ when can_run == 1.
<

#do_update(dt) >
    /calculate_layout/.
    
    // Handle pause popup if active (blocks other input)
    /update_pause_popup/dt.
    << 0 when pause_popup_active == 1.
    
    // Handle docs overlay if active (blocks other input)
    /update_docs/.
    <<0 when docs_active == 1.
    
    // Handle tutorial if active (blocks other input)
    /update_ui_tutorial/.
    <<0 when ui_tut_active == 1.
    
    // Handle chat if active (blocks other input)
    chat_consumed := /update_inbox/.
    // Block if chat still active (clicked inside/no click) OR if consumed (clicked close button)
    <<0 when chat_active == 1.
    <<0 when chat_consumed == 1.
    
    // Update chat bubble (only when chat closed)
    /update_chat_bubble/.
    <<0 when chat_bubble_clicked == 1.  // Block click-through to tech tree
    
    // If dead, wait for restart (use buttons on death screen)
    can_update := 1.
    can_update = 0 when player_is_dead == 1.
    
    // Normal Update
    /do_normal_update/dt when can_update == 1.
<

#do_normal_update(dt) >
    // Update animation timer
    anim_timer = anim_timer - dt.
    anim_timer = 0 when anim_timer lt 0.
    
    // Update stair transition animation
    /update_stair_transition/dt.
    
    // Update divider dragging (must be before other mouse handlers)
    /update_divider/.
    
    // Update buttons and slider (must be before editor to intercept clicks)
    /update_slider/.
    /update_buttons/.
    /update_docs_button/.
    /update_info_button/.
    /update_info_popup/.
    /update_settings_button/.
    /update_tech_tree/.
    
    // Update editor (handles all input)
    /editor_update/dt.
    
    // Bot execution with timing (skip during stair transition)
    /update_bot_runner/dt when bot_is_running == 1 and stair_transition_active == 0.
    
    // Check for death (manual or bot)
    died := /check_player_death/.
    /bot_stop/ when died == 1.
<

#update_stair_transition(dt) >
    // Skip if not in transition
    << 0 when stair_transition_active == 0.
    
    // Update timer
    stair_transition_timer = stair_transition_timer - dt.
    
    // Check if transition complete
    << 0 when stair_transition_timer gt 0.
    
    // Transition complete - generate new dungeon
    /bot_complete_stair_transition/.
<

// ============================================================================
// Divider Update - Handle Resizing
// ============================================================================

#update_divider() >
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    down := /input_mouse_down/.
    just_pressed := /input_mouse_just_pressed/.
    
    // Check if mouse is over divider (with some padding for easier grabbing)
    grab_padding := 8.
    in_divider := mx ge divider_x - grab_padding and mx lt divider_x + divider_width + grab_padding.
    in_divider = in_divider * (my ge LAYOUT_PADDING and my lt SCREEN_H - LAYOUT_PADDING).
    
    // Update hover state
    divider_hovered = 0.
    divider_hovered = 1 when in_divider == 1.
    
    // Start dragging - store starting position and ratio
    divider_drag_start_x = mx when just_pressed == 1 and in_divider == 1.
    divider_drag_start_ratio = split_ratio when just_pressed == 1 and in_divider == 1.
    divider_dragging = 1 when just_pressed == 1 and in_divider == 1.
    
    // Stop dragging
    divider_dragging = 0 when down == 0.
    
    // Update split ratio based on mouse movement delta
    /update_split_from_drag/mx when divider_dragging == 1.
<

#update_split_from_drag(mx) >
    // Calculate how far mouse moved from drag start
    delta_x := mx - divider_drag_start_x.
    
    // Convert pixel delta to ratio delta (percentage of screen width)
    delta_ratio := delta_x * 100 / SCREEN_W.
    
    // New ratio = starting ratio + delta
    new_ratio := divider_drag_start_ratio + delta_ratio.
    
    // Clamp to min/max
    new_ratio = split_min_ratio when new_ratio lt split_min_ratio.
    new_ratio = split_max_ratio when new_ratio gt split_max_ratio.
    
    split_ratio = new_ratio.
<

#update_bot_runner(dt) >
    bot_step_timer = bot_step_timer + dt.
    
    // Cap ticks per frame to prevent freeze on very high speeds
    max_ticks := 100.
    ticks := 0.
    
    loop >
        << 0 when bot_step_timer lt bot_step_delay.
        << 0 when bot_is_running == 0.
        << 0 when ticks ge max_ticks.
        
        bot_step_timer = bot_step_timer - bot_step_delay.
        /bot_run_tick/.
        ticks = ticks + 1.
        
        // Check for death inside loop too?
        // Yes, if bot kills us, stop immediately
        died := /check_player_death/.
        /bot_stop/ when died == 1.
        // Break loop (by setting ticks = max)
        ticks = max_ticks when died == 1.
    <
<

// ============================================================================
// Rendering
// ============================================================================

#game_render() >
    // Skip if not initialized
    can_run := game_initialized.
    
    // Render menu if active
    /text_clear/ when can_run == 1 and menu_active == 1.
    /render_menu/ when can_run == 1 and menu_active == 1.
    can_run = 0 when menu_active == 1.
    
    // Intro rendering logic
    // If INTRO_STATE_CRT_OPEN (6), we want to render the game BEHIND the intro
    is_crt_open := 0.
    is_crt_open = 1 when intro_active == 1 and intro_state == 6.
    
    // Determine if we should render the game
    should_render_game := can_run.
    // If intro active, normally don't render game, UNLESS it's CRT open
    should_render_game = 0 when intro_active == 1 and is_crt_open == 0.
    
    // Render Game
    /do_render/ when should_render_game == 1.

    // Render Intro
    // Clear screen if intro active and NOT CRT open (standalone intro)
    /text_clear/ when can_run == 1 and intro_active == 1 and is_crt_open == 0.
    /render_intro/ when can_run == 1 and intro_active == 1.
    
    can_run = 0 when intro_active == 1.
<

#do_render() >
    // Calculate player position for torch effect shader
    px := dungeon_x + player_x * TILE_W.
    py := dungeon_y + 12 + player_y * TILE_H.

    // Render swirly background shader with player position for torch effect
    /render_background/px/py.

    /text_clear/.
    
    // Draw the divider between panes
    /draw_divider/.
    
    // Draw tech tree placeholder (bottom of left pane)
    /draw_tech_tree/.
    
    /render_dungeon/.
    /draw_entities/.
    /draw_player/.
    /draw_particles/.
    /draw_floating_text/.
    /draw_buttons/.
    /draw_slider/.
    /draw_docs_button/.
    /draw_info_button/.
    /draw_settings_button/.
    /render_editor/.
    
    // Tombstone on top
    /draw_tombstone/ when player_is_dead == 1.
    
    // Pause popup on top of everything
    /render_pause_popup/.
    
    // Docs overlay on very top
    /draw_docs_overlay/.
    
    // Tutorial overlay on top of everything
    /draw_ui_tut_overlay/.
    
    // Chat bubble (bottom right)
    /draw_chat_bubble/.
    
    // Inbox overlay on very top
    /draw_inbox_overlay/.
    
    // Info popup on very top
    /draw_info_popup/.
<

// ============================================================================
// Divider Rendering
// ============================================================================

#draw_divider() >
    dx := divider_x.
    dy := LAYOUT_PADDING.
    dw := divider_width.
    dh := SCREEN_H - LAYOUT_PADDING * 2.
    
    // Base color (darker when not hovered)
    r := 40. g := 45. b := 55.
    
    // Highlight when hovered or dragging
    r = 60 when divider_hovered == 1. g = 70 when divider_hovered == 1. b = 85 when divider_hovered == 1.
    r = 80 when divider_dragging == 1. g = 100 when divider_dragging == 1. b = 130 when divider_dragging == 1.
    
    // Draw divider background
    /draw_rect/dx/dy/dw/dh/r/g/b/255.
    
    // Draw grip icon in center (three horizontal lines)
    icon_x := dx + dw / 2 - 3.
    icon_y := SCREEN_H / 2 - 15.
    grip_r := 100. grip_g := 110. grip_b := 130.
    grip_r = 140 when divider_hovered == 1. grip_g = 160 when divider_hovered == 1. grip_b = 190 when divider_hovered == 1.
    grip_r = 180 when divider_dragging == 1. grip_g = 200 when divider_dragging == 1. grip_b = 230 when divider_dragging == 1.
    
    /draw_rect/icon_x/icon_y/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 6)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 12)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 18)/6/2/grip_r/grip_g/grip_b/255.
    /draw_rect/icon_x/(icon_y + 24)/6/2/grip_r/grip_g/grip_b/255.
<

// ============================================================================
// Tech Tree UI - Clean Implementation with Clipping
// ============================================================================

// Layout constants - increased sizes for better readability
TREE_PADDING := 24.
TREE_HEADER_H := 36.
NODE_PAD_X := 10.
NODE_PAD_Y := 8.
NODE_W := 110.     // Wide enough for all text with padding
NODE_H := 42.
NODE_GAP_X := 10.
NODE_GAP_Y := 14.
BRANCH_GAP := 35.

// Scroll state
// Default scroll_y of -120 shows both upper trees and language tree root
tech_scroll_x := 0.
tech_scroll_y := -120.
tech_dragging := 0.
tech_drag_start_x := 0.
tech_drag_start_y := 0.
tech_drag_scroll_x := 0.
tech_drag_scroll_y := 0.

// Interaction state
tech_hovered := -1.
tech_clicked := -1.

// Clipping bounds (set during draw)
clip_x := 0.
clip_y := 0.
clip_w := 0.
clip_h := 0.

#draw_tech_tree() >
    tx := tech_tree_x.
    ty := tech_tree_y.
    tw := tech_tree_w.
    th := tech_tree_h.
    
    // Reset hover state
    tech_hovered = -1.
    
    // ===== BACKGROUND & BORDER =====
    /draw_rect/tx/ty/tw/th/12/14/18/255.
    /draw_panel_border/tx/ty/tw/th.
    
    // ===== HEADER =====
    /draw_rect/tx/ty/tw/TREE_HEADER_H/20/22/28/255.
    /draw_rect/tx/(ty + TREE_HEADER_H - 1)/tw/1/35/40/50/255.
    
    /text_draw/(tx + TREE_PADDING)/(ty + 12)/14/180/160/100/"UPGRADES".
    
    // Bank (right side)
    /text_draw/(tx + tw - 100)/(ty + 12)/14/80/180/80/"Bank: $".
    /text_draw_int/(tx + tw - 40)/(ty + 12)/14/100/220/100/player_bank.
    
    // Center button
    /draw_center_btn/(tx + tw / 2 - 30)/(ty + 8).
    
    // ===== CONTENT AREA (clipped) =====
    clip_x = tx + 2.
    clip_y = ty + TREE_HEADER_H.
    clip_w = tw - 4.
    clip_h = th - TREE_HEADER_H - 2.
    
    /set_clip_rect/clip_x/clip_y/clip_w/clip_h.
    
    // Base position for tree (scrollable)
    bx := clip_x + TREE_PADDING + tech_scroll_x.
    by := clip_y + clip_h - TREE_PADDING + tech_scroll_y.
    
    // Calculate branch widths
    branch_w := NODE_W * 3 + NODE_GAP_X * 2.
    
    // ===== DRAW BRANCHES =====
    // Buff (left) and Difficulty (right) grow UPWARD from bottom
    // Language (centered below them) grows DOWNWARD
    
    // BUFF branch (left, grows up)
    /draw_buff_tree/bx/by.
    
    // DIFFICULTY branch (right of Buff, grows up)
    diff_x := bx + branch_w + BRANCH_GAP.
    /draw_diff_tree/diff_x/by.
    
    // LANGUAGE branch (centered below Buff/Diff, grows DOWN)
    // Position horizontally centered between the two upper trees
    lang_x := bx + branch_w / 2 + BRANCH_GAP / 2.
    // Start below the bottom of the view (player scrolls down to see it)
    lang_y := by + TREE_PADDING * 2.
    /draw_lang_tree/lang_x/lang_y.
    
    /clear_clip_rect/.
    
    // ===== TOOLTIP (drawn on top, outside clip) =====
    /draw_node_tooltip/ when tech_hovered != -1.
    
    // ===== TUTORIAL POPUP =====
    /draw_tutorial_popup/ when tutorial_active == 1.
<

// ============================================================================
// Panel Border Helper
// ============================================================================

#draw_panel_border(x, y, w, h) >
    /draw_rect/x/y/w/2/35/40/50/255.
    /draw_rect/x/(y + h - 2)/w/2/25/28/35/255.
    /draw_rect/x/y/2/h/35/40/50/255.
    /draw_rect/(x + w - 2)/y/2/h/25/28/35/255.
<

// ============================================================================
// Center Button
// ============================================================================

#draw_center_btn(x, y) >
    bw := 60.
    bh := 20.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    hovered := mx ge x and mx lt x + bw and my ge y and my lt y + bh.
    
    bg := 25.
    bg = 40 when hovered == 1.
    /draw_rect/x/y/bw/bh/bg/(bg + 5)/(bg + 10)/255.
    
    br := 50.
    br = 80 when hovered == 1.
    /draw_rect/x/y/bw/1/br/(br + 10)/(br + 20)/255.
    /draw_rect/x/(y + bh - 1)/bw/1/(br - 10)/br/(br + 5)/255.
    
    tc := 120.
    tc = 180 when hovered == 1.
    /text_draw/(x + 8)/(y + 4)/14/tc/tc/(tc + 20)/"Center".
    
    // Handle click - reset to default scroll position (-120 shows language root)
    // Skip click handling if tutorial is active (popup may overlap)
    just_clicked := /input_mouse_just_pressed/.
    >
        tech_scroll_x = 0.
        tech_scroll_y = -120.
    < when just_clicked == 1 and hovered == 1 and tutorial_active == 0.
<

// ============================================================================
// Tree Drawing - Simplified Data-Driven Approach
// ============================================================================

// Each tree is drawn as a grid of nodes with explicit connections
// Using draw_line for proper bezier-like connections

#draw_buff_tree(bx, by) >
    // Speed upgrades first, then branches!
    // Col 0: Stats path (HP, STR, AC)
    // Col 1: Gold path
    // Col 2: Speed path (separate, ends at row 3)
    nw := NODE_W.
    nh := NODE_H.
    gx := NODE_GAP_X.
    gy := NODE_GAP_Y + 8.
    
    // Calculate row positions (10 rows)
    row0 := by - nh.
    row1 := row0 - nh - gy.
    row2 := row1 - nh - gy.
    row3 := row2 - nh - gy.
    row4 := row3 - nh - gy.
    row5 := row4 - nh - gy.
    row6 := row5 - nh - gy.
    row7 := row6 - nh - gy.
    row8 := row7 - nh - gy.
    row9 := row8 - nh - gy.
    
    // Column positions
    col0 := bx.
    col1 := bx + nw + gx.
    col2 := bx + (nw + gx) * 2.
    // Center between col0 and col1 for merge points
    colm := bx + (nw + gx) / 2.
    
    lr := 45. lg := 55. lb := 70.
    
    // Row 0 -> Row 1: Speed 5x to Speed 10x (center)
    /draw_tree_conn/(colm + nw / 2)/(row0 - 2)/(colm + nw / 2)/(row1 + nh + 2)/lr/lg/lb.
    
    // Row 1 -> Row 2: Speed 10x branches to HP I, Gold Spawn, Speed 100x
    /draw_tree_conn/(colm + nw / 2)/(row1 - 2)/(col0 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row1 - 2)/(col1 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row1 - 2)/(col2 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    
    // Row 2 -> Row 3: HP I to STR I, Gold Spawn to Gold Spawn+, Speed 100x to Speed 1000x
    /draw_tree_conn/(col0 + nw / 2)/(row2 - 2)/(col0 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row2 - 2)/(col1 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row2 - 2)/(col2 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    
    // Row 3 -> Row 4: STR I to AC I (stats path only continues)
    /draw_tree_conn/(col0 + nw / 2)/(row3 - 2)/(col0 + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    
    // Row 4 -> Row 5: AC I to HP II
    /draw_tree_conn/(col0 + nw / 2)/(row4 - 2)/(col0 + nw / 2)/(row5 + nh + 2)/lr/lg/lb.
    
    // Row 5 -> Row 6: HP II branches to STR II and Gold Drops
    /draw_tree_conn/(col0 + nw / 2)/(row5 - 2)/(col0 + nw / 2)/(row6 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col0 + nw / 2)/(row5 - 2)/(col1 + nw / 2)/(row6 + nh + 2)/lr/lg/lb.
    
    // Row 6 -> Row 7: STR II to AC II, Gold Drops to Gold Drops+
    /draw_tree_conn/(col0 + nw / 2)/(row6 - 2)/(col0 + nw / 2)/(row7 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row6 - 2)/(col1 + nw / 2)/(row7 + nh + 2)/lr/lg/lb.
    
    // Row 7 -> Row 8: AC II and Gold Drops+ merge to HP III
    /draw_tree_conn/(col0 + nw / 2)/(row7 - 2)/(colm + nw / 2)/(row8 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row7 - 2)/(colm + nw / 2)/(row8 + nh + 2)/lr/lg/lb.
    
    // Row 8 -> Row 9: HP III to STR III
    /draw_tree_conn/(colm + nw / 2)/(row8 - 2)/(colm + nw / 2)/(row9 + nh + 2)/lr/lg/lb.
    
    // Draw nodes
    // Row 0: Speed 5x (center)
    /draw_node/colm/row0/UPGRADE_BUFF_SPEED_5.
    
    // Row 1: Speed 10x (center)
    /draw_node/colm/row1/UPGRADE_BUFF_SPEED_10.
    
    // Row 2: HP I (left), Gold Spawn (center), Speed 100x (right)
    /draw_node/col0/row2/UPGRADE_BUFF_HP_1.
    /draw_node/col1/row2/UPGRADE_BUFF_GOLD_SPAWN.
    /draw_node/col2/row2/UPGRADE_BUFF_SPEED_100.
    
    // Row 3: STR I (left), Gold Spawn+ (center), Speed 1000x (right)
    /draw_node/col0/row3/UPGRADE_BUFF_STR_1.
    /draw_node/col1/row3/UPGRADE_BUFF_GOLD_SPAWN_2.
    /draw_node/col2/row3/UPGRADE_BUFF_SPEED_1000.
    
    // Row 4: AC I (left)
    /draw_node/col0/row4/UPGRADE_BUFF_AC_1.
    
    // Row 5: HP II (left)
    /draw_node/col0/row5/UPGRADE_BUFF_HP_2.
    
    // Row 6: STR II (left), Gold Drops (center)
    /draw_node/col0/row6/UPGRADE_BUFF_STR_2.
    /draw_node/col1/row6/UPGRADE_BUFF_GOLD_DROP.
    
    // Row 7: AC II (left), Gold Drops+ (center)
    /draw_node/col0/row7/UPGRADE_BUFF_AC_2.
    /draw_node/col1/row7/UPGRADE_BUFF_GOLD_DROP_2.
    
    // Row 8: HP III (center between col0 and col1)
    /draw_node/colm/row8/UPGRADE_BUFF_HP_3.
    
    // Row 9: STR III (center)
    /draw_node/colm/row9/UPGRADE_BUFF_STR_3.
<

#draw_diff_tree(bx, by) >
    // Difficulty tree with choices between rooms and monsters
    nw := NODE_W.
    nh := NODE_H.
    gx := NODE_GAP_X.
    gy := NODE_GAP_Y + 8.
    
    row0 := by - nh.
    row1 := row0 - nh - gy.
    row2 := row1 - nh - gy.
    row3 := row2 - nh - gy.
    row4 := row3 - nh - gy.
    row5 := row4 - nh - gy.
    row6 := row5 - nh - gy.
    
    col0 := bx.
    col1 := bx + nw + gx.
    colm := bx + (nw + gx) / 2.
    
    lr := 45. lg := 55. lb := 70.
    
    // Row 0 -> Row 1: Rnd Stairs to Var Size (straight)
    /draw_tree_conn/(colm + nw / 2)/(row0 - 2)/(colm + nw / 2)/(row1 + nh + 2)/lr/lg/lb.
    
    // Row 1 -> Row 2: Var Size splits to 2 Rooms and Kobolds
    /draw_tree_conn/(colm + nw / 2)/(row1 - 2)/(col0 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row1 - 2)/(col1 + nw / 2)/(row2 + nh + 2)/lr/lg/lb.
    
    // Row 2 -> Row 3: Parallel chains
    /draw_tree_conn/(col0 + nw / 2)/(row2 - 2)/(col0 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row2 - 2)/(col1 + nw / 2)/(row3 + nh + 2)/lr/lg/lb.
    
    // Row 3 -> Row 4: Merge to 2 Monsters
    /draw_tree_conn/(col0 + nw / 2)/(row3 - 2)/(colm + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row3 - 2)/(colm + nw / 2)/(row4 + nh + 2)/lr/lg/lb.
    
    // Row 4 -> Row 5: Split to 4 Rooms and 3 Monsters
    /draw_tree_conn/(colm + nw / 2)/(row4 - 2)/(col0 + nw / 2)/(row5 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row4 - 2)/(col1 + nw / 2)/(row5 + nh + 2)/lr/lg/lb.
    
    // Row 5 -> Row 6: Merge to Many Rooms
    /draw_tree_conn/(col0 + nw / 2)/(row5 - 2)/(colm + nw / 2)/(row6 + nh + 2)/lr/lg/lb.
    /draw_tree_conn/(col1 + nw / 2)/(row5 - 2)/(colm + nw / 2)/(row6 + nh + 2)/lr/lg/lb.
    
    // Draw nodes
    /draw_node/colm/row0/UPGRADE_DIFF_STAIRS_RANDOM.
    /draw_node/colm/row1/UPGRADE_DIFF_VAR_SIZE.
    /draw_node/col0/row2/UPGRADE_DIFF_ROOM_2.
    /draw_node/col1/row2/UPGRADE_DIFF_KOBOLDS.
    /draw_node/col0/row3/UPGRADE_DIFF_ROOM_3.
    /draw_node/col1/row3/UPGRADE_DIFF_GOBLINS.
    /draw_node/colm/row4/UPGRADE_DIFF_MONSTER_2.
    /draw_node/col0/row5/UPGRADE_DIFF_ROOM_4.
    /draw_node/col1/row5/UPGRADE_DIFF_MONSTER_3.
    /draw_node/colm/row6/UPGRADE_DIFF_ROOM_MANY.
<

#draw_lang_tree(bx, by) >
    // Language tree grows DOWNWARD from top - 3 columns, 7 rows
    nw := NODE_W.
    nh := NODE_H.
    gx := NODE_GAP_X.
    gy := NODE_GAP_Y + 8.
    
    // Rows go DOWN (increasing y)
    row0 := by.
    row1 := row0 + nh + gy.
    row2 := row1 + nh + gy.
    row3 := row2 + nh + gy.
    row4 := row3 + nh + gy.
    row5 := row4 + nh + gy.
    row6 := row5 + nh + gy.
    
    // 3 columns
    col0 := bx.
    col1 := bx + nw + gx.
    col2 := bx + (nw + gx) * 2.
    colm := bx + nw + gx. // Middle column (same as col1)
    
    lr := 45. lg := 55. lb := 70.
    
    // Row 0: FOR (start) -> Row 1: When, Comparison (split)
    /draw_tree_conn/(colm + nw / 2)/(row0 + nh + 2)/(col0 + nw / 2)/(row1 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row0 + nh + 2)/(col2 + nw / 2)/(row1 - 2)/lr/lg/lb.
    
    // Row 1 -> Row 2: When -> CanMove, Variables; Comparison -> Arithmetic
    /draw_tree_conn/(col0 + nw / 2)/(row1 + nh + 2)/(col0 + nw / 2)/(row2 - 2)/lr/lg/lb.
    /draw_tree_conn/(col0 + nw / 2)/(row1 + nh + 2)/(colm + nw / 2)/(row2 - 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row1 + nh + 2)/(col2 + nw / 2)/(row2 - 2)/lr/lg/lb.
    
    // Row 2 -> Row 3: Variables, Arithmetic -> Functions (merge)
    /draw_tree_conn/(colm + nw / 2)/(row2 + nh + 2)/(colm + nw / 2)/(row3 - 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row2 + nh + 2)/(colm + nw / 2)/(row3 - 2)/lr/lg/lb.
    
    // Row 3 -> Row 4: Functions -> Break, Return (split)
    /draw_tree_conn/(colm + nw / 2)/(row3 + nh + 2)/(col0 + nw / 2)/(row4 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row3 + nh + 2)/(col2 + nw / 2)/(row4 - 2)/lr/lg/lb.
    
    // Row 4 -> Row 5: Break, Return -> Loop (merge)
    /draw_tree_conn/(col0 + nw / 2)/(row4 + nh + 2)/(colm + nw / 2)/(row5 - 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row4 + nh + 2)/(colm + nw / 2)/(row5 - 2)/lr/lg/lb.
    
    // Row 5 -> Row 6: Loop -> Arrays, Structs, Strings (fan out)
    /draw_tree_conn/(colm + nw / 2)/(row5 + nh + 2)/(col0 + nw / 2)/(row6 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row5 + nh + 2)/(colm + nw / 2)/(row6 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row5 + nh + 2)/(col2 + nw / 2)/(row6 - 2)/lr/lg/lb.
    
    // Draw nodes (rows 0-6)
    /draw_node/colm/row0/UPGRADE_LANG_FOR.             // Row 0: FOR (start)
    /draw_node/col0/row1/UPGRADE_LANG_WHEN.            // Row 1: Left
    /draw_node/col2/row1/UPGRADE_LANG_COMPARISON.      // Row 1: Right
    /draw_node/col0/row2/UPGRADE_LANG_CANMOVE.         // Row 2: Left (from When)
    /draw_node/colm/row2/UPGRADE_LANG_VARIABLES.       // Row 2: Center
    /draw_node/col2/row2/UPGRADE_LANG_ARITHMETIC.      // Row 2: Right
    /draw_node/colm/row3/UPGRADE_LANG_FUNCTIONS.       // Row 3: Center (merge)
    /draw_node/col0/row4/UPGRADE_LANG_BREAK.           // Row 4: Left
    /draw_node/col2/row4/UPGRADE_LANG_RETURN.          // Row 4: Right
    /draw_node/colm/row5/UPGRADE_LANG_LOOP.            // Row 5: Center (merge)
    /draw_node/col0/row6/UPGRADE_LANG_ARRAYS.          // Row 6: Left
    /draw_node/colm/row6/UPGRADE_LANG_STRUCTS.         // Row 6: Center
    /draw_node/col2/row6/UPGRADE_LANG_STRINGS.         // Row 6: Right
    
    // Continue lower tiers
    row7 := row6 + nh + gy.
    row8 := row7 + nh + gy.
    
    // Row 6 -> Row 7: Advanced (If-else, Pipes, Block-when) - fan in from Data
    /draw_tree_conn/(col0 + nw / 2)/(row6 + nh + 2)/(col0 + nw / 2)/(row7 - 2)/lr/lg/lb.
    /draw_tree_conn/(col0 + nw / 2)/(row6 + nh + 2)/(colm + nw / 2)/(row7 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row6 + nh + 2)/(col0 + nw / 2)/(row7 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row6 + nh + 2)/(colm + nw / 2)/(row7 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row6 + nh + 2)/(col2 + nw / 2)/(row7 - 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row6 + nh + 2)/(colm + nw / 2)/(row7 - 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row6 + nh + 2)/(col2 + nw / 2)/(row7 - 2)/lr/lg/lb.
    
    // Row 7 -> Row 8: Expert (Pattern, Lambda) - 2 nodes
    /draw_tree_conn/(col0 + nw / 2)/(row7 + nh + 2)/(col0 + nw / 2)/(row8 - 2)/lr/lg/lb.
    /draw_tree_conn/(col0 + nw / 2)/(row7 + nh + 2)/(col2 + nw / 2)/(row8 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row7 + nh + 2)/(col0 + nw / 2)/(row8 - 2)/lr/lg/lb.
    /draw_tree_conn/(colm + nw / 2)/(row7 + nh + 2)/(col2 + nw / 2)/(row8 - 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row7 + nh + 2)/(col0 + nw / 2)/(row8 - 2)/lr/lg/lb.
    /draw_tree_conn/(col2 + nw / 2)/(row7 + nh + 2)/(col2 + nw / 2)/(row8 - 2)/lr/lg/lb.
    
    // Draw Tier 5 & 6 nodes
    /draw_node/col0/row7/UPGRADE_LANG_IFELSE.          // Tier 5: Left
    /draw_node/colm/row7/UPGRADE_LANG_PIPES.           // Tier 5: Center
    /draw_node/col2/row7/UPGRADE_LANG_BLOCKWHEN.       // Tier 5: Right
    /draw_node/col0/row8/UPGRADE_LANG_PATTERN.         // Tier 6: Left
    /draw_node/col2/row8/UPGRADE_LANG_LAMBDA.          // Tier 6: Right
    
    // Vision APIs: Branch from Can Move (row2/col0) to the LEFT side
    // Vision tree runs parallel to the left of main tree
    colL1 := bx - (nw + gx).       // First column to the left of col0
    colL2 := colL1 - (nw + gx).    // Second column to the left
    
    // Can Move -> Surroundings/Scan (horizontal left then down to row3-5)
    vision_row0 := row2.  // Same level as Can Move
    vision_row1 := row3.  // Surroundings/Scan level
    vision_row2 := row4.  // Pathfind/Room level  
    vision_row3 := row5.  // Find/FullMap level
    
    // Connection from Can Move (col0) to left (horizontal line)
    /draw_tree_conn/(col0 - 2)/(row2 + nh / 2)/(colL1 + nw / 2)/(row2 + nh / 2)/lr/lg/lb.
    
    // Junction at colL1/row2 that branches down to Surroundings
    /draw_tree_conn/(colL1 + nw / 2)/(row2 + nh / 2)/(colL1 + nw / 2)/(vision_row1 - 2)/lr/lg/lb.
    
    // Surroundings (colL1/vision_row1) -> Pathfind -> Find
    /draw_tree_conn/(colL1 + nw / 2)/(vision_row1 + nh + 2)/(colL1 + nw / 2)/(vision_row2 - 2)/lr/lg/lb.
    /draw_tree_conn/(colL1 + nw / 2)/(vision_row2 + nh + 2)/(colL1 + nw / 2)/(vision_row3 - 2)/lr/lg/lb.
    
    // Draw Vision API nodes (stacked vertically in colL1)
    /draw_node/colL1/vision_row1/UPGRADE_LANG_SURROUNDINGS.  // Surroundings
    /draw_node/colL1/vision_row2/UPGRADE_LANG_PATHFIND.      // Pathfind
    /draw_node/colL1/vision_row3/UPGRADE_LANG_FIND.          // Find
    
    // Scan branch - use colL2 (further left)
    // Junction from Can Move also goes to Scan
    /draw_tree_conn/(colL1 + nw / 2)/(row2 + nh / 2)/(colL2 + nw / 2)/(row2 + nh / 2)/lr/lg/lb.
    /draw_tree_conn/(colL2 + nw / 2)/(row2 + nh / 2)/(colL2 + nw / 2)/(vision_row1 - 2)/lr/lg/lb.
    
    // Scan (colL2/vision_row1) -> Room -> FullMap
    /draw_tree_conn/(colL2 + nw / 2)/(vision_row1 + nh + 2)/(colL2 + nw / 2)/(vision_row2 - 2)/lr/lg/lb.
    /draw_tree_conn/(colL2 + nw / 2)/(vision_row2 + nh + 2)/(colL2 + nw / 2)/(vision_row3 - 2)/lr/lg/lb.
    
    /draw_node/colL2/vision_row1/UPGRADE_LANG_SCAN.          // Scan
    /draw_node/colL2/vision_row2/UPGRADE_LANG_ROOM.          // Room
    /draw_node/colL2/vision_row3/UPGRADE_LANG_FULLMAP.       // FullMap
<

// Draw connection line between nodes (top of lower node to bottom of upper node)
#draw_tree_conn(x1, y1, x2, y2, r, g, b) >
    // Check if line is at all visible in clip region
    min_x := x1.
    min_x = x2 when x2 lt x1.
    max_x := x1.
    max_x = x2 when x2 gt x1.
    min_y := y1.
    min_y = y2 when y2 lt y1.
    max_y := y1.
    max_y = y2 when y2 gt y1.
    
    // Skip if completely outside clip
    << 0 when max_x lt clip_x.
    << 0 when min_x gt clip_x + clip_w.
    << 0 when max_y lt clip_y.
    << 0 when min_y gt clip_y + clip_h.
    
    // Use runtime draw_line for proper anti-aliased line
    /draw_line/x1/y1/x2/y2/2/r/g/b/200.
<

// ============================================================================
// Node Drawing - Fixed width for consistent layout
// ============================================================================

#draw_node(x, y, upgrade_id) >
    nw := NODE_W.
    nh := NODE_H.
    
    // Clip check
    << 0 when x + nw lt clip_x.
    << 0 when x gt clip_x + clip_w.
    << 0 when y + nh lt clip_y.
    << 0 when y gt clip_y + clip_h.
    
    // State
    has := /has_upgrade/upgrade_id.
    can := /can_unlock_upgrade/upgrade_id.
    cost := /get_upgrade_cost/upgrade_id.
    affordable := player_bank ge cost.
    available := can * affordable.
    branch := /get_upgrade_branch/upgrade_id.
    
    // Check hover (only if mouse in content area)
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    in_node := mx ge x and mx lt x + nw and my ge y and my lt y + nh.
    in_clip := mx ge clip_x and mx lt clip_x + clip_w and my ge clip_y and my lt clip_y + clip_h.
    hovered := in_node * in_clip.
    tech_hovered = upgrade_id when hovered == 1.
    
    // Base colors by branch
    // 0 = buff (warm), 1 = diff (green), 2 = lang (blue)
    bg_r := 28. bg_g := 30. bg_b := 35.
    br_r := 50. br_g := 55. br_b := 65.
    
    // Tint by branch when locked
    br_r = 90 when branch == 0 and has == 0. br_g = 55 when branch == 0 and has == 0. br_b = 45 when branch == 0 and has == 0.
    br_r = 55 when branch == 1 and has == 0. br_g = 75 when branch == 1 and has == 0. br_b = 55 when branch == 1 and has == 0.
    br_r = 45 when branch == 2 and has == 0. br_g = 65 when branch == 2 and has == 0. br_b = 90 when branch == 2 and has == 0.
    
    // Available = brighter border
    br_r = 170 when available == 1 and branch == 0. br_g = 110 when available == 1 and branch == 0. br_b = 70 when available == 1 and branch == 0.
    br_r = 100 when available == 1 and branch == 1. br_g = 150 when available == 1 and branch == 1. br_b = 100 when available == 1 and branch == 1.
    br_r = 70 when available == 1 and branch == 2. br_g = 140 when available == 1 and branch == 2. br_b = 190 when available == 1 and branch == 2.
    bg_r = 38 when available == 1. bg_g = 42 when available == 1. bg_b = 48 when available == 1.
    
    // Can unlock but can't afford = dimmer
    just_can := can * (1 - affordable).
    br_r = 120 when just_can == 1. br_g = 80 when just_can == 1. br_b = 50 when just_can == 1.
    
    // Owned = filled with branch color
    bg_r = 55 when has == 1 and branch == 0. bg_g = 40 when has == 1 and branch == 0. bg_b = 35 when has == 1 and branch == 0.
    br_r = 200 when has == 1 and branch == 0. br_g = 150 when has == 1 and branch == 0. br_b = 100 when has == 1 and branch == 0.
    bg_r = 35 when has == 1 and branch == 1. bg_g = 50 when has == 1 and branch == 1. bg_b = 35 when has == 1 and branch == 1.
    br_r = 100 when has == 1 and branch == 1. br_g = 180 when has == 1 and branch == 1. br_b = 100 when has == 1 and branch == 1.
    bg_r = 35 when has == 1 and branch == 2. bg_g = 45 when has == 1 and branch == 2. bg_b = 60 when has == 1 and branch == 2.
    br_r = 90 when has == 1 and branch == 2. br_g = 160 when has == 1 and branch == 2. br_b = 220 when has == 1 and branch == 2.
    
    // Hover boost
    bg_r = bg_r + 15 when hovered == 1.
    bg_g = bg_g + 15 when hovered == 1.
    bg_b = bg_b + 15 when hovered == 1.
    
    // Draw node
    /draw_rect/x/y/nw/nh/bg_r/bg_g/bg_b/255.
    
    // Border - consistent 2px on all sides
    /draw_rect/x/y/nw/2/br_r/br_g/br_b/255.
    /draw_rect/x/(y + nh - 2)/nw/2/(br_r * 7 / 10)/(br_g * 7 / 10)/(br_b * 7 / 10)/255.
    /draw_rect/x/y/2/nh/br_r/br_g/br_b/255.
    /draw_rect/(x + nw - 2)/y/2/nh/(br_r * 7 / 10)/(br_g * 7 / 10)/(br_b * 7 / 10)/255.
    
    // Text - upgrade name
    name := /get_upgrade_name/upgrade_id.
    tx := x + NODE_PAD_X.
    ty := y + 8.
    
    tr := 130. tg := 135. tb := 145.
    tr = 220 when available == 1. tg = 200 when available == 1. tb = 150 when available == 1.
    tr = 190 when has == 1. tg = 210 when has == 1. tb = 220 when has == 1.
    
    /text_draw/tx/ty/14/tr/tg/tb/name.
    
    // Cost or status - on second line
    cy := y + 26.
    >
        /text_draw/(x + nw / 2 - 12)/cy/14/100/180/100/"OK".
    < when has == 1.
    >
        cr := 95. cg := 100. cb := 110.
        cr = 100 when available == 1. cg = 190 when available == 1. cb = 100 when available == 1.
        cr = 190 when just_can == 1. cg = 140 when just_can == 1. cb = 80 when just_can == 1.
        /text_draw/(x + NODE_PAD_X)/cy/14/cr/cg/cb/"$".
        /text_draw_int/(x + NODE_PAD_X + 12)/cy/14/cr/cg/cb/cost.
    < when has == 0.
<

#draw_node_tooltip() >
    upgrade_id := tech_hovered.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    
    // Get text
    name := /get_upgrade_name/upgrade_id.
    desc := /get_upgrade_desc/upgrade_id.
    
    // Fixed width - large enough for longest description
    // "Floors have 5+ rooms (+$2)" = 26 chars
    tw := 240.
    th := 55.
    
    // Position offset from mouse
    tx := mx + 18.
    ty := my - 60.
    
    // Keep on screen
    tx = tech_tree_x + tech_tree_w - tw - 10 when tx + tw gt tech_tree_x + tech_tree_w.
    ty = tech_tree_y + TREE_HEADER_H + 5 when ty lt tech_tree_y + TREE_HEADER_H.
    
    // Background
    /draw_rect/tx/ty/tw/th/22/25/32/245.
    
    // Border - consistent 2px
    /draw_rect/tx/ty/tw/2/70/80/100/255.
    /draw_rect/tx/(ty + th - 2)/tw/2/35/40/50/255.
    /draw_rect/tx/ty/2/th/60/70/90/255.
    /draw_rect/(tx + tw - 2)/ty/2/th/35/40/50/255.
    
    // Name
    /text_draw/(tx + 10)/(ty + 10)/14/220/210/170/name.
    
    // Description
    /text_draw/(tx + 10)/(ty + 30)/14/155/160/175/desc.
<

#draw_tutorial_popup() >
    // Draw larger centered tutorial popup
    cx := tech_tree_x + tech_tree_w / 2.
    cy := tech_tree_y + tech_tree_h / 2.
    
    pw := 360.
    ph := 340.
    px := cx - pw / 2.
    py := cy - ph / 2.
    
    // Background with border
    /draw_rect/px/py/pw/ph/15/20/30/250.
    /draw_rect/px/py/pw/3/80/160/200/255.
    /draw_rect/px/(py + ph - 3)/pw/3/40/80/100/255.
    /draw_rect/px/py/3/ph/60/120/160/255.
    /draw_rect/(px + pw - 3)/py/3/ph/60/120/160/255.
    
    // Title (large, centered feel)
    /text_draw/(px + 15)/(py + 12)/16/100/200/255/tutorial_title.
    
    // Separator line
    /draw_rect/(px + 15)/(py + 35)/330/1/50/80/110/200.
    
    // Tutorial text (6 lines)
    /text_draw/(px + 15)/(py + 45)/14/200/200/210/tutorial_line_1.
    /text_draw/(px + 15)/(py + 60)/14/200/200/210/tutorial_line_2.
    /text_draw/(px + 15)/(py + 75)/14/200/200/210/tutorial_line_3.
    /text_draw/(px + 15)/(py + 90)/14/200/200/210/tutorial_line_4.
    /text_draw/(px + 15)/(py + 105)/14/200/200/210/tutorial_line_5.
    /text_draw/(px + 15)/(py + 120)/14/200/200/210/tutorial_line_6.
    
    // Code examples section
    /draw_rect/(px + 15)/(py + 140)/330/1/50/80/110/200.
    /text_draw/(px + 15)/(py + 150)/14/120/160/200/"EXAMPLES:".
    
    // Code examples (4 lines, monospace-style coloring)
    /text_draw/(px + 15)/(py + 170)/14/255/220/100/tutorial_code_1.
    /text_draw/(px + 15)/(py + 185)/14/255/220/100/tutorial_code_2.
    /text_draw/(px + 15)/(py + 200)/14/255/220/100/tutorial_code_3.
    /text_draw/(px + 15)/(py + 215)/14/255/220/100/tutorial_code_4.
    
    // Tip section
    /draw_rect/(px + 15)/(py + 240)/330/1/50/80/110/200.
    /text_draw/(px + 15)/(py + 255)/14/100/220/150/tutorial_tip.
    
    // Close button
    btn_x := px + pw / 2 - 50.
    btn_y := py + ph - 45.
    btn_w := 100.
    btn_h := 30.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    btn_hover := mx ge btn_x and mx lt btn_x + btn_w and my ge btn_y and my lt btn_y + btn_h.
    
    bg_r := 40. bg_g := 80. bg_b := 100.
    bg_r = 60 when btn_hover == 1. bg_g = 120 when btn_hover == 1. bg_b = 150 when btn_hover == 1.
    
    /draw_rect/btn_x/btn_y/btn_w/btn_h/bg_r/bg_g/bg_b/255.
    /draw_rect/btn_x/btn_y/btn_w/2/100/180/220/255.
    
    /text_draw/(btn_x + 22)/(btn_y + 8)/14/220/240/255/"GOT IT!".
    
    // Handle click
    just_clicked := /input_mouse_just_pressed/.
    /close_tutorial/ when just_clicked == 1 and btn_hover == 1.
<

#update_tech_tree() >
    // Skip if tutorial is active
    << 0 when tutorial_active == 1.
    
    // Only process input when mouse is over the tech tree area
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    in_tree := mx ge tech_tree_x and mx lt tech_tree_x + tech_tree_w and my ge tech_tree_y and my lt tech_tree_y + tech_tree_h.
    << 0 when in_tree == 0.
    
    // Handle drag scrolling
    /update_tech_drag/.
    
    // Check for click (only if not dragging)
    just_clicked := /input_mouse_just_pressed/.
    << 0 when just_clicked == 0.
    
    // Skip if we were dragging
    drag_dx := mx - tech_drag_start_x.
    drag_dy := my - tech_drag_start_y.
    drag_dx = 0 - drag_dx when drag_dx lt 0.
    drag_dy = 0 - drag_dy when drag_dy lt 0.
    << 0 when drag_dx gt 5 or drag_dy gt 5.
    
    // Check if in content area (clipped region inside the tree panel)
    in_x := mx ge clip_x and mx lt clip_x + clip_w.
    in_y := my ge clip_y and my lt clip_y + clip_h.
    << 0 when in_x * in_y == 0.
    
    // Calculate positions (must match draw_*_tree)
    nw := NODE_W.
    nh := NODE_H.
    gx := NODE_GAP_X.
    gy := NODE_GAP_Y + 8.
    branch_w := NODE_W * 3 + NODE_GAP_X * 2.
    
    bx := clip_x + TREE_PADDING + tech_scroll_x.
    by := clip_y + clip_h - TREE_PADDING + tech_scroll_y.
    
    // Row positions (10 rows for buff tree with speed start)
    row0 := by - nh.
    row1 := row0 - nh - gy.
    row2 := row1 - nh - gy.
    row3 := row2 - nh - gy.
    row4 := row3 - nh - gy.
    row5 := row4 - nh - gy.
    row6 := row5 - nh - gy.
    row7 := row6 - nh - gy.
    row8 := row7 - nh - gy.
    row9 := row8 - nh - gy.
    
    // BUFF tree columns (3 columns: stats, gold, speed)
    col0 := bx.
    col1 := bx + nw + gx.
    col2 := bx + (nw + gx) * 2.
    colm := bx + (nw + gx) / 2.
    
    // BUFF tree - Row 0: Speed 5x (center)
    /try_node_click/colm/row0/UPGRADE_BUFF_SPEED_5/mx/my.
    
    // Row 1: Speed 10x (center)
    /try_node_click/colm/row1/UPGRADE_BUFF_SPEED_10/mx/my.
    
    // Row 2: HP I (left), Gold Spawn (center), Speed 100x (right)
    /try_node_click/col0/row2/UPGRADE_BUFF_HP_1/mx/my.
    /try_node_click/col1/row2/UPGRADE_BUFF_GOLD_SPAWN/mx/my.
    /try_node_click/col2/row2/UPGRADE_BUFF_SPEED_100/mx/my.
    
    // Row 3: STR I (left), Gold Spawn+ (center), Speed 1000x (right)
    /try_node_click/col0/row3/UPGRADE_BUFF_STR_1/mx/my.
    /try_node_click/col1/row3/UPGRADE_BUFF_GOLD_SPAWN_2/mx/my.
    /try_node_click/col2/row3/UPGRADE_BUFF_SPEED_1000/mx/my.
    
    // Row 4: AC I (left)
    /try_node_click/col0/row4/UPGRADE_BUFF_AC_1/mx/my.
    
    // Row 5: HP II (left)
    /try_node_click/col0/row5/UPGRADE_BUFF_HP_2/mx/my.
    
    // Row 6: STR II (left), Gold Drops (center)
    /try_node_click/col0/row6/UPGRADE_BUFF_STR_2/mx/my.
    /try_node_click/col1/row6/UPGRADE_BUFF_GOLD_DROP/mx/my.
    
    // Row 7: AC II (left), Gold Drops+ (center)
    /try_node_click/col0/row7/UPGRADE_BUFF_AC_2/mx/my.
    /try_node_click/col1/row7/UPGRADE_BUFF_GOLD_DROP_2/mx/my.
    
    // Row 8: HP III (center)
    /try_node_click/colm/row8/UPGRADE_BUFF_HP_3/mx/my.
    
    // Row 9: STR III (center)
    /try_node_click/colm/row9/UPGRADE_BUFF_STR_3/mx/my.
    
    // DIFF tree (right of Buff, grows upward - 7 rows)
    diff_x := bx + branch_w + BRANCH_GAP.
    dcol0 := diff_x.
    dcol1 := diff_x + nw + gx.
    dcolm := diff_x + (nw + gx) / 2.
    drow6 := row5 - nh - gy.
    
    /try_node_click/dcolm/row0/UPGRADE_DIFF_STAIRS_RANDOM/mx/my.
    /try_node_click/dcolm/row1/UPGRADE_DIFF_VAR_SIZE/mx/my.
    /try_node_click/dcol0/row2/UPGRADE_DIFF_ROOM_2/mx/my.
    /try_node_click/dcol1/row2/UPGRADE_DIFF_KOBOLDS/mx/my.
    /try_node_click/dcol0/row3/UPGRADE_DIFF_ROOM_3/mx/my.
    /try_node_click/dcol1/row3/UPGRADE_DIFF_GOBLINS/mx/my.
    /try_node_click/dcolm/row4/UPGRADE_DIFF_MONSTER_2/mx/my.
    /try_node_click/dcol0/row5/UPGRADE_DIFF_ROOM_4/mx/my.
    /try_node_click/dcol1/row5/UPGRADE_DIFF_MONSTER_3/mx/my.
    /try_node_click/dcolm/drow6/UPGRADE_DIFF_ROOM_MANY/mx/my.
    
    // LANG tree (centered below Buff/Diff, grows DOWNWARD - 3 columns, 9 rows)
    lang_x := bx + branch_w / 2 + BRANCH_GAP / 2.
    lcol0 := lang_x.
    lcol1 := lang_x + nw + gx.
    lcol2 := lang_x + (nw + gx) * 2.
    lcolm := lang_x + nw + gx. // Middle column
    
    // Row positions for downward-growing tree
    lang_by := by + TREE_PADDING * 2.
    lrow0 := lang_by.
    lrow1 := lrow0 + nh + gy.
    lrow2 := lrow1 + nh + gy.
    lrow3 := lrow2 + nh + gy.
    lrow4 := lrow3 + nh + gy.
    lrow5 := lrow4 + nh + gy.
    lrow6 := lrow5 + nh + gy.
    lrow7 := lrow6 + nh + gy.
    lrow8 := lrow7 + nh + gy.
    
    // Row 0: FOR (start)
    /try_lang_node_click/lcolm/lrow0/UPGRADE_LANG_FOR/mx/my.
    // Row 1: When, Comparison
    /try_lang_node_click/lcol0/lrow1/UPGRADE_LANG_WHEN/mx/my.
    /try_lang_node_click/lcol2/lrow1/UPGRADE_LANG_COMPARISON/mx/my.
    // Row 2: CanMove, Variables, Arithmetic
    /try_lang_node_click/lcol0/lrow2/UPGRADE_LANG_CANMOVE/mx/my.
    /try_lang_node_click/lcolm/lrow2/UPGRADE_LANG_VARIABLES/mx/my.
    /try_lang_node_click/lcol2/lrow2/UPGRADE_LANG_ARITHMETIC/mx/my.
    // Row 3: Functions
    /try_lang_node_click/lcolm/lrow3/UPGRADE_LANG_FUNCTIONS/mx/my.
    // Row 4: Break, Return
    /try_lang_node_click/lcol0/lrow4/UPGRADE_LANG_BREAK/mx/my.
    /try_lang_node_click/lcol2/lrow4/UPGRADE_LANG_RETURN/mx/my.
    // Row 5: Loop
    /try_lang_node_click/lcolm/lrow5/UPGRADE_LANG_LOOP/mx/my.
    // Row 6: Data
    /try_lang_node_click/lcol0/lrow6/UPGRADE_LANG_ARRAYS/mx/my.
    /try_lang_node_click/lcolm/lrow6/UPGRADE_LANG_STRUCTS/mx/my.
    /try_lang_node_click/lcol2/lrow6/UPGRADE_LANG_STRINGS/mx/my.
    // Row 7: Advanced
    /try_lang_node_click/lcol0/lrow7/UPGRADE_LANG_IFELSE/mx/my.
    /try_lang_node_click/lcolm/lrow7/UPGRADE_LANG_PIPES/mx/my.
    /try_lang_node_click/lcol2/lrow7/UPGRADE_LANG_BLOCKWHEN/mx/my.
    // Row 8: Expert
    /try_lang_node_click/lcol0/lrow8/UPGRADE_LANG_PATTERN/mx/my.
    /try_lang_node_click/lcol2/lrow8/UPGRADE_LANG_LAMBDA/mx/my.
    
    // Vision APIs: Branch from Can Move at row2 (to the LEFT)
    // Uses lcolL1 for Surroundings branch, lcolL2 for Scan branch
    lcolL1 := lang_x - (nw + gx).       // First column to the left
    lcolL2 := lcolL1 - (nw + gx).       // Second column to the left
    
    // Surroundings -> Pathfind -> Find (in colL1, rows 3-5)
    /try_lang_node_click/lcolL1/lrow3/UPGRADE_LANG_SURROUNDINGS/mx/my.
    /try_lang_node_click/lcolL1/lrow4/UPGRADE_LANG_PATHFIND/mx/my.
    /try_lang_node_click/lcolL1/lrow5/UPGRADE_LANG_FIND/mx/my.
    
    // Scan -> Room -> FullMap (in colL2, rows 3-5)
    /try_lang_node_click/lcolL2/lrow3/UPGRADE_LANG_SCAN/mx/my.
    /try_lang_node_click/lcolL2/lrow4/UPGRADE_LANG_ROOM/mx/my.
    /try_lang_node_click/lcolL2/lrow5/UPGRADE_LANG_FULLMAP/mx/my.
<

#update_tech_drag() >
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    down := /input_mouse_down/.
    just := /input_mouse_just_pressed/.
    
    // In content area?
    in_x := mx ge clip_x and mx lt clip_x + clip_w.
    in_y := my ge clip_y and my lt clip_y + clip_h.
    in_content := in_x * in_y.
    
    // Start drag
    >
        tech_drag_start_x = mx.
        tech_drag_start_y = my.
        tech_drag_scroll_x = tech_scroll_x.
        tech_drag_scroll_y = tech_scroll_y.
        tech_dragging = 1.
    < when just == 1 and in_content == 1.
    
    // Stop drag
    tech_dragging = 0 when down == 0.
    
    // Update scroll while dragging
    >
        tech_scroll_x = tech_drag_scroll_x + (mx - tech_drag_start_x).
        tech_scroll_y = tech_drag_scroll_y + (my - tech_drag_start_y).
    < when tech_dragging == 1.
<

#try_node_click(x, y, upgrade_id, mx, my) >
    nw := NODE_W.
    nh := NODE_H.
    in_x := mx ge x and mx lt x + nw.
    in_y := my ge y and my lt y + nh.
    << 0 when in_x * in_y == 0.
    
    result := /try_purchase_upgrade/upgrade_id.
    // Restart bot and regenerate dungeon when purchased
    >
        /generate_dungeon/.
        /bot_reset_on_change/.
    < when result == 1.
<

// Special click handler for language nodes - allows re-showing tutorial
#try_lang_node_click(x, y, upgrade_id, mx, my) >
    nw := NODE_W.
    nh := NODE_H.
    in_x := mx ge x and mx lt x + nw.
    in_y := my ge y and my lt y + nh.
    << 0 when in_x * in_y == 0.
    
    // Check if already purchased - if so, just show tutorial again
    has := /has_upgrade/upgrade_id.
    >
        /show_language_tutorial/upgrade_id.
        << 1.
    < when has == 1.
    
    // Otherwise try to purchase
    result := /try_purchase_upgrade/upgrade_id.
    << result.
<
