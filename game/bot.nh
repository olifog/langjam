// ============================================================================
// Bot Interpreter Module
// Runs user code from the editor to control the bot
// ============================================================================

// Import interpreter modules (shared with standalone interpreter)
@use "../interpreter/ast.nh".
@use "../interpreter/lexer.nh".
@use "../interpreter/parser.nh".

// Import bot-specific modules
@use "bot_eval.nh".
@use "bot_ui.nh".

// ============================================================================
// Bot Interpreter State
// ============================================================================

bot_ast := 0.          // The parsed AST
bot_env := 0.          // The execution environment
bot_is_running := 0.   // 1 if continuously running, 0 if stopped
bot_is_stepping := 0.  // 1 if we're in step mode
bot_step_timer := 0.   // Timer for continuous run delay
bot_step_delay := 500. // Delay between steps in continuous mode (ms)
bot_error := "".       // Error message if any
bot_has_error := 0.    // 1 if there's an error


// Current execution line (0-indexed, -1 = not running)
bot_current_line := 0 - 1.

// Code hash for detecting edits (simple checksum)
bot_code_hash := 0.

// Statement list for line-by-line execution
bot_statements := [].      // Array of statement AST nodes
bot_stmt_lines := [].      // Array of line numbers for each statement
bot_stmt_count := 0.       // Number of statements
bot_stmt_index := 0.       // Current statement index (which one to execute next)

// Flag for when bot action happens (for animation timing)
bot_did_move := 0.

// Timeout protection
bot_ops_count := 0.
bot_max_ops := 100000.

// Yield state - for pausing execution mid-loop
bot_yield := 0.            // 1 if we should pause execution
bot_in_loop := 0.          // 1 if we're suspended inside a loop
bot_loop_node := 0.        // The loop AST node we're in
bot_loop_iter := 0.        // Current iteration (for for-loops)
bot_loop_var := "".        // Loop variable name (for for-loops)
bot_loop_end := 0.         // Loop end value (for for-loops)
bot_loop_env := 0.         // Environment for the loop

// Loop body stepping - for line-by-line within loops
bot_loop_body_stmts := []. // Flattened statements in loop body
bot_loop_body_count := 0.  // Number of statements in loop body
bot_loop_body_idx := 0.    // Current statement index within body

// Print output for debugging
bot_print_buffer := 0.     // Last printed value
bot_print_is_string := 0.  // 1 if the value is a string pointer
bot_has_print := 0.        // 1 if there's a value to display

// ============================================================================
// Bot Control Interface
// ============================================================================

#bot_compile_editor_code() >
    // Reset error state first
    bot_error = "".
    bot_has_error = 0.
    
    // Concatenate all editor lines into a single source string
    source := "".
    new_hash := 0.
    for i in 0..editor_num_lines >
        line := editor_lines[i].
        source = /ds_string_concat/source/line.
        source = /ds_string_concat/source/"\n".
        // Simple hash: sum of line lengths * (i+1)
        new_hash = new_hash + /ds_strlen/line * (i + 1).
    <
    
    // Check if code changed - reset state if so
    /bot_reset_on_change/ when new_hash != bot_code_hash.
    bot_code_hash = new_hash.
    
    // Tokenize
    tokens := /tokenize/source.
    
    // Check for empty program
    token_count := /ds_list_len/tokens.
    << /bot_set_error/"Empty program" when token_count le 1.
    
    // Parse into statement list with line numbers
    /bot_parse_to_statements/tokens.
    
    // Check for parse failure
    << /bot_set_error/"Syntax error in program" when bot_stmt_count == 0.
    
    // Create fresh environment
    bot_env = /bot_env_new/.
    
    // Reset execution position
    bot_stmt_index = 0.
    bot_current_line = bot_stmt_lines[0] when bot_stmt_count gt 0.
    
    << 1.
<

#bot_parse_to_statements(tokens) >
    bot_stmt_count = 0.
    pos := 0.
    max_iter := 500.
    iter := 0.
    
    loop >
        tok := /peek/tokens/pos.
        >> when tok->type == TOK_EOF.
        >> when tok == 0.
        >> when iter ge max_iter.
        
        // Get line number from first token of statement
        stmt_line := tok->line.
        
        old_pos := pos.
        res := /parse_stmt/tokens/pos.
        pos = res->end.
        
        // Safety: prevent infinite loop
        pos = pos + 1 when pos == old_pos.
        >> when pos == old_pos.
        
        // Store statement and its line number
        /bot_add_statement/res->node/stmt_line when res->node != 0.
        
        iter = iter + 1.
    <
<

#bot_add_statement(node, line) >
    idx := bot_stmt_count.
    bot_statements[idx] = node.
    bot_stmt_lines[idx] = line.
    bot_stmt_count = bot_stmt_count + 1.
<

#bot_reset_on_change() >
    bot_current_line = 0 - 1.
    bot_stmt_count = 0.
    bot_stmt_index = 0.
    bot_env = 0.
    bot_is_stepping = 0.
    bot_is_running = 0.
    // Reset loop state
    bot_yield = 0.
    bot_in_loop = 0.
    bot_loop_node = 0.
    bot_loop_env = 0.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
<

// Call this from editor when code is modified
#bot_notify_code_changed() >
    // Only reset if actively stepping - play mode recompiles every time
    /bot_reset_on_change/ when bot_is_stepping == 1.
<

bot_message := "".

#bot_set_error(msg) >
    bot_error = msg.
    bot_has_error = 1.
    bot_message = msg.
    << 0.
<

#bot_start() >
    /bot_compile_editor_code/.
    
    // Don't start if there's an error
    << 0 when bot_has_error == 1.
    
    bot_is_running = 1.
    bot_is_stepping = 0.
    bot_step_timer = 0.
    bot_stmt_index = 0.
    // Reset loop state for fresh start
    bot_yield = 0.
    bot_in_loop = 0.
    bot_loop_node = 0.
    bot_loop_env = 0.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    bot_loop_body_idx = 0.
    bot_ops_count = 0.
    bot_current_line = bot_stmt_lines[0] when bot_stmt_count gt 0.
    bot_message = "Bot running...".
    last_message = "". // Clear welcome message
<

#bot_stop() >
    bot_is_running = 0.
    bot_is_stepping = 0.
    bot_env = 0.
    bot_stmt_count = 0.
    bot_stmt_index = 0.
    bot_current_line = 0 - 1.
    bot_code_hash = 0.
    // Reset loop state
    bot_yield = 0.
    bot_in_loop = 0.
    bot_loop_node = 0.
    bot_loop_env = 0.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    // last_message = "Bot stopped.". // Removed to prevent duplicate
    bot_message = "Bot stopped.".
    // Clear arrays so GC can collect old objects
    /gc_clear_array/bot_statements/16384.
    /gc_clear_array/bot_loop_body_stmts/16384.
    // Clear execution stack and force garbage collection
    /gc_clear_exec_stack/.
    /gc_force_collect/.
<

#bot_pause() >
    // Pause execution but keep all state intact
    bot_is_running = 0.
    bot_message = "Paused.".
<

#bot_resume() >
    // Resume from current state if we have one, otherwise start fresh
    // Check if we have existing state (env exists and statements parsed)
    has_state := 0.
    has_state = 1 when bot_env != 0 and bot_stmt_count gt 0.
    
    // If no existing state, start fresh
    << /bot_start/ when has_state == 0.
    
    // Resume from current position
    bot_is_running = 1.
    bot_is_stepping = 0.
    bot_step_timer = 0.
    bot_ops_count = 0.
    bot_message = "Resumed...".
<

#bot_step_once() >
    // Check if we need to compile (first time or code changed)
    /bot_check_recompile/.
    
    // Don't step if there's an error
    << 0 when bot_has_error == 1.
    
    // Check if we've executed all statements
    << /bot_finished_message/ when bot_stmt_index ge bot_stmt_count.
    
    bot_is_stepping = 1.
    bot_is_running = 0.
    bot_has_print = 0.
    
    // Execute one step
    /bot_do_step/.
    
    // Show print output if any
    /bot_show_print/ when bot_has_print == 1.
    bot_message = "Step executed." when bot_has_print == 0.
<

#bot_show_print() >
    // Display the printed value - keep bot_has_print set for render
    bot_message = "Print:".
<

// Shared core: execute one statement and handle side effects
#bot_do_step() >
    // Clear yield flag at start of each step
    bot_yield = 0.
    
    // Check if we're resuming a suspended loop
    << /bot_resume_loop/ when bot_in_loop gt 0.
    
    << 0 when bot_stmt_index ge bot_stmt_count.
    
    // Execute current statement
    /bot_execute_current_statement/.
    
    // Check if bot reached stairs
    tile := /get_tile/player_x/player_y.
    /bot_handle_stairs/ when tile == TILE_STAIRS.
    
    // Check if we just finished (only if not yielded mid-loop)
    << /bot_finished_message/ when bot_stmt_index ge bot_stmt_count and bot_in_loop == 0.
<

#bot_resume_loop() >
    // Resume a suspended loop
    bot_yield = 0.
    
    was_in_loop := bot_in_loop.
    
    // Resume infinite loop (bot_in_loop == 1)
    /bot_resume_inf_loop/ when bot_in_loop == 1.
    
    // Resume for loop (bot_in_loop == 2)
    /bot_resume_for_loop/ when bot_in_loop == 2.
    
    // Check if bot reached stairs
    tile := /get_tile/player_x/player_y.
    /bot_handle_stairs/ when tile == TILE_STAIRS.
    
    // If loop finished (bot_in_loop went from >0 to 0), advance to next statement
    bot_stmt_index = bot_stmt_index + 1 when was_in_loop gt 0 and bot_in_loop == 0.
    
    << 0.
<



// Helper for Run Mode: execute flattened body until yield
#bot_exec_loop_body_run_mode(env) >
    loop >
        // Execute one flattened step
        /bot_step_loop_body/env.
        
        // Stop if we yielded, ran out of ops, or broke out of loop
        >> when bot_yield == 1.
        >> when /bot_check_ops/ == 1.
        >> when bot_in_loop == 0.
    <
<

#bot_resume_inf_loop() >
    node := bot_loop_node.
    env := bot_loop_env.
    
    // In step mode, execute one statement from flattened body
    << /bot_step_loop_body/env when bot_is_stepping == 1.
    
    // In run mode, execute using flattened body mechanism too (to track index)
    /bot_exec_loop_body_run_mode/env.
<

#bot_resume_for_loop() >
    node := bot_loop_node.
    env := bot_loop_env.
    i := bot_loop_iter.
    end := bot_loop_end.
    var := bot_loop_var.
    
    // Check if loop should end
    bot_in_loop = 0 when i gt end.
    << 0 when i gt end.
    
    // Set loop variable
    /bot_env_set/env/var/i.
    
    // In step mode, execute one statement from flattened body
    << /bot_step_loop_body/env when bot_is_stepping == 1.
    
    // In run mode, execute using flattened body mechanism too
    /bot_exec_loop_body_run_mode/env.
<

// Execute one statement from loop body (for step mode)
#bot_step_loop_body(env) >
    // If body not yet flattened, do it now
    /bot_flatten_loop_body/ when bot_loop_body_count == 0.
    
    // Check if we've finished the body
    << /bot_next_loop_iteration/ when bot_loop_body_idx ge bot_loop_body_count.
    
    // Get current statement in body
    stmt := bot_loop_body_stmts[bot_loop_body_idx].
    
    // Update line indicator - try to get line from node or its children
    line := /bot_get_node_line/stmt.
    bot_current_line = line when line gt 0.
    
    // Execute it
    /bot_eval/stmt/env.
    
    // Advance to next statement in body
    bot_loop_body_idx = bot_loop_body_idx + 1.
    
    // Check for flow control
    flow := /bot_env_get_flow/env.
    // break (flow == 1): exit loop
    bot_in_loop = 0 when flow == 1.
    /bot_env_set_flow/env/0 when flow == 1.
    // return (flow == 2): exit loop
    bot_in_loop = 0 when flow == 2.
    // continue (flow == 3): skip to next iteration
    /bot_env_set_flow/env/0 when flow == 3.
    << /bot_next_loop_iteration/ when flow == 3.
    
    // Check if we finished the body
    << /bot_next_loop_iteration/ when bot_loop_body_idx ge bot_loop_body_count.
<

// Try to get line number from a node, checking children if needed
#bot_get_node_line(node) >
    << 0 when node == 0.
    
    // Try direct line property
    << node->line when node->line gt 0.
    
    // Try stmt child (for when nodes)
    << node->stmt->line when node->stmt != 0 and node->stmt->line gt 0.
    
    // Try a child (for binary/seq nodes)
    << node->a->line when node->a != 0 and node->a->line gt 0.
    
    << 0.
<

#bot_next_loop_iteration() >
    // Reset body position for next iteration
    bot_loop_body_idx = 0.
    
    // Increment loop counter (for for-loops)
    bot_loop_iter = bot_loop_iter + 1 when bot_in_loop == 2.
    
    // Update loop variable for next iteration (for for-loops)
    /bot_env_set/bot_loop_env/bot_loop_var/bot_loop_iter when bot_in_loop == 2.
    
    // Check if for-loop should end
    bot_in_loop = 0 when bot_in_loop == 2 and bot_loop_iter gt bot_loop_end.
    
    << 0.
<

#bot_flatten_loop_body() >
    body := bot_loop_node->body.
    bot_loop_body_count = 0.
    /bot_flatten_stmt/body.
<

#bot_flatten_stmt(node) >
    << 0 when node == 0.
    
    // If it's a seq, flatten both sides
    /bot_flatten_stmt/node->a when node->tag == TAG_SEQ.
    /bot_flatten_stmt/node->b when node->tag == TAG_SEQ.
    << 0 when node->tag == TAG_SEQ.
    
    // Otherwise, add this statement to the list
    idx := bot_loop_body_count.
    bot_loop_body_stmts[idx] = node.
    bot_loop_body_count = bot_loop_body_count + 1.
<

#bot_check_recompile() >
    // If already stepping/running, only recompile if code changed
    << 0 when bot_is_stepping == 1.
    
    // If we have existing state (paused mid-execution), don't recompile
    << 0 when bot_env != 0 and bot_stmt_count gt 0.
    
    // Not yet stepping and no state, need to compile
    /bot_compile_editor_code/.
    
    // Set the current line to show first statement (before it runs)
    bot_current_line = bot_stmt_lines[0] when bot_stmt_count gt 0.
<

#bot_execute_current_statement() >
    << 0 when bot_stmt_index ge bot_stmt_count.
    
    // Get current statement
    stmt := bot_statements[bot_stmt_index].
    
    // Show indicator for THIS statement (the one about to run)
    bot_current_line = bot_stmt_lines[bot_stmt_index].
    
    // Execute it
    bot_did_move = 0.
    /bot_eval/stmt/bot_env.
    
    // Only advance if we're NOT suspended mid-loop
    // If we yielded inside a loop, don't advance - we'll resume this statement
    bot_stmt_index = bot_stmt_index + 1 when bot_in_loop == 0.
<


// Old definition removed


#bot_run_tick() >
    << 0 when bot_is_running == 0.
    << 0 when bot_stmt_count == 0.
    << 0 when bot_has_error == 1.
    
    // Reset ops count for this tick
    bot_ops_count = 0.
    
    // If we've reached the end, stop (don't loop)
    << /bot_finished_message/ when bot_stmt_index ge bot_stmt_count.
    
    // Execute one step (shared with bot_step_once)
    /bot_do_step/.
<

#bot_finished_message() >
    bot_is_running = 0.
    bot_is_stepping = 0.
    bot_current_line = 0 - 1.
    // Reset message
    bot_message = "Program Complete.".
    << 0.
<

#bot_handle_stairs() >
    last_message = "You found the stairs! Banking gold...".
    
    // Dungeon completion bonus (flat 1 for now, will increase later)
    dngn_bonus = 1.
    
    // Add current gold + bonus to bank
    player_bank = player_bank + player_gold + dngn_bonus.
    
    // Reset current gold for new floor
    player_gold = 0.
    
    // Reset health to full
    player_hp = player_max_hp.
    
    // Advance to next floor
    dungeon_level = dungeon_level + 1.
    /generate_dungeon/.
    last_message = "Welcome to the next level!".
    /spawn_particles/player_x/player_y.
    
    // Reset bot program to start from beginning
    bot_stmt_index = 0.
    bot_current_line = bot_stmt_lines[0] when bot_stmt_count gt 0.
    // Reset loop state
    bot_yield = 0.
    bot_in_loop = 0.
    bot_loop_node = 0.
    bot_loop_env = 0.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    
    bot_message = "Program restarting on new level...".
<
