// ============================================================================
// Bot Evaluator Module
// Evaluates the AST to execute bot code
// Has stepping/yield logic for the game's step-through debugger
// Uses TAG_* constants from interpreter/ast.nh
// ============================================================================

// ============================================================================
// Environment
// ============================================================================

#bot_check_ops() >
    bot_ops_count = bot_ops_count + 1.
    << 0 when bot_ops_count le bot_max_ops.
    
    // Timeout
    /bot_set_error/"Bot timed out: Infinite loop detected".
    << 1.
<

#bot_env_new() >
    env := /ds_object_create/0.
    /ds_set_prop/env/"__flow__"/0.
    /ds_set_prop/env/"__return__"/0.
    /ds_set_prop/env/"__parent__"/0.
    << env.
<

#bot_env_new_child(parent) >
    env := /ds_object_create/0.
    /ds_set_prop/env/"__flow__"/0.
    /ds_set_prop/env/"__return__"/0.
    /ds_set_prop/env/"__parent__"/parent.
    << env.
<

#bot_env_get_flow(env) >
    << /ds_object_get/env/"__flow__".
<

#bot_env_set_flow(env, val) >
    /ds_set_prop/env/"__flow__"/val.
    << val.
<

#bot_env_get_return(env) >
    << /ds_object_get/env/"__return__".
<

#bot_env_set_return(env, val) >
    /ds_set_prop/env/"__return__"/val.
    << val.
<

#bot_env_get(env, name) >
    val := /ds_object_get/env/name.
    parent := /ds_object_get/env/"__parent__".
    << (val == 0 and parent != 0) | >
        1 => /bot_env_get/parent/name
        0 => val
    <.
<

#bot_env_set(env, name, value) >
    /ds_set_prop/env/name/value.
    << value.
<

// ============================================================================
// Evaluator Core
// ============================================================================

#bot_eval_decl(node, env) >
    val := /bot_eval/node->expr/env.
    << /bot_env_set/env/node->name/val.
<

#bot_eval_assign(node, env) >
    val := /bot_eval/node->expr/env.
    << /bot_env_set/env/node->name/val.
<

#bot_eval_seq(node, env) >
    // Update line number for first statement
    bot_current_line = node->a->line when node->a->line gt 0.
    
    /bot_eval/node->a/env.
    
    // In step mode, yield after each statement
    bot_yield = 1 when bot_is_stepping == 1.
    
    flow := /bot_env_get_flow/env.
    << 0 when flow != 0.
    << 0 when bot_yield == 1.
    
    // Update line number for second statement
    bot_current_line = node->b->line when node->b->line gt 0.
    
    << /bot_eval/node->b/env.
<

#bot_eval_var(node, env) >
    << /bot_env_get/env/node->name.
<

#bot_eval_loop(node, env) >
    // In step mode, set up loop state and execute first statement only
    << /bot_enter_inf_loop_stepping/node/env when bot_is_stepping == 1.
    
    // In run mode, run the loop normally (yields on moves)
    res := 0.
    loop >
        >> when /bot_check_ops/ == 1.
        
        // Update line number for loop body
        bot_current_line = node->body->line when node->body->line gt 0.
        
        res = /bot_eval/node->body/env.
        flow := /bot_env_get_flow/env.
        >> when flow == 1. // break
        >> when flow == 2. // return
        // continue (flow == 3): reset flow and continue loop
        /bot_env_set_flow/env/0 when flow == 3.
        
        // Check if we should yield (from move)
        // Save loop state for resumption
        bot_in_loop = 1 when bot_yield == 1.
        bot_loop_node = node when bot_yield == 1.
        bot_loop_iter = 0 when bot_yield == 1.
        bot_loop_env = env when bot_yield == 1.
        >> when bot_yield == 1.
    <
    flow := /bot_env_get_flow/env.
    /bot_env_set_flow/env/0 when flow == 1.
    // Clear loop state if we finished normally
    bot_in_loop = 0 when bot_yield == 0.
    << res.
<

#bot_enter_inf_loop_stepping(node, env) >
    // Set up loop state for stepping
    bot_in_loop = 1.
    bot_loop_node = node.
    bot_loop_iter = 0.
    bot_loop_env = env.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    
    // Flatten body and execute first statement
    /bot_step_loop_body/env.
    << 0.
<

#bot_eval_break(node, env) >
    /bot_env_set_flow/env/1.
    << 0.
<

#bot_eval_continue(node, env) >
    /bot_env_set_flow/env/3.
    << 0.
<

#bot_eval_if(node, env) >
    cond := /bot_eval/node->cond/env.
    << cond | >
        1 => /bot_eval/node->then_br/env
        0 => /bot_eval/node->else_br/env
    <.
<

#bot_eval_when(node, env) >
    cond := /bot_eval/node->cond/env.
    << cond | >
        1 => /bot_eval/node->stmt/env
        0 => 0
    <.
<

#bot_eval_for(node, env) >
    start := /bot_eval/node->start/env.
    end := /bot_eval/node->end/env.
    var := node->var.
    
    // In step mode, set up loop state and execute first statement only
    << /bot_enter_for_loop_stepping/node/env/start/end/var when bot_is_stepping == 1.
    
    // In run mode, run the loop normally (yields on moves)
    i := start.
    loop >
        >> when /bot_check_ops/ == 1.
        >> when i gt end.
        
        /bot_env_set/env/var/i.
        
        // Update line number for loop body
        bot_current_line = node->body->line when node->body->line gt 0.
        
        /bot_eval/node->body/env.
        
        flow := /bot_env_get_flow/env.
        >> when flow == 1. // break
        >> when flow == 2. // return
        // continue (flow == 3): reset flow, increment i, continue loop
        /bot_env_set_flow/env/0 when flow == 3.
        
        i = i + 1.
        
        // Check if we should yield (from move)
        // Save for-loop state for resumption
        bot_in_loop = 2 when bot_yield == 1.
        bot_loop_node = node when bot_yield == 1.
        bot_loop_iter = i when bot_yield == 1.
        bot_loop_var = var when bot_yield == 1.
        bot_loop_end = end when bot_yield == 1.
        bot_loop_env = env when bot_yield == 1.
        >> when bot_yield == 1.
    <
    
    flow := /bot_env_get_flow/env.
    /bot_env_set_flow/env/0 when flow == 1.
    // Clear loop state if we finished normally
    bot_in_loop = 0 when bot_yield == 0.
    << 0.
<

#bot_enter_for_loop_stepping(node, env, start, end, var) >
    // Set up loop state for stepping
    bot_in_loop = 2.
    bot_loop_node = node.
    bot_loop_iter = start.
    bot_loop_var = var.
    bot_loop_end = end.
    bot_loop_env = env.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    
    // Set loop variable
    /bot_env_set/env/var/start.
    
    // Flatten body and execute first statement
    /bot_step_loop_body/env.
    << 0.
<

#bot_eval_func(node, env) >
    func := /ds_object_create/0.
    /ds_set_prop/func/"params"/node->params.
    /ds_set_prop/func/"body"/node->body.
    /ds_set_prop/func/"env"/env.
    /bot_env_set/env/node->name/func.
    << 0.
<

#bot_eval_call(node, env) >
    name := node->name.
    args := node->args.
    
    // Check for built-in functions first
    << /bot_builtin_move/args/env when /ds_streq/name/"move".
    << /bot_builtin_get_x/args/env when /ds_streq/name/"get_x".
    << /bot_builtin_get_y/args/env when /ds_streq/name/"get_y".
    << /bot_builtin_look/args/env when /ds_streq/name/"look".
    << /bot_builtin_can_walk/args/env when /ds_streq/name/"can_walk".
    << /bot_builtin_print/args/env when /ds_streq/name/"print".
    << /bot_builtin_strcat/args/env when /ds_streq/name/"strcat".
    << /bot_builtin_rng_int/args/env when /ds_streq/name/"rng_int".

    // Vision APIs
    << /bot_builtin_check_surroundings/args/env when /ds_streq/name/"check_surroundings".
    
    // State APIs
    << /bot_builtin_get_hp/args/env when /ds_streq/name/"get_hp".
    << /bot_builtin_get_max_hp/args/env when /ds_streq/name/"get_max_hp".
    << /bot_builtin_get_gold/args/env when /ds_streq/name/"get_gold".
    << /bot_builtin_get_level/args/env when /ds_streq/name/"get_level".
    
    // Look up user-defined function
    func := /bot_env_get/env/name.
    
    params := func->params.
    body := func->body.
    closure_env := func->env.
    
    call_env := /bot_env_new_child/closure_env.
    
    num_args := /ds_list_len/args.
    i := 0.
    loop >
        >> when i ge num_args.
        param := /ds_list_get/params/i.
        arg := /ds_list_get/args/i.
        arg_val := /bot_eval/arg/env.
        /bot_env_set/call_env/param/arg_val.
        i = i + 1.
    <
    
    res := /bot_eval/body/call_env.
    
    ret := /bot_env_get_return/call_env.
    flow := /bot_env_get_flow/call_env.
    
    << (flow == 2) | >
        1 => ret
        0 => res
    <.
<

#bot_eval_return(node, env) >
    val := /bot_eval/node->expr/env.
    /bot_env_set_return/env/val.
    /bot_env_set_flow/env/2.
    << val.
<

#bot_eval_match(node, env) >
    val := /bot_eval/node->value/env.
    arms := node->arms.
    num_arms := /ds_list_len/arms.
    
    i := 0.
    result := 0.
    found := 0.
    loop >
        >> when i ge num_arms.
        >> when found == 1.
        
        arm := /ds_list_get/arms/i.
        pattern := arm->pattern.
        
        match := pattern->tag | >
            TAG_WILDCARD => 1
            TAG_LIT => (val == pattern->value)
            _ => 0
        <.
        
        result = /bot_eval/arm->body/env when match.
        found = 1 when match.
        i = i + 1.
    <
    
    << result.
<

#bot_eval_array(node, env) >
    elements := node->elements.
    len := /ds_list_len/elements.
    result := /ds_list_create/.
    
    i := 0.
    loop >
        >> when i ge len.
        elem := /ds_list_get/elements/i.
        /ds_list_push/result/(/bot_eval/elem/env).
        i = i + 1.
    <
    
    << result.
<

#bot_eval_index(node, env) >
    arr := /bot_eval/node->arr/env.
    idx := /bot_eval/node->idx/env.
    << /ds_list_get/arr/idx.
<

#bot_eval_object(node, env) >
    fields := node->fields.
    len := /ds_list_len/fields.
    obj := /ds_object_create/0.
    
    i := 0.
    loop >
        >> when i ge len.
        field := /ds_list_get/fields/i.
        key := field->key.
        val := /bot_eval/field->value/env.
        /ds_set_prop/obj/key/val.
        i = i + 1.
    <
    
    << obj.
<

#bot_eval_prop(node, env) >
    obj := /bot_eval/node->obj/env.
    key := node->key.
    << /ds_object_get/obj/key.
<

#bot_eval_lambda(node, env) >
    func := /ds_object_create/0.
    /ds_set_prop/func/"params"/node->params.
    /ds_set_prop/func/"body"/node->body.
    /ds_set_prop/func/"env"/env.
    << func.
<

#bot_eval(node, env) >
    << 0 when node == 0.
    
    // Check ops limit (recursion protection)
    << 0 when /bot_check_ops/ == 1.
    
    << node->tag | >
        TAG_LIT => (node->value)
        TAG_VAR => /bot_eval_var/node/env
        TAG_ADD => /bot_eval/node->a/env + /bot_eval/node->b/env
        TAG_DECL => /bot_eval_decl/node/env
        TAG_SEQ => /bot_eval_seq/node/env
        TAG_ASSIGN => /bot_eval_assign/node/env
        TAG_NEG => 0 - /bot_eval/node->a/env
        TAG_SUB => /bot_eval/node->a/env - /bot_eval/node->b/env
        TAG_MUL => /bot_eval/node->a/env * /bot_eval/node->b/env
        TAG_DIV => /ds_div/(/bot_eval/node->a/env)/(/bot_eval/node->b/env)
        TAG_MOD => /ds_mod/(/bot_eval/node->a/env)/(/bot_eval/node->b/env)
        TAG_LT => (/bot_eval/node->a/env lt /bot_eval/node->b/env)
        TAG_GT => (/bot_eval/node->a/env gt /bot_eval/node->b/env)
        TAG_LE => (/bot_eval/node->a/env le /bot_eval/node->b/env)
        TAG_GE => (/bot_eval/node->a/env ge /bot_eval/node->b/env)
        TAG_EQ => /bot_eval_eq/(/bot_eval/node->a/env)/(/bot_eval/node->b/env)
        TAG_NE => (not /bot_eval_eq/(/bot_eval/node->a/env)/(/bot_eval/node->b/env))
        TAG_AND => (/bot_eval/node->a/env and /bot_eval/node->b/env)
        TAG_OR => (/bot_eval/node->a/env or /bot_eval/node->b/env)
        TAG_NOT => (not /bot_eval/node->a/env)
        TAG_LOOP => /bot_eval_loop/node/env
        TAG_BREAK => /bot_eval_break/node/env
        TAG_CONTINUE => /bot_eval_continue/node/env
        TAG_IF => /bot_eval_if/node/env
        TAG_WHEN => /bot_eval_when/node/env
        TAG_FOR => /bot_eval_for/node/env
        TAG_FUNC => /bot_eval_func/node/env
        TAG_CALL => /bot_eval_call/node/env
        TAG_RETURN => /bot_eval_return/node/env
        TAG_MATCH => /bot_eval_match/node/env
        TAG_STRING => (node->value)
        TAG_ARRAY => /bot_eval_array/node/env
        TAG_INDEX => /bot_eval_index/node/env
        TAG_OBJECT => /bot_eval_object/node/env
        TAG_PROP => /bot_eval_prop/node/env
        TAG_LAMBDA => /bot_eval_lambda/node/env
        _ => 0
    <.
<

// Equality helper (handles strings)
#bot_eval_eq(a, b) >
    // Check if both are strings
    is_str_a := /ds_is_string_like/a.
    is_str_b := /ds_is_string_like/b.
    
    // If both are strings, use string equality
    << /ds_streq/a/b when is_str_a == 1 and is_str_b == 1.
    
    // Otherwise use primitive equality
    << (a == b).
<

// ============================================================================
// Built-in Functions for Bot Control
// ============================================================================

// /move/dx/dy - Move the bot by delta x and y
#bot_builtin_move(args, env) >
    dx := /bot_eval/(/ds_list_get/args/0)/env.
    dy := /bot_eval/(/ds_list_get/args/1)/env.
    
    result := /try_move/dx/dy.
    bot_did_move = 1 when result == 1.
    
    // Yield after a successful move to allow rendering
    bot_yield = 1 when result == 1.
    
    << result.
<

// /get_x/ - Get the bot's current X position
#bot_builtin_get_x(args, env) >
    << player_x.
<

// /get_y/ - Get the bot's current Y position
#bot_builtin_get_y(args, env) >
    << player_y.
<

// /look/dx/dy - Look at a tile relative to the bot
#bot_builtin_look(args, env) >
    dx := /bot_eval/(/ds_list_get/args/0)/env.
    dy := /bot_eval/(/ds_list_get/args/1)/env.
    
    << /get_tile/(player_x + dx)/(player_y + dy).
<

// /can_walk/dx/dy - Check if a tile is walkable
#bot_builtin_can_walk(args, env) >
    dx := /bot_eval/(/ds_list_get/args/0)/env.
    dy := /bot_eval/(/ds_list_get/args/1)/env.
    
    tile := /get_tile/(player_x + dx)/(player_y + dy).
    << /can_walk/tile.
<

// /print/value - Print a value to the message area for debugging
#bot_builtin_print(args, env) >
    // /print/val - Print generic value
    // /print/val/1 - Print value as string (force)
    
    // Check if argument was a string literal in the AST
    // We need to look at the AST node for the argument, not just the evaluated value
    arg_node := /ds_list_get/args/0.
    is_str_lit := 0.
    is_str_lit = 1 when arg_node->tag == TAG_STRING.
    
    val := /bot_eval/arg_node/env.
    
    // Check for optional second argument (force string mode)
    force_string := 0.
    num_args := /ds_list_len/args.
    force_string = /bot_eval/(/ds_list_get/args/1)/env when num_args gt 1.
    
    // Check heuristic for string-like value
    heuristic := 0.
    heuristic = /ds_is_string_like/val.
    
    // Store in bot_print_buffer for display
    bot_print_buffer = val.
    bot_has_print = 1.
    bot_print_is_string = is_str_lit or force_string or heuristic.
    
    << val.
<


// /strcat/a/b - Concatenate two strings
#bot_builtin_strcat(args, env) >
    a := /bot_eval/(/ds_list_get/args/0)/env.
    b := /bot_eval/(/ds_list_get/args/1)/env.
    << /ds_string_concat/a/b.
<

// /get_hp/ - Get current HP
#bot_builtin_get_hp(args, env) >
    << player_hp.
<

// /get_max_hp/ - Get max HP
#bot_builtin_get_max_hp(args, env) >
    << player_max_hp.
<

// /get_gold/ - Get current Gold
#bot_builtin_get_gold(args, env) >
    << player_gold.
<

// /get_level/ - Get current Dungeon Level
#bot_builtin_get_level(args, env) >
    << dungeon_level.
<
// /rng_int/max - Returns random integer 0..max-1
#bot_builtin_rng_int(args, env) >
    max := /bot_eval/(/ds_list_get/args/0)/env.
    << /rng_int/max.
<

// /check_surroundings/ - Returns 3x3 grid of char codes
// [[NW, N, NE], [W, C, E], [SW, S, SE]]
#bot_builtin_check_surroundings(args, env) >
    grid := /ds_list_create/.
    
    // Iterate rows (dy: -1 to 1)
    py := player_y.
    px := player_x.
    
    for dy_offset in 0..3 >
        dy := dy_offset - 1.
        row := /ds_list_create/.
        
        for dx_offset in 0..3 >
            dx := dx_offset - 1.
            
            ax := px + dx.
            ay := py + dy.
            
            // Default: Empty/Void
            char_code := 0. 
            
            // 1. Check Entity
            e_idx := /get_entity_at/ax/ay.
            
            // 2. Check Tile
            tile := /get_tile/ax/ay.
            
            // Priority Logic
            done := 0.
            
            // Monster?
            is_mon := 0.
            is_mon = 1 when e_idx != -1.
            // Convert char code to string
            char_code = /ds_char_to_string/entity_type[e_idx] when is_mon == 1.
            done = 1 when is_mon == 1.
            
            // Gold?
            is_gold := 0.
            is_gold = 1 when tile == TILE_GOLD.
            char_code = "$" when is_gold == 1 and done == 0. // '$'
            done = 1 when is_gold == 1.
            
            // Stairs?
            is_stairs := 0.
            is_stairs = 1 when tile == TILE_STAIRS.
            char_code = ">" when is_stairs == 1 and done == 0. // '>'
            done = 1 when is_stairs == 1.
            
            // Terrain Fallback
            // Map tiles to strings (only if not done)
            char_code = "." when tile == TILE_FLOOR and done == 0.      // '.'
            char_code = "#" when tile == TILE_CORRIDOR and done == 0.   // '#'
            char_code = "-" when tile == TILE_WALL_H and done == 0.     // '-'
            char_code = "|" when tile == TILE_WALL_V and done == 0.     // '|'
            char_code = "+" when tile == TILE_DOOR and done == 0.       // '+'
            // Empty maps to 0
            
            /ds_list_push/row/char_code.
        <
        /ds_list_push/grid/row.
    <
    
    << grid.
<

