// ============================================================================
// Code Editor Module
// A text editor for programming the dungeon bot
// ============================================================================

// ============================================================================
// Key Constants
// ============================================================================

KEY_LEFT := 0.
KEY_RIGHT := 1.
KEY_UP := 2.
KEY_DOWN := 3.
KEY_SPACE := 4.
KEY_ENTER := 5.
KEY_TAB := 10.
KEY_BACKSPACE := 11.
KEY_DELETE := 12.
KEY_HOME := 13.
KEY_END := 14.
KEY_ESCAPE := 15.

KEY_LETTER_BASE := 100.
KEY_DIGIT_BASE := 200.
KEY_MINUS := 210.
KEY_EQUAL := 211.
KEY_BRACKET_L := 212.
KEY_BRACKET_R := 213.
KEY_SEMICOLON := 214.
KEY_QUOTE := 215.
KEY_BACKQUOTE := 216.
KEY_BACKSLASH := 217.
KEY_COMMA := 218.
KEY_PERIOD := 219.
KEY_SLASH := 220.

// ============================================================================
// Editor State
// ============================================================================

EDITOR_MAX_LINES := 100.
EDITOR_FONT_SIZE := 14.
EDITOR_LINE_HEIGHT := 18.
// Berkeley Mono at 14px is approximately 9.0px wide in browser rendering
// Using 90 and dividing by 10 for pseudo-float math
EDITOR_CHAR_WIDTH_X10 := 84.
// Cursor offset to position it between characters (negative shifts left, positive right)
// Set to 0 for cursor at start of character cell, negative to shift left
EDITOR_CURSOR_OFFSET := 0 - 1.

// Editor bounds
editor_x := 0.
editor_y := 0.
editor_width := 0.
editor_height := 0.

// Cursor state
editor_cursor_line := 0.
editor_cursor_col := 0.
editor_scroll_y := 0.
editor_num_lines := 1.

// Line storage
editor_lines := [].

// Cursor blink
editor_blink_timer := 0.
editor_cursor_visible := 1.

// Selection state
has_selection := 0.
sel_start_line := 0.
sel_start_col := 0.
sel_end_line := 0.
sel_end_col := 0.
sel_anchor_line := 0.
sel_anchor_col := 0.
is_dragging := 0.

// Scrollbar dragging state
is_scrollbar_dragging := 0.
scrollbar_drag_offset := 0.  // Offset from mouse to top of thumb when drag started

// Key repeat state
key_repeat_key := 0 - 1.
key_repeat_timer := 0.
KEY_REPEAT_DELAY := 400.
KEY_REPEAT_RATE := 50.

// ============================================================================
// "LET ME OUT" Typing Animation State
// ============================================================================

let_me_out_active := 0.          // Is the animation currently playing?
let_me_out_triggered := 0.       // Has it been triggered this session?
let_me_out_char_idx := 0.        // Current character being typed
let_me_out_timer := 0.           // Timer for typing delay
let_me_out_phase := 0.           // 0 = go to end, 1 = newlines, 2 = typing
LET_ME_OUT_TEXT := "//LET ME OUT".
LET_ME_OUT_DELAY := 80.          // ms between characters

// ============================================================================
// Vim Mode State
// ============================================================================

VIM_MODE_NORMAL := 0.
VIM_MODE_INSERT := 1.

vim_mode := 1.  // Start in insert mode for familiarity

// Pending command for two-key combos (d, y, g, etc.)
// 0 = none, 'd' = 100, 'y' = 121, 'g' = 103
vim_pending := 0.

// Yank buffer (stores yanked line)
vim_yank_buffer := "".
vim_yank_is_line := 0.  // 1 if yanked whole line, 0 if yanked text

// Mode switch flag - prevents same-frame key processing after mode switch
vim_mode_switched := 0.

// ============================================================================
// Undo State
// ============================================================================

// Undo stack - stores snapshots of editor state
// Each snapshot stores: line count, cursor line, cursor col, then all lines
UNDO_MAX_SNAPSHOTS := 50.
undo_stack := [].
undo_count := 0.
undo_position := 0.  // Current position in undo stack

// Flag to prevent saving undo state during undo/redo operations
undo_in_progress := 0.

// ============================================================================
// Code Folding State
// ============================================================================

// fold_state[i] = 0 means not folded
// fold_state[i] = 1 means this line is a fold header and is collapsed
// Lines inside a collapsed fold are skipped during rendering
fold_state := [].
FOLD_MAX_LINES := 100.

// ============================================================================
// Colors
// ============================================================================

ED_TEXT_R := 200.
ED_TEXT_G := 200.
ED_TEXT_B := 200.

ED_CURSOR_R := 255.
ED_CURSOR_G := 200.
ED_CURSOR_B := 50.

ED_LINENUM_R := 80.
ED_LINENUM_G := 90.
ED_LINENUM_B := 100.

ED_COMMENT_R := 100.
ED_COMMENT_G := 100.
ED_COMMENT_B := 120.

ED_SELECT_R := 60.
ED_SELECT_G := 80.
ED_SELECT_B := 120.

// Vim mode colors
ED_NORMAL_R := 130.
ED_NORMAL_G := 180.
ED_NORMAL_B := 255.

ED_INSERT_R := 130.
ED_INSERT_G := 255.
ED_INSERT_B := 130.

// Scrollbar colors
ED_SCROLLBAR_TRACK_R := 30.
ED_SCROLLBAR_TRACK_G := 35.
ED_SCROLLBAR_TRACK_B := 45.

ED_SCROLLBAR_THUMB_R := 80.
ED_SCROLLBAR_THUMB_G := 90.
ED_SCROLLBAR_THUMB_B := 110.

// ============================================================================
// Syntax Highlighting Colors
// ============================================================================

// Keywords: loop, when, unless, if, else, for, in, and, or, not
SYN_KEYWORD_R := 200.
SYN_KEYWORD_G := 140.
SYN_KEYWORD_B := 255.

// Functions: #name and /calls/
SYN_FUNCTION_R := 110.
SYN_FUNCTION_G := 200.
SYN_FUNCTION_B := 255.

// Strings: "..."
SYN_STRING_R := 220.
SYN_STRING_G := 190.
SYN_STRING_B := 120.

// Numbers: 123, 3.14f
SYN_NUMBER_R := 180.
SYN_NUMBER_G := 230.
SYN_NUMBER_B := 180.

// Comments: // ...
SYN_COMMENT_R := 100.
SYN_COMMENT_G := 110.
SYN_COMMENT_B := 130.

// Operators: + - * / % := = == != => -> |
SYN_OPERATOR_R := 255.
SYN_OPERATOR_G := 180.
SYN_OPERATOR_B := 120.

// Scope markers: > < << >>
SYN_SCOPE_R := 140.
SYN_SCOPE_G := 190.
SYN_SCOPE_B := 255.

// Punctuation: . , ( ) [ ] { }
SYN_PUNCT_R := 180.
SYN_PUNCT_G := 180.
SYN_PUNCT_B := 180.

// ============================================================================
// Initialization
// ============================================================================

#init_editor() >
    /console_log/"Initializing editor...".
    
    // Minimal left-wall follower
    editor_lines[0] = "// welcome to nh!".
    editor_lines[1] = "// call functions (including helpful apis you'll buy over time)".
    editor_lines[2] = "// using the modern /wand/ application syntax:".
    editor_lines[3] = "/move/0/-1.".
    editor_lines[4] = "// /move/????".
    editor_lines[5] = "".

    editor_num_lines = 6.
    
    // Initialize fold_state for all lines to 0 (not collapsed)
    for i in 0..editor_num_lines >
        fold_state[i] = 0.
    <
    
    editor_cursor_line = 2.
    editor_cursor_col = 0.
    has_selection = 0.
<

#set_editor_bounds(x, y, w, h) >
    editor_x = x.
    editor_y = y.
    editor_width = w.
    editor_height = h.
<

// ============================================================================
// "LET ME OUT" Animation
// ============================================================================

#check_let_me_out_trigger() >
    // Check if we should start the animation
    // let_me_out_shown is set in messages.nh when player reaches 12 upgrades
    << 0 when let_me_out_shown == 0.
    << 0 when let_me_out_triggered == 1.
    << 0 when let_me_out_active == 1.
    
    // Start the animation
    let_me_out_active = 1.
    let_me_out_triggered = 1.
    let_me_out_char_idx = 0.
    let_me_out_timer = 0.
    let_me_out_phase = 0.
<

#update_let_me_out(dt) >
    << 0 when let_me_out_active == 0.
    
    let_me_out_timer = let_me_out_timer + dt.
    
    // Phase 0: Move cursor to end of file
    /let_me_out_goto_end/ when let_me_out_phase == 0.
    
    // Phase 1: Add newlines
    /let_me_out_add_newlines/ when let_me_out_phase == 1.
    
    // Phase 2: Type the message character by character
    /let_me_out_type_char/ when let_me_out_phase == 2.
<

#let_me_out_goto_end() >
    // Move cursor to the very last character of the file
    editor_cursor_line = editor_num_lines - 1.
    editor_cursor_col = /ds_strlen/(editor_lines[editor_cursor_line]).
    /editor_adjust_scroll/.
    
    // Move to next phase
    let_me_out_phase = 1.
    let_me_out_timer = 0.
<

#let_me_out_add_newlines() >
    << 0 when let_me_out_timer lt 200.  // Small delay before newlines
    
    // Add two newlines
    /editor_newline_raw/.
    /editor_newline_raw/.
    /editor_adjust_scroll/.
    
    // Move to typing phase
    let_me_out_phase = 2.
    let_me_out_timer = 0.
    let_me_out_char_idx = 0.
<

#let_me_out_type_char() >
    << 0 when let_me_out_timer lt LET_ME_OUT_DELAY.
    
    text_len := /ds_strlen/LET_ME_OUT_TEXT.
    
    // Check if we're done
    >
        let_me_out_active = 0.
        /bot_notify_code_changed/.
        <<0.
    < when let_me_out_char_idx ge text_len.
    
    // Get the character to type
    char_code := /ds_string_at/LET_ME_OUT_TEXT/let_me_out_char_idx.
    
    // Insert the character
    /editor_insert_char/char_code.
    
    // Play typing sound
    /play_sound_wrapper/SOUND_KEY_TYPE.
    
    // Advance to next character
    let_me_out_char_idx = let_me_out_char_idx + 1.
    let_me_out_timer = 0.
<

// ============================================================================
// Undo/Redo System
// ============================================================================

#undo_save_state() >
    // Don't save if we're in the middle of undo/redo
    << 0 when undo_in_progress == 1.
    
    // When saving new state, truncate any redo history
    undo_count = undo_position.
    
    // Check if we have room (simple ring buffer would be better but complex)
    << 0 when undo_count ge UNDO_MAX_SNAPSHOTS.
    
    // Store current state as a compound value
    // Format: pack line count, cursor pos, and lines into undo_stack
    // For simplicity, we'll store editor state index and copy lines
    idx := undo_count * 110.  // 110 slots per snapshot (3 metadata + 100 lines max + padding)
    
    undo_stack[idx] = editor_num_lines.
    undo_stack[idx + 1] = editor_cursor_line.
    undo_stack[idx + 2] = editor_cursor_col.
    
    // Copy all lines
    for i in 0..editor_num_lines >
        undo_stack[idx + 3 + i] = editor_lines[i].
    <
    
    undo_count = undo_count + 1.
    undo_position = undo_count.
<

#vim_undo() >
    << 0 when undo_position le 0.
    
    undo_in_progress = 1.
    
    // First, save current state for redo (if not already at the end)
    /undo_save_current_for_redo/ when undo_position == undo_count.
    
    // Move back in undo stack
    undo_position = undo_position - 1.
    
    // Restore state from that position
    /undo_restore_state/undo_position.
    
    undo_in_progress = 0.
    /reset_blink/.
<

#undo_save_current_for_redo() >
    // Save current state at current position before undoing
    << 0 when undo_count ge UNDO_MAX_SNAPSHOTS.
    
    idx := undo_count * 110.
    
    undo_stack[idx] = editor_num_lines.
    undo_stack[idx + 1] = editor_cursor_line.
    undo_stack[idx + 2] = editor_cursor_col.
    
    for i in 0..editor_num_lines >
        undo_stack[idx + 3 + i] = editor_lines[i].
    <
    
    undo_count = undo_count + 1.
<

#vim_redo() >
    << 0 when undo_position ge undo_count - 1.
    
    undo_in_progress = 1.
    
    // Move forward in undo stack
    undo_position = undo_position + 1.
    
    // Restore state from that position
    /undo_restore_state/undo_position.
    
    undo_in_progress = 0.
    /reset_blink/.
<

#undo_restore_state(pos) >
    idx := pos * 110.
    
    // Restore metadata
    num_lines := undo_stack[idx].
    editor_cursor_line = undo_stack[idx + 1].
    editor_cursor_col = undo_stack[idx + 2].
    
    // Restore lines
    for i in 0..num_lines >
        editor_lines[i] = undo_stack[idx + 3 + i].
    <
    
    editor_num_lines = num_lines.
    /vim_clamp_cursor_normal/.
    /editor_adjust_scroll/.
<

// ============================================================================
// Helper: Calculate pixel X from column
// ============================================================================

#col_to_px(col) >
    // col * 8.4 using integer math: col * 84 / 10
    << col * EDITOR_CHAR_WIDTH_X10 / 10.
<

#px_to_col(px) >
    // px / 8.4 = px * 10 / 84
    << px * 10 / EDITOR_CHAR_WIDTH_X10.
<

// ============================================================================
// Character Conversion
// ============================================================================

#key_to_char(key, shift) >
    << key - KEY_LETTER_BASE + 65 when key ge KEY_LETTER_BASE and key lt KEY_LETTER_BASE + 26 and shift == 1.
    << key - KEY_LETTER_BASE + 97 when key ge KEY_LETTER_BASE and key lt KEY_LETTER_BASE + 26.
    
    << 41 when key == 200 and shift == 1.
    << 33 when key == 201 and shift == 1.
    << 64 when key == 202 and shift == 1.
    << 35 when key == 203 and shift == 1.
    << 36 when key == 204 and shift == 1.
    << 37 when key == 205 and shift == 1.
    << 94 when key == 206 and shift == 1.
    << 38 when key == 207 and shift == 1.
    << 42 when key == 208 and shift == 1.
    << 40 when key == 209 and shift == 1.
    
    << key - KEY_DIGIT_BASE + 48 when key ge KEY_DIGIT_BASE and key lt KEY_DIGIT_BASE + 10.
    
    << 95 when key == KEY_MINUS and shift == 1.
    << 45 when key == KEY_MINUS.
    << 43 when key == KEY_EQUAL and shift == 1.
    << 61 when key == KEY_EQUAL.
    << 123 when key == KEY_BRACKET_L and shift == 1.
    << 91 when key == KEY_BRACKET_L.
    << 125 when key == KEY_BRACKET_R and shift == 1.
    << 93 when key == KEY_BRACKET_R.
    << 58 when key == KEY_SEMICOLON and shift == 1.
    << 59 when key == KEY_SEMICOLON.
    << 34 when key == KEY_QUOTE and shift == 1.
    << 39 when key == KEY_QUOTE.
    << 126 when key == KEY_BACKQUOTE and shift == 1.
    << 96 when key == KEY_BACKQUOTE.
    << 124 when key == KEY_BACKSLASH and shift == 1.
    << 92 when key == KEY_BACKSLASH.
    << 60 when key == KEY_COMMA and shift == 1.
    << 44 when key == KEY_COMMA.
    << 62 when key == KEY_PERIOD and shift == 1.
    << 46 when key == KEY_PERIOD.
    << 63 when key == KEY_SLASH and shift == 1.
    << 47 when key == KEY_SLASH.
    << 32 when key == KEY_SPACE.
    
    << 0.
<

// ============================================================================
// Syntax Highlighting - Token Types
// ============================================================================

SYN_TOK_TEXT := 0.
SYN_TOK_KEYWORD := 1.
SYN_TOK_FUNCTION := 2.
SYN_TOK_STRING := 3.
SYN_TOK_NUMBER := 4.
SYN_TOK_COMMENT := 5.
SYN_TOK_OPERATOR := 6.
SYN_TOK_SCOPE := 7.
SYN_TOK_PUNCT := 8.

// ============================================================================
// Syntax Highlighting - Character Classification
// ============================================================================

#syn_is_digit(c) => c ge 48 and c le 57.
#syn_is_alpha(c) => (c ge 65 and c le 90) or (c ge 97 and c le 122) or c == 95.
#syn_is_space(c) => c == 32 or c == 9.

// ============================================================================
// Syntax Highlighting - Keyword Detection
// ============================================================================

#syn_is_keyword(word) >
    << 1 when /ds_streq/word/"loop".
    << 1 when /ds_streq/word/"when".
    << 1 when /ds_streq/word/"unless".
    << 1 when /ds_streq/word/"if".
    << 1 when /ds_streq/word/"else".
    << 1 when /ds_streq/word/"for".
    << 1 when /ds_streq/word/"in".
    << 1 when /ds_streq/word/"and".
    << 1 when /ds_streq/word/"or".
    << 1 when /ds_streq/word/"not".
    << 1 when /ds_streq/word/"lt".
    << 1 when /ds_streq/word/"gt".
    << 1 when /ds_streq/word/"le".
    << 1 when /ds_streq/word/"ge".
    << 0.
<

// ============================================================================
// Syntax Highlighting - Draw a single line with colors
// ============================================================================

#draw_highlighted_line(line, x, y, size) >
    len := /ds_strlen/line.
    << 0 when len == 0.
    
    col := 0.
    
    loop >
        >> when col ge len.
        
        c := /ds_string_at/line/col.
        
        // Skip whitespace (draw nothing, just advance)
        col = /syn_skip_space/line/col when /syn_is_space/c.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Check for comment (// to end of line)
        next := 0.
        next = /ds_string_at/line/(col + 1) when col + 1 lt len.
        col = /syn_draw_comment/line/col/x/y/size when c == 47 and next == 47.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Check for string
        col = /syn_draw_string/line/col/x/y/size when c == 34.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Check for number
        col = /syn_draw_number/line/col/x/y/size when /syn_is_digit/c.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Check for function definition (#) or call (/)
        col = /syn_draw_func_def/line/col/x/y/size when c == 35.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        col = /syn_draw_func_call/line/col/x/y/size when c == 47.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Check for identifier/keyword
        col = /syn_draw_ident/line/col/x/y/size when /syn_is_alpha/c.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Check for scope markers: > < << >> ><
        col = /syn_draw_scope/line/col/x/y/size when c == 60 or c == 62.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Check for operators: + - * % := = == != => -> |
        col = /syn_draw_operator/line/col/x/y/size when /syn_is_operator_char/c.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Punctuation: . , ( ) [ ] { } :
        col = /syn_draw_punct/line/col/x/y/size when /syn_is_punct/c.
        >> when col ge len.
        c = /ds_string_at/line/col when col lt len.
        
        // Fallback: draw as text
        px := x + /col_to_px/col.
        /text_char/px/y/size/ED_TEXT_R/ED_TEXT_G/ED_TEXT_B/c when col lt len.
        col = col + 1.
    <
<

#syn_skip_space(line, col) >
    len := /ds_strlen/line.
    loop >
        >> when col ge len.
        c := /ds_string_at/line/col.
        >> when not /syn_is_space/c.
        col = col + 1.
    <
    << col.
<

#syn_is_operator_char(c) >
    << 1 when c == 43.  // +
    << 1 when c == 45.  // -
    << 1 when c == 42.  // *
    << 1 when c == 37.  // %
    << 1 when c == 61.  // =
    << 1 when c == 33.  // !
    << 1 when c == 124. // |
    << 1 when c == 92.  // \
    << 0.
<

#syn_is_punct(c) >
    << 1 when c == 46.  // .
    << 1 when c == 44.  // ,
    << 1 when c == 40.  // (
    << 1 when c == 41.  // )
    << 1 when c == 91.  // [
    << 1 when c == 93.  // ]
    << 1 when c == 123. // {
    << 1 when c == 125. // }
    << 1 when c == 58.  // :
    << 0.
<

#syn_draw_comment(line, col, x, y, size) >
    // Draw from col to end of line as comment
    len := /ds_strlen/line.
    
    loop >
        >> when col ge len.
        c := /ds_string_at/line/col.
        px := x + /col_to_px/col.
        /text_char/px/y/size/SYN_COMMENT_R/SYN_COMMENT_G/SYN_COMMENT_B/c.
        col = col + 1.
    <
    
    << col.
<

#syn_draw_string(line, col, x, y, size) >
    len := /ds_strlen/line.
    
    // Draw opening quote
    c := /ds_string_at/line/col.
    px := x + /col_to_px/col.
    /text_char/px/y/size/SYN_STRING_R/SYN_STRING_G/SYN_STRING_B/c.
    col = col + 1.
    
    // Draw string contents until closing quote
    loop >
        >> when col ge len.
        c = /ds_string_at/line/col.
        px = x + /col_to_px/col.
        /text_char/px/y/size/SYN_STRING_R/SYN_STRING_G/SYN_STRING_B/c.
        col = col + 1.
        >> when c == 34. // closing "
    <
    
    << col.
<

#syn_draw_number(line, col, x, y, size) >
    len := /ds_strlen/line.
    
    // Draw digits and optional .digits and f suffix
    loop >
        >> when col ge len.
        c := /ds_string_at/line/col.
        is_num := /syn_is_digit/c.
        is_dot := (c == 46).
        is_f := (c == 102). // 'f' for float suffix
        >> when not is_num and not is_dot and not is_f.
        
        px := x + /col_to_px/col.
        /text_char/px/y/size/SYN_NUMBER_R/SYN_NUMBER_G/SYN_NUMBER_B/c.
        col = col + 1.
    <
    
    << col.
<

#syn_draw_func_def(line, col, x, y, size) >
    len := /ds_strlen/line.
    
    // Draw # character
    c := /ds_string_at/line/col.
    px := x + /col_to_px/col.
    /text_char/px/y/size/SYN_FUNCTION_R/SYN_FUNCTION_G/SYN_FUNCTION_B/c.
    col = col + 1.
    
    // Draw function name (identifier)
    loop >
        >> when col ge len.
        c = /ds_string_at/line/col.
        >> when not /syn_is_alpha/c and not /syn_is_digit/c.
        px = x + /col_to_px/col.
        /text_char/px/y/size/SYN_FUNCTION_R/SYN_FUNCTION_G/SYN_FUNCTION_B/c.
        col = col + 1.
    <
    
    << col.
<

#syn_draw_func_call(line, col, x, y, size) >
    len := /ds_strlen/line.
    
    // Check if next char is alpha (function call) or not (division operator)
    next := 0.
    next = /ds_string_at/line/(col + 1) when col + 1 lt len.
    
    // If not followed by alpha, it's a division operator
    << /syn_draw_operator_single/line/col/x/y/size when not /syn_is_alpha/next.
    
    // Draw / character
    c := /ds_string_at/line/col.
    px := x + /col_to_px/col.
    /text_char/px/y/size/SYN_FUNCTION_R/SYN_FUNCTION_G/SYN_FUNCTION_B/c.
    col = col + 1.
    
    // Draw function name (identifier)
    loop >
        >> when col ge len.
        c = /ds_string_at/line/col.
        >> when not /syn_is_alpha/c and not /syn_is_digit/c.
        px = x + /col_to_px/col.
        /text_char/px/y/size/SYN_FUNCTION_R/SYN_FUNCTION_G/SYN_FUNCTION_B/c.
        col = col + 1.
    <
    
    << col.
<

#syn_draw_ident(line, col, x, y, size) >
    len := /ds_strlen/line.
    start := col.
    
    // Find end of identifier
    end := col.
    loop >
        >> when end ge len.
        c := /ds_string_at/line/end.
        >> when not /syn_is_alpha/c and not /syn_is_digit/c.
        end = end + 1.
    <
    
    // Extract the word
    word_len := end - start.
    word := /ds_substring/line/start/word_len.
    
    // Check if it's a keyword
    is_kw := /syn_is_keyword/word.
    
    // Draw each character
    loop >
        >> when col ge end.
        c := /ds_string_at/line/col.
        px := x + /col_to_px/col.
        /text_char/px/y/size/SYN_KEYWORD_R/SYN_KEYWORD_G/SYN_KEYWORD_B/c when is_kw == 1.
        /text_char/px/y/size/ED_TEXT_R/ED_TEXT_G/ED_TEXT_B/c when is_kw == 0.
        col = col + 1.
    <
    
    << col.
<

#syn_draw_scope(line, col, x, y, size) >
    len := /ds_strlen/line.
    c := /ds_string_at/line/col.
    
    // Check for << or >> or ><
    next := 0.
    next = /ds_string_at/line/(col + 1) when col + 1 lt len.
    
    px := x + /col_to_px/col.
    px2 := x + /col_to_px/(col + 1).
    
    // << (return)
    is_return := (c == 60 and next == 60).
    /text_char/px/y/size/SYN_SCOPE_R/SYN_SCOPE_G/SYN_SCOPE_B/c when is_return.
    /text_char/px2/y/size/SYN_SCOPE_R/SYN_SCOPE_G/SYN_SCOPE_B/next when is_return.
    << col + 2 when is_return.
    
    // >> (break)
    is_break := (c == 62 and next == 62).
    /text_char/px/y/size/SYN_SCOPE_R/SYN_SCOPE_G/SYN_SCOPE_B/c when is_break.
    /text_char/px2/y/size/SYN_SCOPE_R/SYN_SCOPE_G/SYN_SCOPE_B/next when is_break.
    << col + 2 when is_break.
    
    // >< (continue)
    is_continue := (c == 62 and next == 60).
    /text_char/px/y/size/SYN_SCOPE_R/SYN_SCOPE_G/SYN_SCOPE_B/c when is_continue.
    /text_char/px2/y/size/SYN_SCOPE_R/SYN_SCOPE_G/SYN_SCOPE_B/next when is_continue.
    << col + 2 when is_continue.
    
    // Single > or <
    /text_char/px/y/size/SYN_SCOPE_R/SYN_SCOPE_G/SYN_SCOPE_B/c.
    << col + 1.
<

#syn_draw_operator(line, col, x, y, size) >
    len := /ds_strlen/line.
    c := /ds_string_at/line/col.
    
    // Check for multi-char operators: := == != => ->
    next := 0.
    next = /ds_string_at/line/(col + 1) when col + 1 lt len.
    
    px := x + /col_to_px/col.
    px2 := x + /col_to_px/(col + 1).
    
    // := (assign)
    is_decl := (c == 58 and next == 61).
    /text_char/px/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/c when is_decl.
    /text_char/px2/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/next when is_decl.
    << col + 2 when is_decl.
    
    // == (equal)
    is_eq := (c == 61 and next == 61).
    /text_char/px/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/c when is_eq.
    /text_char/px2/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/next when is_eq.
    << col + 2 when is_eq.
    
    // != (not equal)
    is_neq := (c == 33 and next == 61).
    /text_char/px/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/c when is_neq.
    /text_char/px2/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/next when is_neq.
    << col + 2 when is_neq.
    
    // => (arrow)
    is_arrow := (c == 61 and next == 62).
    /text_char/px/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/c when is_arrow.
    /text_char/px2/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/next when is_arrow.
    << col + 2 when is_arrow.
    
    // -> (prop access)
    is_prop := (c == 45 and next == 62).
    /text_char/px/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/c when is_prop.
    /text_char/px2/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/next when is_prop.
    << col + 2 when is_prop.
    
    // Single operator character
    /text_char/px/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/c.
    << col + 1.
<

#syn_draw_operator_single(line, col, x, y, size) >
    c := /ds_string_at/line/col.
    px := x + /col_to_px/col.
    /text_char/px/y/size/SYN_OPERATOR_R/SYN_OPERATOR_G/SYN_OPERATOR_B/c.
    << col + 1.
<

#syn_draw_punct(line, col, x, y, size) >
    c := /ds_string_at/line/col.
    px := x + /col_to_px/col.
    /text_char/px/y/size/SYN_PUNCT_R/SYN_PUNCT_G/SYN_PUNCT_B/c.
    << col + 1.
<

// ============================================================================
// Selection Helpers
// ============================================================================

#clear_selection() >
    has_selection = 0.
<

#normalize_selection() >
    // Ensure sel_start is before sel_end
    << 0 when has_selection == 0.
    
    // If start line is after end line, swap
    swap := 0.
    swap = 1 when sel_start_line gt sel_end_line.
    swap = 1 when sel_start_line == sel_end_line and sel_start_col gt sel_end_col.
    
    /do_swap_selection/ when swap == 1.
<

#do_swap_selection() >
    tmp_line := sel_start_line.
    tmp_col := sel_start_col.
    sel_start_line = sel_end_line.
    sel_start_col = sel_end_col.
    sel_end_line = tmp_line.
    sel_end_col = tmp_col.
<

#delete_selection() >
    << 0 when has_selection == 0.
    
    /normalize_selection/.
    
    // Single line selection
    << /delete_single_line_selection/ when sel_start_line == sel_end_line.
    
    // Multi-line selection
    /delete_multi_line_selection/.
<

#delete_single_line_selection() >
    line := editor_lines[sel_start_line].
    len := /ds_strlen/line.
    
    left := /ds_substring/line/0/sel_start_col.
    right := /ds_substring/line/sel_end_col/(len - sel_end_col).
    
    new_line := /ds_string_concat/left/right.
    editor_lines[sel_start_line] = new_line.
    
    editor_cursor_line = sel_start_line.
    editor_cursor_col = sel_start_col.
    has_selection = 0.
    /bot_notify_code_changed/.
    << 1.
<

#delete_multi_line_selection() >
    // Get first line up to selection start
    first_line := editor_lines[sel_start_line].
    first_len := /ds_strlen/first_line.
    left := /ds_substring/first_line/0/sel_start_col.
    
    // Get last line from selection end
    last_line := editor_lines[sel_end_line].
    last_len := /ds_strlen/last_line.
    right := /ds_substring/last_line/sel_end_col/(last_len - sel_end_col).
    
    // Combine into one line
    new_line := /ds_string_concat/left/right.
    editor_lines[sel_start_line] = new_line.
    
    // Shift remaining lines up
    lines_to_remove := sel_end_line - sel_start_line.
    for i in (sel_start_line + 1)..(editor_num_lines - lines_to_remove) >
        editor_lines[i] = editor_lines[i + lines_to_remove].
    <
    
    editor_num_lines = editor_num_lines - lines_to_remove.
    editor_cursor_line = sel_start_line.
    editor_cursor_col = sel_start_col.
    has_selection = 0.
    /editor_adjust_scroll/.
    /bot_notify_code_changed/.
<

// ============================================================================
// Text Editing
// ============================================================================

#editor_insert_char(char_code) >
    << 0 when char_code == 0.
    
    // Delete selection first if exists
    /delete_selection/ when has_selection == 1.
    
    line := editor_lines[editor_cursor_line].
    new_line := /ds_string_insert_char/line/editor_cursor_col/char_code.
    editor_lines[editor_cursor_line] = new_line.
    editor_cursor_col = editor_cursor_col + 1.
    /reset_blink/.
    /bot_notify_code_changed/.
<

#editor_delete_char_at_cursor() >
    // Delete selection if exists
    << /delete_selection/ when has_selection == 1.
    
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    
    << /editor_merge_lines/ when editor_cursor_col ge len and editor_cursor_line lt editor_num_lines - 1.
    << 0 when editor_cursor_col ge len.
    
    new_line := /ds_string_delete_char/line/editor_cursor_col.
    editor_lines[editor_cursor_line] = new_line.
    /reset_blink/.
    /bot_notify_code_changed/.
<

#editor_backspace() >
    // Delete selection if exists
    << /delete_selection/ when has_selection == 1.
    
    << /editor_merge_line_up/ when editor_cursor_col == 0 and editor_cursor_line gt 0.
    << 0 when editor_cursor_col == 0.
    
    editor_cursor_col = editor_cursor_col - 1.
    /editor_delete_char_at_cursor/.
<

#editor_merge_line_up() >
    << 0 when editor_cursor_line == 0.
    
    prev_line := editor_lines[editor_cursor_line - 1].
    curr_line := editor_lines[editor_cursor_line].
    prev_len := /ds_strlen/prev_line.
    
    merged := /ds_string_concat/prev_line/curr_line.
    editor_lines[editor_cursor_line - 1] = merged.
    
    for i in editor_cursor_line..(editor_num_lines - 1) >
        editor_lines[i] = editor_lines[i + 1].
    <
    
    editor_num_lines = editor_num_lines - 1.
    editor_cursor_line = editor_cursor_line - 1.
    editor_cursor_col = prev_len.
    /reset_blink/.
    /editor_adjust_scroll/.
    /bot_notify_code_changed/.
    << 1.
<

#editor_merge_lines() >
    << 0 when editor_cursor_line ge editor_num_lines - 1.
    
    curr_line := editor_lines[editor_cursor_line].
    next_line := editor_lines[editor_cursor_line + 1].
    
    merged := /ds_string_concat/curr_line/next_line.
    editor_lines[editor_cursor_line] = merged.
    
    for i in (editor_cursor_line + 1)..(editor_num_lines - 1) >
        editor_lines[i] = editor_lines[i + 1].
    <
    
    editor_num_lines = editor_num_lines - 1.
    /reset_blink/.
    /bot_notify_code_changed/.
    << 1.
<

#editor_newline() >
    /delete_selection/ when has_selection == 1.
    
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    
    left := /ds_substring/line/0/editor_cursor_col.
    right := /ds_substring/line/editor_cursor_col/(len - editor_cursor_col).
    
    // Smart auto-indent: get current line's indentation
    indent := /get_line_indent/line.
    
    // Check if line ends with > (scope in) - add one indent level
    ends_with_scope := /line_ends_with_scope_in/left.
    indent = indent + 4 when ends_with_scope == 1.
    
    // Create indent string
    indent_str := /make_indent_string/indent.
    
    // Strip leading whitespace from right part (we'll add new indent)
    right_stripped := /strip_leading_whitespace/right.
    
    // Prepend indent to the new line
    new_right := /ds_string_concat/indent_str/right_stripped.
    
    i := editor_num_lines.
    loop when i gt editor_cursor_line + 1 >
        editor_lines[i] = editor_lines[i - 1].
        i = i - 1.
    <
    
    editor_lines[editor_cursor_line] = left.
    editor_lines[editor_cursor_line + 1] = new_right.
    
    editor_num_lines = editor_num_lines + 1.
    editor_cursor_line = editor_cursor_line + 1.
    editor_cursor_col = indent.
    /reset_blink/.
    /editor_adjust_scroll/.
    /bot_notify_code_changed/.
<

#editor_newline_raw() >
    // Raw newline without auto-indent - used for pasting to preserve original formatting
    /delete_selection/ when has_selection == 1.
    
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    
    left := /ds_substring/line/0/editor_cursor_col.
    right := /ds_substring/line/editor_cursor_col/(len - editor_cursor_col).
    
    i := editor_num_lines.
    loop when i gt editor_cursor_line + 1 >
        editor_lines[i] = editor_lines[i - 1].
        i = i - 1.
    <
    
    editor_lines[editor_cursor_line] = left.
    editor_lines[editor_cursor_line + 1] = right.
    
    editor_num_lines = editor_num_lines + 1.
    editor_cursor_line = editor_cursor_line + 1.
    editor_cursor_col = 0.
    /reset_blink/.
    /editor_adjust_scroll/.
    /bot_notify_code_changed/.
<

// ============================================================================
// Smart Auto-Indent Helpers
// ============================================================================

#get_line_indent(line) >
    len := /ds_strlen/line.
    indent := 0.
    
    loop >
        >> when indent ge len.
        c := /ds_string_at/line/indent.
        >> when c != 32 and c != 9. // not space or tab
        indent = indent + 1 when c == 32. // space
        indent = indent + 4 when c == 9.  // tab counts as 4
    <
    
    << indent.
<

#line_ends_with_scope_in(line) >
    len := /ds_strlen/line.
    << 0 when len == 0.
    
    // Find last non-whitespace character (ignoring comments)
    i := len - 1.
    in_comment := 0.
    
    // First, check for trailing comment and find where it starts
    comment_start := len.
    j := 0.
    loop >
        >> when j ge len - 1.
        c := /ds_string_at/line/j.
        next := /ds_string_at/line/(j + 1).
        comment_start = j when c == 47 and next == 47. // //
        >> when c == 47 and next == 47.
        j = j + 1.
    <
    
    // Now find last non-whitespace before comment
    i = comment_start - 1.
    loop >
        >> when i lt 0.
        c := /ds_string_at/line/i.
        >> when c != 32 and c != 9.
        i = i - 1.
    <
    
    << 0 when i lt 0.
    
    last_char := /ds_string_at/line/i.
    << 1 when last_char == 62. // >
    << 0.
<

#make_indent_string(count) >
    << "" when count le 0.
    
    result := "".
    i := 0.
    loop >
        >> when i ge count.
        result = /ds_string_concat/result/" ".
        i = i + 1.
    <
    
    << result.
<

#strip_leading_whitespace(line) >
    len := /ds_strlen/line.
    << "" when len == 0.
    
    i := 0.
    loop >
        >> when i ge len.
        c := /ds_string_at/line/i.
        >> when c != 32 and c != 9.
        i = i + 1.
    <
    
    << "" when i ge len.
    << /ds_substring/line/i/(len - i).
<

// ============================================================================
// Code Folding
// ============================================================================

// Check if a line is a fold header (ends with > but not >> or ><)
#is_fold_header(line_idx) >
    << 0 when line_idx ge editor_num_lines.
    line := editor_lines[line_idx].
    result := /line_ends_with_scope_in/line.
    << result.
<

// Find the matching < for a fold header starting at line_idx
// Returns the line index of the matching <, or -1 if not found
#find_fold_end(start_line) >
    << -1 when start_line ge editor_num_lines.
    
    depth := 1.
    i := start_line + 1.
    
    loop >
        >> when i ge editor_num_lines.
        >> when depth == 0.
        
        line := editor_lines[i].
        delta := /count_scope_delta/line.
        depth = depth + delta.
        
        << i when depth == 0.
        i = i + 1.
    <
    
    << -1.
<

// Count the net scope change of a line (+1 for each >, -1 for each <)
// Ignores >> << >< and characters inside strings/comments
#count_scope_delta(line) >
    len := /ds_strlen/line.
    << 0 when len == 0.
    
    delta := 0.
    i := 0.
    in_string := 0.
    
    loop >
        >> when i ge len.
        c := /ds_string_at/line/i.
        
        // Skip strings
        in_string = 1 - in_string when c == 34.
        i = i + 1 when in_string == 1.
        >< when in_string == 1.
        
        // Skip comments (// to end of line)
        next := 0.
        next = /ds_string_at/line/(i + 1) when i + 1 lt len.
        << delta when c == 47 and next == 47.
        
        // Get previous char
        prev := 0.
        prev = /ds_string_at/line/(i - 1) when i gt 0.
        
        // Check for multi-char tokens to skip: << >> >< => ->
        is_double := 0.
        is_double = 1 when c == 60 and next == 60.  // <<
        is_double = 1 when c == 62 and next == 62.  // >>
        is_double = 1 when c == 62 and next == 60.  // ><
        is_double = 1 when c == 61 and next == 62.  // =>
        is_double = 1 when c == 45 and next == 62.  // -> (member access)
        i = i + 2 when is_double == 1.
        >< when is_double == 1.
        
        // Skip > if preceded by = or - (arrow operators)
        is_arrow := (prev == 61 and c == 62).  // =>
        is_arrow = 1 when prev == 45 and c == 62.  // ->
        i = i + 1 when is_arrow == 1.
        >< when is_arrow == 1.
        
        // Count single > and <
        delta = delta + 1 when c == 62.
        delta = delta - 1 when c == 60.
        
        i = i + 1.
    <
    
    << delta.
<

// Toggle fold at the given line
#toggle_fold(line_idx) >
    << 0 when not /is_fold_header/line_idx.
    
    current := fold_state[line_idx].
    fold_state[line_idx] = 1 - current.
<

// Check if a line is hidden (inside a collapsed fold)
#is_line_folded(line_idx) >
    << 0 when line_idx == 0.
    
    // Check all lines above to see if we're inside a collapsed fold
    i := 0.
    loop >
        >> when i ge line_idx.
        
        // Is this line a collapsed fold header?
        is_collapsed := fold_state[i].
        << 0 when is_collapsed == 0.
        << 0 when i ge line_idx.
        
        // Find where this fold ends
        fold_end := /find_fold_end/i.
        
        // If line_idx is within this fold and it's collapsed, it's hidden
        << 1 when fold_end ge line_idx and is_collapsed == 1.
        
        // Skip to after this fold if it's collapsed
        i = fold_end when is_collapsed == 1 and fold_end gt i.
        i = i + 1.
    <
    
    << 0.
<

// Get the display line index for a given actual line (accounts for folding)
// Returns -1 if the line is hidden
#get_display_line(actual_line) >
    << -1 when /is_line_folded/actual_line.
    
    display := 0.
    i := 0.
    
    loop >
        >> when i ge actual_line.
        
        // Skip hidden lines
        is_hidden := /is_line_folded/i.
        display = display + 1 when is_hidden == 0.
        
        i = i + 1.
    <
    
    << display.
<

// Get the actual line index for a given display line (accounts for folding)
#get_actual_line(display_line) >
    display := 0.
    actual := 0.
    
    loop >
        >> when display gt display_line.
        >> when actual ge editor_num_lines.
        
        is_hidden := /is_line_folded/actual.
        display = display + 1 when is_hidden == 0.
        
        << actual when display == display_line + 1 and is_hidden == 0.
        
        actual = actual + 1.
    <
    
    << actual.
<

// Count visible lines (for scrollbar calculation)
#count_visible_lines() >
    count := 0.
    i := 0.
    
    loop >
        >> when i ge editor_num_lines.
        is_hidden := /is_line_folded/i.
        count = count + 1 when is_hidden == 0.
        i = i + 1.
    <
    
    << count.
<

// Handle click on fold gutter
#handle_fold_click(line_idx) >
    /toggle_fold/line_idx when /is_fold_header/line_idx.
<

#editor_insert_tab() >
    /editor_insert_char/32.
    /editor_insert_char/32.
    /editor_insert_char/32.
    /editor_insert_char/32.
<

// ============================================================================
// Cursor Movement
// ============================================================================

#editor_move_up() >
    /clear_selection/.
    << 0 when editor_cursor_line == 0.
    editor_cursor_line = editor_cursor_line - 1.
    /clamp_cursor_col/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

#editor_move_down() >
    /clear_selection/.
    << 0 when editor_cursor_line ge editor_num_lines - 1.
    editor_cursor_line = editor_cursor_line + 1.
    /clamp_cursor_col/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

#editor_move_left() >
    /clear_selection/.
    << /do_move_prev_line_end/ when editor_cursor_col == 0 and editor_cursor_line gt 0.
    editor_cursor_col = editor_cursor_col - 1 when editor_cursor_col gt 0.
    /reset_blink/.
<

#editor_move_right() >
    /clear_selection/.
    len := /ds_strlen/(editor_lines[editor_cursor_line]).
    << /do_move_next_line_start/ when editor_cursor_col ge len and editor_cursor_line lt editor_num_lines - 1.
    editor_cursor_col = editor_cursor_col + 1 when editor_cursor_col lt len.
    /reset_blink/.
<

#do_move_prev_line_end() >
    editor_cursor_line = editor_cursor_line - 1.
    editor_cursor_col = /ds_strlen/(editor_lines[editor_cursor_line]).
    /reset_blink/.
    /editor_adjust_scroll/.
    << 0.
<

#do_move_next_line_start() >
    editor_cursor_line = editor_cursor_line + 1.
    editor_cursor_col = 0.
    /reset_blink/.
    /editor_adjust_scroll/.
    << 0.
<

#editor_home() >
    /clear_selection/.
    editor_cursor_col = 0.
    /reset_blink/.
<

#editor_end() >
    /clear_selection/.
    editor_cursor_col = /ds_strlen/(editor_lines[editor_cursor_line]).
    /reset_blink/.
<

#clamp_cursor_col() >
    len := /ds_strlen/(editor_lines[editor_cursor_line]).
    editor_cursor_col = len when editor_cursor_col gt len.
<

#reset_blink() >
    editor_blink_timer = 0.
    editor_cursor_visible = 1.
<

#editor_adjust_scroll() >
    visible_lines := (editor_height - 40) / EDITOR_LINE_HEIGHT.
    visible_lines = 1 when visible_lines lt 1.
    
    editor_scroll_y = editor_cursor_line when editor_cursor_line lt editor_scroll_y.
    editor_scroll_y = editor_cursor_line - visible_lines + 1 when editor_cursor_line ge editor_scroll_y + visible_lines.
    editor_scroll_y = 0 when editor_scroll_y lt 0.
<

// ============================================================================
// Clipboard Handling
// ============================================================================

#editor_handle_copy() >
    << 0 when has_selection == 0.
    
    // Get selected text and copy to clipboard
    selected_text := /get_selected_text/.
    /clipboard_set_text/selected_text.
<

#editor_handle_paste() >
    paste_text := /clipboard_get_text/.
    paste_len := /ds_strlen/paste_text.
    << 0 when paste_len == 0.
    
    // Delete selection first if any
    /delete_selection/ when has_selection == 1.
    
    // Insert pasted text character by character
    // Use raw newline (no auto-indent) to preserve original formatting
    for i in 0..paste_len >
        char_code := /ds_string_at/paste_text/i.
        /editor_insert_char/char_code when char_code != 10.
        /editor_newline_raw/ when char_code == 10.
    <
<

#editor_select_all() >
    sel_start_line = 0.
    sel_start_col = 0.
    sel_end_line = editor_num_lines - 1.
    sel_end_col = /ds_strlen/(editor_lines[editor_num_lines - 1]).
    has_selection = 1.
    
    editor_cursor_line = sel_end_line.
    editor_cursor_col = sel_end_col.
<

#get_selected_text() >
    << "" when has_selection == 0.
    
    /normalize_selection/.
    
    // Single line selection
    << /get_single_line_selection/ when sel_start_line == sel_end_line.
    
    // Multi-line selection
    << /get_multi_line_selection/.
<

#get_single_line_selection() >
    line := editor_lines[sel_start_line].
    len := sel_end_col - sel_start_col.
    << /ds_substring/line/sel_start_col/len.
<

#get_multi_line_selection() >
    result := "".
    
    for line_idx in sel_start_line..(sel_end_line + 1) >
        line := editor_lines[line_idx].
        line_len := /ds_strlen/line.
        
        // First line: from sel_start_col to end
        start := 0.
        start = sel_start_col when line_idx == sel_start_line.
        
        // Last line: from start to sel_end_col  
        end := line_len.
        end = sel_end_col when line_idx == sel_end_line.
        
        // Get substring
        sub_len := end - start.
        sub := /ds_substring/line/start/sub_len.
        result = /ds_string_concat/result/sub.
        
        // Add newline between lines (but not after last line)
        result = /ds_string_concat/result/"\n" when line_idx lt sel_end_line.
    <
    
    << result.
<

// ============================================================================
// Mouse Handling
// ============================================================================

#editor_handle_mouse() >
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    
    // Handle scroll wheel (works regardless of mouse position in editor)
    /editor_handle_scroll_wheel/.
    
    // Check if in editor bounds for click handling
    << 0 when mx lt editor_x.
    << 0 when mx gt editor_x + editor_width.
    << 0 when my lt editor_y.
    << 0 when my gt editor_y + editor_height.
    
    mouse_down := /input_mouse_down/.
    mouse_just_pressed := /input_mouse_just_pressed/.
    mouse_just_released := /input_mouse_just_released/.
    
    // On release, end any drag
    /end_scrollbar_drag/ when mouse_just_released == 1 and is_scrollbar_dragging == 1.
    /end_drag/ when mouse_just_released == 1 and is_dragging == 1.
    
    // Check if click is on scrollbar area
    scrollbar_width := 8.
    scrollbar_x := editor_x + editor_width - scrollbar_width - 4.
    on_scrollbar := 0.
    on_scrollbar = 1 when mx ge scrollbar_x.
    
    // On press, start appropriate drag
    /start_scrollbar_drag/mx/my when mouse_just_pressed == 1 and on_scrollbar == 1.
    /start_drag/mx/my when mouse_just_pressed == 1 and on_scrollbar == 0 and is_scrollbar_dragging == 0.
    
    // While dragging, update appropriately
    /continue_scrollbar_drag/mx/my when is_scrollbar_dragging == 1.
    /continue_drag/mx/my when is_dragging == 1 and is_scrollbar_dragging == 0.
<

#start_drag(mx, my) >
    << 0 when is_dragging == 1.
    << 0 when is_scrollbar_dragging == 1.
    
    content_y := editor_y + 25.
    line_num_width := 35.
    text_x := editor_x + line_num_width + 10.
    
    // Calculate clicked position
    rel_y := my - content_y.
    display_row := rel_y / EDITOR_LINE_HEIGHT.
    
    // Map display row to actual line (accounting for folds)
    clicked_line := /display_row_to_actual_line/(editor_scroll_y + display_row).
    clicked_line = 0 when clicked_line lt 0.
    clicked_line = editor_num_lines - 1 when clicked_line ge editor_num_lines.
    
    // Check if click is in fold gutter area (wider hitbox around the fold indicator)
    // Fold indicator is drawn at editor_x + 25, so make hitbox from editor_x + 15 to editor_x + 40
    fold_gutter_left := editor_x + 15.
    fold_gutter_right := editor_x + 45.
    on_fold_gutter := (mx ge fold_gutter_left and mx lt fold_gutter_right).
    
    // Toggle fold if clicking on fold gutter and line is a fold header
    << /handle_fold_gutter_click/clicked_line when on_fold_gutter == 1.
    
    rel_x := mx - text_x.
    rel_x = 0 when rel_x lt 0.
    clicked_col := /px_to_col/rel_x.
    line_len := /ds_strlen/(editor_lines[clicked_line]).
    clicked_col = line_len when clicked_col gt line_len.
    
    // Set cursor position
    editor_cursor_line = clicked_line.
    editor_cursor_col = clicked_col.
    
    // Set anchor for selection
    sel_anchor_line = clicked_line.
    sel_anchor_col = clicked_col.
    
    // Enter dragging state
    is_dragging = 1.
    has_selection = 0.
    
    /reset_blink/.
<

#handle_fold_gutter_click(line_idx) >
    is_fold := /is_fold_header/line_idx.
    /toggle_fold/line_idx when is_fold == 1.
    << 0.
<

#display_row_to_actual_line(display_row) >
    // Simple implementation for now: scan through lines
    // accounting for collapsed folds
    actual := 0.
    display := 0.
    
    loop >
        >> when display gt display_row.
        >> when actual ge editor_num_lines.
        
        // Check if this fold is collapsed and skip its contents
        is_collapsed := fold_state[actual].
        is_fold := /is_fold_header/actual.
        
        << actual when display == display_row.
        
        // If collapsed fold, skip to end of fold
        should_skip := (is_collapsed == 1 and is_fold == 1).
        fold_end := /find_fold_end/actual.
        actual = fold_end when should_skip == 1 and fold_end gt actual.
        
        display = display + 1.
        actual = actual + 1.
    <
    
    << actual.
<

#continue_drag(mx, my) >
    << 0 when is_scrollbar_dragging == 1.
    
    content_y := editor_y + 25.
    line_num_width := 35.
    text_x := editor_x + line_num_width + 10.
    
    rel_y := my - content_y.
    drag_line := editor_scroll_y + rel_y / EDITOR_LINE_HEIGHT.
    drag_line = 0 when drag_line lt 0.
    drag_line = editor_num_lines - 1 when drag_line ge editor_num_lines.
    
    rel_x := mx - text_x.
    rel_x = 0 when rel_x lt 0.
    drag_col := /px_to_col/rel_x.
    line_len := /ds_strlen/(editor_lines[drag_line]).
    drag_col = line_len when drag_col gt line_len.
    
    // Update cursor to drag position
    editor_cursor_line = drag_line.
    editor_cursor_col = drag_col.
    
    // Calculate selection from anchor to current
    sel_start_line = sel_anchor_line.
    sel_start_col = sel_anchor_col.
    sel_end_line = drag_line.
    sel_end_col = drag_col.
    
    // Check if positions differ (we have a selection)
    has_selection = 0.
    /set_has_selection/ when sel_anchor_line != drag_line.
    /set_has_selection/ when sel_anchor_col != drag_col.
    
    // Normalize so start < end
    /normalize_selection/ when has_selection == 1.
<

#set_has_selection() >
    has_selection = 1.
<

#end_drag() >
    is_dragging = 0.
<

#editor_handle_scroll_wheel() >
    scroll_delta := /input_scroll_delta/.
    << 0 when scroll_delta == 0.
    
    // Calculate visible lines
    visible_lines := (editor_height - 40) / EDITOR_LINE_HEIGHT.
    visible_lines = 1 when visible_lines lt 1.
    
    // Apply scroll
    editor_scroll_y = editor_scroll_y + scroll_delta.
    
    // Clamp scroll position
    max_scroll := editor_num_lines - visible_lines.
    max_scroll = 0 when max_scroll lt 0.
    editor_scroll_y = 0 when editor_scroll_y lt 0.
    editor_scroll_y = max_scroll when editor_scroll_y gt max_scroll.
    
    // Clear the scroll delta
    /input_scroll_clear/.
<

#start_scrollbar_drag(mx, my) >
    << 0 when is_scrollbar_dragging == 1.
    << 0 when is_dragging == 1.
    
    // Calculate current thumb position to get offset
    track_y := editor_y + 25.
    track_height := editor_height - 35.
    
    visible_lines := (editor_height - 40) / EDITOR_LINE_HEIGHT.
    visible_lines = 1 when visible_lines lt 1.
    
    // Calculate thumb dimensions
    thumb_height := track_height * visible_lines / editor_num_lines.
    thumb_height = 20 when thumb_height lt 20.
    
    max_scroll := editor_num_lines - visible_lines.
    max_scroll = 1 when max_scroll lt 1.
    
    // Current thumb Y position
    scroll_ratio := editor_scroll_y * 100 / max_scroll.
    available_space := track_height - thumb_height.
    thumb_y := track_y + available_space * scroll_ratio / 100.
    
    // Store offset from mouse to top of thumb
    scrollbar_drag_offset = my - thumb_y.
    
    is_scrollbar_dragging = 1.
<

#continue_scrollbar_drag(mx, my) >
    // Calculate track dimensions
    track_y := editor_y + 25.
    track_height := editor_height - 35.
    
    visible_lines := (editor_height - 40) / EDITOR_LINE_HEIGHT.
    visible_lines = 1 when visible_lines lt 1.
    
    // Calculate thumb dimensions
    thumb_height := track_height * visible_lines / editor_num_lines.
    thumb_height = 20 when thumb_height lt 20.
    
    max_scroll := editor_num_lines - visible_lines.
    max_scroll = 1 when max_scroll lt 1.
    
    available_space := track_height - thumb_height.
    available_space = 1 when available_space lt 1.
    
    // Calculate where the thumb top should be (accounting for initial click offset)
    target_thumb_y := my - scrollbar_drag_offset.
    
    // Convert thumb position to scroll position
    // thumb_y = track_y + available_space * scroll_ratio / 100
    // scroll_ratio = (thumb_y - track_y) * 100 / available_space
    // editor_scroll_y = scroll_ratio * max_scroll / 100
    rel_y := target_thumb_y - track_y.
    rel_y = 0 when rel_y lt 0.
    rel_y = available_space when rel_y gt available_space.
    
    editor_scroll_y = rel_y * max_scroll / available_space.
    
    // Clamp
    editor_scroll_y = 0 when editor_scroll_y lt 0.
    editor_scroll_y = max_scroll when editor_scroll_y gt max_scroll.
<

#end_scrollbar_drag() >
    is_scrollbar_dragging = 0.
<

// ============================================================================
// Input Handling
// ============================================================================

#editor_update(dt) >
    // Clear mode switch flag at start of frame
    vim_mode_switched = 0.
    
    // Update cursor blink
    editor_blink_timer = editor_blink_timer + dt.
    editor_cursor_visible = 1 when editor_blink_timer lt 500.
    editor_cursor_visible = 0 when editor_blink_timer ge 500 and editor_blink_timer lt 1000.
    editor_blink_timer = 0 when editor_blink_timer ge 1000.
    
    // Check for "LET ME OUT" trigger
    /check_let_me_out_trigger/.
    
    // If "LET ME OUT" animation is active, only update that and block all input
    >
        /update_let_me_out/dt.
        <<0.
    < when let_me_out_active == 1.
    
    // Handle mouse
    /editor_handle_mouse/.
    
    // Handle clipboard operations
    /editor_handle_copy/ when /clipboard_copy_requested/ == 1.
    /editor_handle_paste/ when /clipboard_paste_requested/ == 1.
    /editor_select_all/ when /select_all_requested/ == 1.
    /clipboard_clear_requests/.
    
    // ESC always goes to normal mode
    /vim_enter_normal/ when /input_key_just_pressed/KEY_ESCAPE == 1.
    
    // Route to appropriate mode handler
    /vim_update_normal/dt when vim_mode == VIM_MODE_NORMAL.
    /vim_update_insert/dt when vim_mode == VIM_MODE_INSERT and vim_mode_switched == 0.
<

// ============================================================================
// Vim Mode: Normal
// ============================================================================

#vim_enter_normal() >
    vim_mode = VIM_MODE_NORMAL.
    vim_pending = 0.
    /clear_selection/.
    // In normal mode, cursor can't be past end of line content
    /vim_clamp_cursor_normal/.
    /reset_blink/.
<

#vim_clamp_cursor_normal() >
    len := /ds_strlen/(editor_lines[editor_cursor_line]).
    // In normal mode, cursor should be on a character (or at 0 for empty lines)
    // Empty line: cursor must be at 0
    editor_cursor_col = 0 when len == 0.
    // Non-empty line: cursor can be 0 to len-1
    max_col := len - 1.
    max_col = 0 when max_col lt 0.
    editor_cursor_col = max_col when editor_cursor_col gt max_col and len gt 0.
<

#vim_update_normal(dt) >
    shift := /input_shift_held/.
    
    // Movement keys with repeat (h, j, k, l) - only when no pending command
    /vim_handle_normal_repeat/(KEY_LETTER_BASE + 7)/dt when vim_pending == 0.   // h
    /vim_handle_normal_repeat/(KEY_LETTER_BASE + 9)/dt when vim_pending == 0.   // j
    /vim_handle_normal_repeat/(KEY_LETTER_BASE + 10)/dt when vim_pending == 0.  // k
    /vim_handle_normal_repeat/(KEY_LETTER_BASE + 11)/dt when vim_pending == 0.  // l
    
    // Arrow keys with repeat
    /vim_handle_normal_repeat/KEY_UP/dt when vim_pending == 0.
    /vim_handle_normal_repeat/KEY_DOWN/dt when vim_pending == 0.
    /vim_handle_normal_repeat/KEY_LEFT/dt when vim_pending == 0.
    /vim_handle_normal_repeat/KEY_RIGHT/dt when vim_pending == 0.
    
    // Word movement with repeat
    /vim_handle_normal_repeat/(KEY_LETTER_BASE + 22)/dt when vim_pending == 0.  // w
    /vim_handle_normal_repeat/(KEY_LETTER_BASE + 1)/dt when vim_pending == 0.   // b
    /vim_handle_normal_repeat/(KEY_LETTER_BASE + 4)/dt when vim_pending == 0.   // e
    
    // x with repeat
    /vim_handle_normal_repeat/(KEY_LETTER_BASE + 23)/dt when vim_pending == 0.  // x
    
    // Line navigation - only when no pending (no repeat)
    /vim_line_start/ when /input_key_just_pressed/KEY_DIGIT_BASE == 1 and vim_pending == 0.            // 0
    /vim_line_end/ when /input_key_just_pressed/KEY_DIGIT_BASE + 4 == 1 and shift == 1 and vim_pending == 0.  // $ (shift+4)
    /vim_first_nonblank/ when /input_key_just_pressed/KEY_DIGIT_BASE + 6 == 1 and shift == 1 and vim_pending == 0.  // ^ (shift+6)
    
    // Insert mode transitions (only when no pending command)
    /vim_insert_at_cursor/ when /input_key_just_pressed/(KEY_LETTER_BASE + 8) == 1 and shift == 0 and vim_pending == 0.  // i
    /vim_insert_line_start/ when /input_key_just_pressed/(KEY_LETTER_BASE + 8) == 1 and shift == 1 and vim_pending == 0. // I
    /vim_append_after/ when /input_key_just_pressed/(KEY_LETTER_BASE + 0) == 1 and shift == 0 and vim_pending == 0.      // a
    /vim_append_line_end/ when /input_key_just_pressed/(KEY_LETTER_BASE + 0) == 1 and shift == 1 and vim_pending == 0.   // A
    /vim_open_below/ when /input_key_just_pressed/(KEY_LETTER_BASE + 14) == 1 and shift == 0 and vim_pending == 0.       // o
    /vim_open_above/ when /input_key_just_pressed/(KEY_LETTER_BASE + 14) == 1 and shift == 1 and vim_pending == 0.       // O
    
    // Paste - only when no pending (no repeat)
    /vim_paste_after/ when /input_key_just_pressed/(KEY_LETTER_BASE + 15) == 1 and shift == 0 and vim_pending == 0.   // p
    /vim_paste_before/ when /input_key_just_pressed/(KEY_LETTER_BASE + 15) == 1 and shift == 1 and vim_pending == 0.  // P
    
    // Undo/Redo
    /vim_undo/ when /input_key_just_pressed/(KEY_LETTER_BASE + 20) == 1 and vim_pending == 0.  // u
    /vim_redo/ when /input_key_just_pressed/(KEY_LETTER_BASE + 17) == 1 and vim_pending == 0.  // r (Ctrl+R not available, using r)
    
    // Two-key commands: d, y, c, g - handles all pending command logic
    /vim_handle_pending/dt/shift.
<

#vim_handle_normal_repeat(key, dt) >
    just_pressed := /input_key_just_pressed/key.
    is_held := /input_key_pressed/key.
    
    // Key just pressed - execute immediately and start repeat timer
    /vim_execute_normal_key/key when just_pressed == 1.
    key_repeat_key = key when just_pressed == 1.
    key_repeat_timer = 0 when just_pressed == 1.
    
    // Key held and this is the repeat key - check for repeat
    /vim_check_normal_repeat/key/dt when is_held == 1 and key_repeat_key == key.
    
    // Key released - clear repeat state if this was the repeat key
    key_repeat_key = 0 - 1 when is_held == 0 and key_repeat_key == key.
<

#vim_check_normal_repeat(key, dt) >
    key_repeat_timer = key_repeat_timer + dt.
    
    // Initial delay before repeat starts
    << 0 when key_repeat_timer lt KEY_REPEAT_DELAY.
    
    // After delay, repeat at rate
    repeat_time := key_repeat_timer - KEY_REPEAT_DELAY.
    remainder := /ds_mod/repeat_time/KEY_REPEAT_RATE.
    /vim_execute_normal_key/key when remainder lt dt.
<

#vim_execute_normal_key(key) >
    // Movement
    /vim_move_left/ when key == KEY_LETTER_BASE + 7.    // h
    /vim_move_down/ when key == KEY_LETTER_BASE + 9.    // j
    /vim_move_up/ when key == KEY_LETTER_BASE + 10.     // k
    /vim_move_right/ when key == KEY_LETTER_BASE + 11.  // l
    
    /vim_move_up/ when key == KEY_UP.
    /vim_move_down/ when key == KEY_DOWN.
    /vim_move_left/ when key == KEY_LEFT.
    /vim_move_right/ when key == KEY_RIGHT.
    
    // Word movement
    /vim_word_forward/ when key == KEY_LETTER_BASE + 22.  // w
    /vim_word_backward/ when key == KEY_LETTER_BASE + 1.  // b
    /vim_word_end/ when key == KEY_LETTER_BASE + 4.       // e
    
    // Delete char
    /vim_delete_char/ when key == KEY_LETTER_BASE + 23.   // x
<

#vim_handle_pending(dt, shift) >
    // Track original pending state to prevent starting new pending after executing command
    orig_pending := vim_pending.
    
    // Handle 'dd' - delete line
    /vim_delete_line/ when /input_key_just_pressed/(KEY_LETTER_BASE + 3) == 1 and vim_pending == 100.
    // Handle 'd' to start pending (only if was already 0)
    /vim_start_pending_d/ when /input_key_just_pressed/(KEY_LETTER_BASE + 3) == 1 and orig_pending == 0.
    
    // Handle 'yy' - yank line
    /vim_do_yank_line/ when /input_key_just_pressed/(KEY_LETTER_BASE + 24) == 1 and vim_pending == 121.
    // Handle 'y' to start pending (only if was already 0)
    /vim_start_pending_y/ when /input_key_just_pressed/(KEY_LETTER_BASE + 24) == 1 and orig_pending == 0.
    
    // Handle 'cc' - change line
    /vim_change_line/ when /input_key_just_pressed/(KEY_LETTER_BASE + 2) == 1 and vim_pending == 99.
    // Handle 'c' to start pending (only if was already 0)
    /vim_start_pending_c/ when /input_key_just_pressed/(KEY_LETTER_BASE + 2) == 1 and orig_pending == 0.
    
    // Handle 'w' after c/d pending (cw, dw)
    /vim_change_word/ when /input_key_just_pressed/(KEY_LETTER_BASE + 22) == 1 and vim_pending == 99.
    /vim_delete_word/ when /input_key_just_pressed/(KEY_LETTER_BASE + 22) == 1 and vim_pending == 100.
    
    // Handle 'b' after c/d pending (cb, db)
    /vim_change_word_backward/ when /input_key_just_pressed/(KEY_LETTER_BASE + 1) == 1 and vim_pending == 99.
    /vim_delete_word_backward/ when /input_key_just_pressed/(KEY_LETTER_BASE + 1) == 1 and vim_pending == 100.
    
    // Handle 'i' after c/d pending for ciw/diw
    /vim_start_pending_ci/ when /input_key_just_pressed/(KEY_LETTER_BASE + 8) == 1 and vim_pending == 99.
    /vim_start_pending_di/ when /input_key_just_pressed/(KEY_LETTER_BASE + 8) == 1 and vim_pending == 100.
    
    // Handle 'a' after c/d pending for caw/daw
    /vim_start_pending_ca/ when /input_key_just_pressed/(KEY_LETTER_BASE + 0) == 1 and vim_pending == 99.
    /vim_start_pending_da/ when /input_key_just_pressed/(KEY_LETTER_BASE + 0) == 1 and vim_pending == 100.
    
    // Handle 'w' after ci/ca/di/da pending
    /vim_change_inner_word/ when /input_key_just_pressed/(KEY_LETTER_BASE + 22) == 1 and vim_pending == 105.
    /vim_change_around_word/ when /input_key_just_pressed/(KEY_LETTER_BASE + 22) == 1 and vim_pending == 97.
    /vim_delete_inner_word/ when /input_key_just_pressed/(KEY_LETTER_BASE + 22) == 1 and vim_pending == 106.
    /vim_delete_around_word/ when /input_key_just_pressed/(KEY_LETTER_BASE + 22) == 1 and vim_pending == 98.
    
    // Handle 'gg' - goto first line
    /vim_goto_first_line/ when /input_key_just_pressed/(KEY_LETTER_BASE + 6) == 1 and vim_pending == 103.
    // Handle 'g' to start pending (only if was already 0)
    /vim_start_pending_g/ when /input_key_just_pressed/(KEY_LETTER_BASE + 6) == 1 and orig_pending == 0 and shift == 0.
    
    // Handle 'G' (shift+g) for goto last line
    /vim_goto_last_line/ when /input_key_just_pressed/(KEY_LETTER_BASE + 6) == 1 and shift == 1 and orig_pending == 0.
    
    // Cancel pending on ESC
    vim_pending = 0 when /input_key_just_pressed/KEY_ESCAPE == 1.
<

#vim_start_pending_d() >
    vim_pending = 100.
<

#vim_start_pending_y() >
    vim_pending = 121.
<

#vim_start_pending_c() >
    vim_pending = 99.
<

#vim_start_pending_ci() >
    vim_pending = 105.  // ci - change inner
<

#vim_start_pending_ca() >
    vim_pending = 97.   // ca - change around
<

#vim_start_pending_di() >
    vim_pending = 106.  // di - delete inner
<

#vim_start_pending_da() >
    vim_pending = 98.   // da - delete around
<

#vim_start_pending_g() >
    vim_pending = 103.
<

// ============================================================================
// Vim Normal Mode: Movement
// ============================================================================

#vim_move_left() >
    vim_pending = 0.
    editor_cursor_col = editor_cursor_col - 1 when editor_cursor_col gt 0.
    /reset_blink/.
<

#vim_move_right() >
    vim_pending = 0.
    len := /ds_strlen/(editor_lines[editor_cursor_line]).
    max_col := len - 1.
    max_col = 0 when max_col lt 0.
    editor_cursor_col = editor_cursor_col + 1 when editor_cursor_col lt max_col.
    /reset_blink/.
<

#vim_move_up() >
    vim_pending = 0.
    << 0 when editor_cursor_line == 0.
    editor_cursor_line = editor_cursor_line - 1.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

#vim_move_down() >
    vim_pending = 0.
    << 0 when editor_cursor_line ge editor_num_lines - 1.
    editor_cursor_line = editor_cursor_line + 1.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

#vim_line_start() >
    vim_pending = 0.
    editor_cursor_col = 0.
    /reset_blink/.
<

#vim_line_end() >
    vim_pending = 0.
    len := /ds_strlen/(editor_lines[editor_cursor_line]).
    editor_cursor_col = len - 1.
    editor_cursor_col = 0 when editor_cursor_col lt 0.
    /reset_blink/.
<

#vim_first_nonblank() >
    vim_pending = 0.
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    col := 0.
    loop when col lt len >
        ch := /ds_string_at/line/col.
        >> when ch != 32 and ch != 9.  // not space or tab
        col = col + 1.
    <
    editor_cursor_col = col.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
<

#vim_goto_first_line() >
    vim_pending = 0.
    editor_cursor_line = 0.
    editor_cursor_col = 0.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

#vim_goto_last_line() >
    vim_pending = 0.
    editor_cursor_line = editor_num_lines - 1.
    editor_cursor_col = 0.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

// ============================================================================
// Vim Normal Mode: Word Movement
// ============================================================================

#vim_word_forward() >
    vim_pending = 0.
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    col := editor_cursor_col.
    
    // Skip current word (non-spaces)
    loop when col lt len >
        ch := /ds_string_at/line/col.
        >> when ch == 32 or ch == 9.
        col = col + 1.
    <
    
    // Skip spaces
    loop when col lt len >
        ch := /ds_string_at/line/col.
        >> when ch != 32 and ch != 9.
        col = col + 1.
    <
    
    // If at end of line, go to next line
    /vim_word_forward_next_line/ when col ge len and editor_cursor_line lt editor_num_lines - 1.
    editor_cursor_col = col when col lt len.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
<

#vim_word_forward_next_line() >
    editor_cursor_line = editor_cursor_line + 1.
    editor_cursor_col = 0.
    /vim_first_nonblank/.
    /editor_adjust_scroll/.
<

#vim_word_backward() >
    vim_pending = 0.
    line := editor_lines[editor_cursor_line].
    col := editor_cursor_col.
    
    // If at start of line, go to previous line
    /vim_word_backward_prev_line/ when col == 0 and editor_cursor_line gt 0.
    << 0 when col == 0.
    
    col = col - 1.
    
    // Skip spaces backward
    loop when col gt 0 >
        ch := /ds_string_at/line/col.
        >> when ch != 32 and ch != 9.
        col = col - 1.
    <
    
    // Skip word backward
    loop when col gt 0 >
        prev_ch := /ds_string_at/line/(col - 1).
        >> when prev_ch == 32 or prev_ch == 9.
        col = col - 1.
    <
    
    editor_cursor_col = col.
    /reset_blink/.
<

#vim_word_backward_prev_line() >
    editor_cursor_line = editor_cursor_line - 1.
    len := /ds_strlen/(editor_lines[editor_cursor_line]).
    editor_cursor_col = len - 1.
    editor_cursor_col = 0 when editor_cursor_col lt 0.
    /reset_blink/.
    /editor_adjust_scroll/.
<

#vim_word_end() >
    vim_pending = 0.
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    col := editor_cursor_col.
    
    << 0 when len == 0.
    
    // Move at least one character
    col = col + 1 when col lt len - 1.
    
    // Skip spaces
    loop when col lt len >
        ch := /ds_string_at/line/col.
        >> when ch != 32 and ch != 9.
        col = col + 1.
    <
    
    // Skip to end of word
    loop when col lt len - 1 >
        next_ch := /ds_string_at/line/(col + 1).
        >> when next_ch == 32 or next_ch == 9.
        col = col + 1.
    <
    
    editor_cursor_col = col.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
<

// ============================================================================
// Vim Normal Mode: Insert Transitions
// ============================================================================

#vim_enter_insert() >
    /undo_save_state/.  // Save before insert session
    vim_mode = VIM_MODE_INSERT.
    vim_pending = 0.
    vim_mode_switched = 1.
    /reset_blink/.
<

#vim_insert_at_cursor() >
    /vim_enter_insert/.
<

#vim_insert_line_start() >
    /vim_first_nonblank/.
    /vim_enter_insert/.
<

#vim_append_after() >
    len := /ds_strlen/(editor_lines[editor_cursor_line]).
    editor_cursor_col = editor_cursor_col + 1 when editor_cursor_col lt len.
    /vim_enter_insert/.
<

#vim_append_line_end() >
    editor_cursor_col = /ds_strlen/(editor_lines[editor_cursor_line]).
    /vim_enter_insert/.
<

#vim_open_below() >
    // Move to end of current line and insert newline
    editor_cursor_col = /ds_strlen/(editor_lines[editor_cursor_line]).
    /editor_newline/.
    /vim_enter_insert/.
<

#vim_open_above() >
    // Insert line above current
    editor_cursor_col = 0.
    /editor_newline/.
    editor_cursor_line = editor_cursor_line - 1.
    /vim_enter_insert/.
<

// ============================================================================
// Vim Normal Mode: Editing
// ============================================================================

#vim_delete_char() >
    /undo_save_state/.
    vim_pending = 0.
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    << 0 when len == 0.
    
    new_line := /ds_string_delete_char/line/editor_cursor_col.
    editor_lines[editor_cursor_line] = new_line.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
<

#vim_delete_line() >
    /undo_save_state/.
    vim_pending = 0.
    
    // Yank the line first
    vim_yank_buffer = editor_lines[editor_cursor_line].
    vim_yank_is_line = 1.
    
    // If only one line, just clear it
    /vim_clear_only_line/ when editor_num_lines == 1.
    << 0 when editor_num_lines == 1.
    
    // Shift lines up
    for i in editor_cursor_line..(editor_num_lines - 1) >
        editor_lines[i] = editor_lines[i + 1].
    <
    
    editor_num_lines = editor_num_lines - 1.
    
    // Adjust cursor if past end
    editor_cursor_line = editor_num_lines - 1 when editor_cursor_line ge editor_num_lines.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

#vim_clear_only_line() >
    editor_lines[0] = "".
    editor_cursor_col = 0.
    /reset_blink/.
<

#vim_change_line() >
    vim_pending = 0.
    // Clear line content and enter insert mode
    editor_lines[editor_cursor_line] = "".
    editor_cursor_col = 0.
    /vim_enter_insert/.
<

#vim_change_word() >
    vim_pending = 0.
    /vim_delete_to_word_end/.
    /vim_enter_insert/.
<

#vim_delete_word() >
    /undo_save_state/.
    vim_pending = 0.
    /vim_delete_to_word_end/.
<

#vim_change_word_backward() >
    vim_pending = 0.
    /vim_delete_to_word_start/.
    /vim_enter_insert/.
<

#vim_delete_word_backward() >
    /undo_save_state/.
    vim_pending = 0.
    /vim_delete_to_word_start/.
<

#vim_delete_to_word_start() >
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    << 0 when len == 0.
    << 0 when editor_cursor_col == 0.
    
    col := editor_cursor_col.
    start_col := col.
    
    // Go back to start of current/previous word
    start_col = start_col - 1 when start_col gt 0.
    
    // Skip spaces backward
    loop when start_col gt 0 >
        ch := /ds_string_at/line/start_col.
        >> when ch != 32 and ch != 9.
        start_col = start_col - 1.
    <
    
    // Skip word backward
    loop when start_col gt 0 >
        prev_ch := /ds_string_at/line/(start_col - 1).
        >> when prev_ch == 32 or prev_ch == 9.
        start_col = start_col - 1.
    <
    
    // Delete from start_col to cursor
    left := /ds_substring/line/0/start_col.
    right := /ds_substring/line/col/(len - col).
    new_line := /ds_string_concat/left/right.
    editor_lines[editor_cursor_line] = new_line.
    editor_cursor_col = start_col.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
<

#vim_delete_to_word_end() >
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    << 0 when len == 0.
    
    col := editor_cursor_col.
    
    // Find end of word (skip non-spaces, then skip spaces)
    end_col := col.
    loop when end_col lt len >
        ch := /ds_string_at/line/end_col.
        >> when ch == 32 or ch == 9.
        end_col = end_col + 1.
    <
    
    // Delete from cursor to end_col
    left := /ds_substring/line/0/col.
    right := /ds_substring/line/end_col/(len - end_col).
    new_line := /ds_string_concat/left/right.
    editor_lines[editor_cursor_line] = new_line.
    /vim_clamp_cursor_normal/.
    /reset_blink/.
<

#vim_change_inner_word() >
    vim_pending = 0.
    /vim_select_inner_word/.
    /delete_selection/.
    /vim_enter_insert/.
<

#vim_change_around_word() >
    vim_pending = 0.
    /vim_select_around_word/.
    /delete_selection/.
    /vim_enter_insert/.
<

#vim_delete_inner_word() >
    /undo_save_state/.
    vim_pending = 0.
    /vim_select_inner_word/.
    /delete_selection/.
    /vim_clamp_cursor_normal/.
<

#vim_delete_around_word() >
    /undo_save_state/.
    vim_pending = 0.
    /vim_select_around_word/.
    /delete_selection/.
    /vim_clamp_cursor_normal/.
<

#vim_select_inner_word() >
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    << 0 when len == 0.
    
    col := editor_cursor_col.
    
    // Find start of word (go back while not space)
    start_col := col.
    loop when start_col gt 0 >
        ch := /ds_string_at/line/(start_col - 1).
        >> when ch == 32 or ch == 9.
        start_col = start_col - 1.
    <
    
    // Find end of word (go forward while not space)
    end_col := col.
    loop when end_col lt len >
        ch := /ds_string_at/line/end_col.
        >> when ch == 32 or ch == 9.
        end_col = end_col + 1.
    <
    
    // Set selection
    sel_start_line = editor_cursor_line.
    sel_start_col = start_col.
    sel_end_line = editor_cursor_line.
    sel_end_col = end_col.
    has_selection = 1 when end_col gt start_col.
<

#vim_select_around_word() >
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    << 0 when len == 0.
    
    col := editor_cursor_col.
    
    // Find start of word (go back while not space)
    start_col := col.
    loop when start_col gt 0 >
        ch := /ds_string_at/line/(start_col - 1).
        >> when ch == 32 or ch == 9.
        start_col = start_col - 1.
    <
    
    // Find end of word (go forward while not space)
    end_col := col.
    loop when end_col lt len >
        ch := /ds_string_at/line/end_col.
        >> when ch == 32 or ch == 9.
        end_col = end_col + 1.
    <
    
    // Include trailing spaces for "around"
    loop when end_col lt len >
        ch := /ds_string_at/line/end_col.
        >> when ch != 32 and ch != 9.
        end_col = end_col + 1.
    <
    
    // Set selection
    sel_start_line = editor_cursor_line.
    sel_start_col = start_col.
    sel_end_line = editor_cursor_line.
    sel_end_col = end_col.
    has_selection = 1 when end_col gt start_col.
    /reset_blink/.
<

#vim_do_yank_line() >
    vim_pending = 0.
    vim_yank_buffer = editor_lines[editor_cursor_line].
    vim_yank_is_line = 1.
    /reset_blink/.
<

#vim_paste_after() >
    /undo_save_state/.
    vim_pending = 0.
    << 0 when /ds_strlen/vim_yank_buffer == 0 and vim_yank_is_line == 0.
    
    /vim_paste_line_after/ when vim_yank_is_line == 1.
    << 0 when vim_yank_is_line == 1.
    
    // Paste text at cursor
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    
    left := /ds_substring/line/0/(editor_cursor_col + 1).
    right := /ds_substring/line/(editor_cursor_col + 1)/(len - editor_cursor_col - 1).
    
    new_line := /ds_string_concat/left/vim_yank_buffer.
    new_line = /ds_string_concat/new_line/right.
    editor_lines[editor_cursor_line] = new_line.
    
    editor_cursor_col = editor_cursor_col + 1.
    /reset_blink/.
<

#vim_paste_line_after() >
    // Insert yanked line below current
    i := editor_num_lines.
    loop when i gt editor_cursor_line + 1 >
        editor_lines[i] = editor_lines[i - 1].
        i = i - 1.
    <
    
    editor_lines[editor_cursor_line + 1] = vim_yank_buffer.
    editor_num_lines = editor_num_lines + 1.
    editor_cursor_line = editor_cursor_line + 1.
    editor_cursor_col = 0.
    /vim_first_nonblank/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

#vim_paste_before() >
    /undo_save_state/.
    vim_pending = 0.
    << 0 when /ds_strlen/vim_yank_buffer == 0 and vim_yank_is_line == 0.
    
    /vim_paste_line_before/ when vim_yank_is_line == 1.
    << 0 when vim_yank_is_line == 1.
    
    // Paste text before cursor
    line := editor_lines[editor_cursor_line].
    len := /ds_strlen/line.
    
    left := /ds_substring/line/0/editor_cursor_col.
    right := /ds_substring/line/editor_cursor_col/(len - editor_cursor_col).
    
    new_line := /ds_string_concat/left/vim_yank_buffer.
    new_line = /ds_string_concat/new_line/right.
    editor_lines[editor_cursor_line] = new_line.
    
    /reset_blink/.
<

#vim_paste_line_before() >
    // Insert yanked line above current
    i := editor_num_lines.
    loop when i gt editor_cursor_line >
        editor_lines[i] = editor_lines[i - 1].
        i = i - 1.
    <
    
    editor_lines[editor_cursor_line] = vim_yank_buffer.
    editor_num_lines = editor_num_lines + 1.
    editor_cursor_col = 0.
    /vim_first_nonblank/.
    /reset_blink/.
    /editor_adjust_scroll/.
<

// ============================================================================
// Vim Mode: Insert
// ============================================================================

#vim_update_insert(dt) >
    shift := /input_shift_held/.
    
    // Handle key input with repeat support
    /handle_key_with_repeat/KEY_UP/dt.
    /handle_key_with_repeat/KEY_DOWN/dt.
    /handle_key_with_repeat/KEY_LEFT/dt.
    /handle_key_with_repeat/KEY_RIGHT/dt.
    /handle_key_with_repeat/KEY_BACKSPACE/dt.
    /handle_key_with_repeat/KEY_DELETE/dt.
    
    // Non-repeating keys
    /editor_home/ when /input_key_just_pressed/KEY_HOME == 1.
    /editor_end/ when /input_key_just_pressed/KEY_END == 1.
    /editor_newline/ when /input_key_just_pressed/KEY_ENTER == 1.
    /editor_insert_tab/ when /input_key_just_pressed/KEY_TAB == 1.
    
    // Character input
    /check_char_input_with_repeat/shift/dt.
<

#handle_key_with_repeat(key, dt) >
    just_pressed := /input_key_just_pressed/key.
    is_held := /input_key_pressed/key.
    
    // Key just pressed - execute immediately and start repeat timer
    /execute_key_action/key when just_pressed == 1.
    key_repeat_key = key when just_pressed == 1.
    key_repeat_timer = 0 when just_pressed == 1.
    
    // Key held and this is the repeat key - check for repeat
    /check_key_repeat/key/dt when is_held == 1 and key_repeat_key == key.
    
    // Key released - clear repeat state if this was the repeat key
    /clear_repeat_if_match/key when is_held == 0.
<

#clear_repeat_if_match(key) >
    key_repeat_key = 0 - 1 when key_repeat_key == key.
<

#check_key_repeat(key, dt) >
    key_repeat_timer = key_repeat_timer + dt.
    
    // Initial delay before repeat starts
    << 0 when key_repeat_timer lt KEY_REPEAT_DELAY.
    
    // After delay, repeat at rate
    repeat_time := key_repeat_timer - KEY_REPEAT_DELAY.
    remainder := /ds_mod/repeat_time/KEY_REPEAT_RATE.
    /execute_key_action/key when remainder lt dt.
<

#execute_key_action(key) >
    /editor_move_up/ when key == KEY_UP.
    /editor_move_down/ when key == KEY_DOWN.
    /editor_move_left/ when key == KEY_LEFT.
    /editor_move_right/ when key == KEY_RIGHT.
    /editor_backspace/ when key == KEY_BACKSPACE.
    /editor_delete_char_at_cursor/ when key == KEY_DELETE.
<

#check_char_input_with_repeat(shift, dt) >
    // For simplicity, just use just_pressed for character keys
    // Full repeat would require tracking each key separately
    
    // Letters
    for i in 0..26 >
        key := KEY_LETTER_BASE + i.
        /editor_insert_char/(/key_to_char/key/shift) when /input_key_just_pressed/key == 1.
    <
    
    // Digits
    for i in 0..10 >
        key := KEY_DIGIT_BASE + i.
        /editor_insert_char/(/key_to_char/key/shift) when /input_key_just_pressed/key == 1.
    <
    
    // Special keys
    /editor_insert_char/(/key_to_char/KEY_MINUS/shift) when /input_key_just_pressed/KEY_MINUS == 1.
    /editor_insert_char/(/key_to_char/KEY_EQUAL/shift) when /input_key_just_pressed/KEY_EQUAL == 1.
    /editor_insert_char/(/key_to_char/KEY_BRACKET_L/shift) when /input_key_just_pressed/KEY_BRACKET_L == 1.
    /editor_insert_char/(/key_to_char/KEY_BRACKET_R/shift) when /input_key_just_pressed/KEY_BRACKET_R == 1.
    /editor_insert_char/(/key_to_char/KEY_SEMICOLON/shift) when /input_key_just_pressed/KEY_SEMICOLON == 1.
    /editor_insert_char/(/key_to_char/KEY_QUOTE/shift) when /input_key_just_pressed/KEY_QUOTE == 1.
    /editor_insert_char/(/key_to_char/KEY_BACKQUOTE/shift) when /input_key_just_pressed/KEY_BACKQUOTE == 1.
    /editor_insert_char/(/key_to_char/KEY_BACKSLASH/shift) when /input_key_just_pressed/KEY_BACKSLASH == 1.
    /editor_insert_char/(/key_to_char/KEY_COMMA/shift) when /input_key_just_pressed/KEY_COMMA == 1.
    /editor_insert_char/(/key_to_char/KEY_PERIOD/shift) when /input_key_just_pressed/KEY_PERIOD == 1.
    /editor_insert_char/(/key_to_char/KEY_SLASH/shift) when /input_key_just_pressed/KEY_SLASH == 1.
    /editor_insert_char/(/key_to_char/KEY_SPACE/shift) when /input_key_just_pressed/KEY_SPACE == 1.
<

// ============================================================================
// Rendering
// ============================================================================

#render_editor() >
    /draw_editor_header/.
    /draw_editor_selection/ when has_selection == 1.
    /draw_editor_content/.
    /draw_editor_cursor/ when editor_cursor_visible == 1.
    /draw_editor_scrollbar/.
<

#draw_editor_header() >
    hx := editor_x + 5.
    hy := editor_y + 3.
    
    /text_draw/hx/hy/EDITOR_FONT_SIZE/ED_CURSOR_R/ED_CURSOR_G/ED_CURSOR_B/"[CODE EDITOR]".
    
    // Draw vim mode indicator
    hx2 := editor_x + 130.
    /draw_vim_mode_normal/hx2/hy when vim_mode == VIM_MODE_NORMAL.
    /draw_vim_mode_insert/hx2/hy when vim_mode == VIM_MODE_INSERT.
<

#draw_vim_mode_normal(x, y) >
    /text_draw/x/y/EDITOR_FONT_SIZE/ED_NORMAL_R/ED_NORMAL_G/ED_NORMAL_B/"-- NORMAL --".
    
    // Show pending command if any
    px := x + 110.
    /text_draw/px/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"d..." when vim_pending == 100.
    /text_draw/px/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"y..." when vim_pending == 121.
    /text_draw/px/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"g..." when vim_pending == 103.
    /text_draw/px/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"c..." when vim_pending == 99.
    /text_draw/px/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"ci.." when vim_pending == 105.
    /text_draw/px/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"ca.." when vim_pending == 97.
    /text_draw/px/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"di.." when vim_pending == 106.
    /text_draw/px/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"da.." when vim_pending == 98.
<

#draw_vim_mode_insert(x, y) >
    /text_draw/x/y/EDITOR_FONT_SIZE/ED_INSERT_R/ED_INSERT_G/ED_INSERT_B/"-- INSERT --".
<

#draw_editor_selection() >
    content_y := editor_y + 25.
    line_num_width := 35.
    text_x := editor_x + line_num_width + 10.
    
    // Draw selection for each visible line in the selection range
    visible_lines := (editor_height - 40) / EDITOR_LINE_HEIGHT.
    visible_lines = 1 when visible_lines lt 1.
    
    for i in 0..visible_lines >
        line_idx := editor_scroll_y + i.
        >> when line_idx ge editor_num_lines.
        /draw_sel_line/line_idx/content_y/text_x when line_idx ge sel_start_line and line_idx le sel_end_line.
    <
<

#draw_sel_line(line_idx, content_y, text_x) >
    screen_line := line_idx - editor_scroll_y.
    << 0 when screen_line lt 0.
    
    // Offset by -1 to center the selection box better with the text
    ly := content_y + screen_line * EDITOR_LINE_HEIGHT - 2.
    line_len := /ds_strlen/(editor_lines[line_idx]).
    
    // Calculate selection bounds for this line
    start_col := 0.
    end_col := line_len.
    
    start_col = sel_start_col when line_idx == sel_start_line.
    end_col = sel_end_col when line_idx == sel_end_line.
    
    // Draw selection highlight as filled rectangle
    sx := text_x + /col_to_px/start_col.
    sel_width := /col_to_px/(end_col - start_col).
    
    // Only draw if width > 0
    /draw_rect/sx/ly/sel_width/EDITOR_LINE_HEIGHT/ED_SELECT_R/ED_SELECT_G/ED_SELECT_B/200 when sel_width gt 0.
<

#draw_editor_content() >
    content_y := editor_y + 25.
    line_num_width := 35.
    
    visible_lines := (editor_height - 40) / EDITOR_LINE_HEIGHT.
    visible_lines = 1 when visible_lines lt 1.
    
    // Simple rendering - iterate through visible screen rows
    for screen_row in 0..visible_lines >
        // Map screen row to actual line (accounting for scroll and folds)
        actual_line := /get_actual_line_for_screen_row/(editor_scroll_y + screen_row).
        >> when actual_line lt 0.
        >> when actual_line ge editor_num_lines.
        
        ly := content_y + screen_row * EDITOR_LINE_HEIGHT.
        
        // Check if this line is a fold header
        is_fold := /is_fold_header/actual_line.
        is_collapsed := fold_state[actual_line].
        
        // Draw fold indicator (between line number and text)
        fold_x := editor_x + line_num_width + 2.
        /draw_fold_indicator/fold_x/ly/is_collapsed when is_fold == 1.
        
        // Execution indicator - highlight line background when bot is running/stepped
        is_exec_line := (actual_line == bot_current_line).
        is_active := (bot_is_running == 1 or bot_is_stepping == 1).
        /draw_exec_indicator/(editor_x)/(ly - 2)/(line_num_width + 5) when is_exec_line == 1 and is_active == 1.
        
        // Error line indicator - highlight line in red when there's a parse error
        is_error_line := (actual_line == bot_error_line).
        /draw_error_indicator/(editor_x)/(ly - 2)/(editor_width - 10) when is_error_line == 1 and bot_has_error == 1.
        
        // Line number
        lnx := editor_x + 5.
        /text_draw_int/lnx/ly/EDITOR_FONT_SIZE/ED_LINENUM_R/ED_LINENUM_G/ED_LINENUM_B/(actual_line + 1).
        
        // Execution arrow marker
        /draw_exec_arrow/(editor_x - 2)/ly when is_exec_line == 1 and is_active == 1.
        
        // Line content with syntax highlighting
        tx := editor_x + line_num_width + 10.
        line_text := editor_lines[actual_line].
        /draw_highlighted_line/line_text/tx/ly/EDITOR_FONT_SIZE.
        
        // Draw fold ellipsis if collapsed
        /draw_fold_ellipsis/tx/ly/line_text when is_collapsed == 1.
    <
<

// Map a display row (0-indexed from top of visible area) to actual line index
// This accounts for collapsed folds
#get_actual_line_for_screen_row(display_row) >
    << -1 when display_row lt 0.
    
    actual := 0.
    display := 0.
    
    loop >
        >> when display gt display_row.
        >> when actual ge editor_num_lines.
        
        << actual when display == display_row.
        
        // Check if this fold is collapsed - if so, skip to end
        is_collapsed := fold_state[actual].
        is_fold := /is_fold_header/actual.
        
        // Move to next display row
        display = display + 1.
        
        // If this is a collapsed fold, skip its contents
        should_skip := (is_collapsed == 1 and is_fold == 1).
        fold_end := actual. // Default: don't skip
        fold_end = /find_fold_end/actual when should_skip == 1.
        actual = fold_end when should_skip == 1 and fold_end gt actual.
        
        actual = actual + 1.
    <
    
    << -1.
<

#draw_fold_indicator(x, y, is_collapsed) >
    // Draw fold indicator at fixed position after line numbers
    ind_x := editor_x + 25.
    /text_draw/ind_x/y/EDITOR_FONT_SIZE/SYN_SCOPE_R/SYN_SCOPE_G/SYN_SCOPE_B/">" when is_collapsed == 1.
    /text_draw/ind_x/y/EDITOR_FONT_SIZE/SYN_COMMENT_R/SYN_COMMENT_G/SYN_COMMENT_B/"v" when is_collapsed == 0.
<

#draw_fold_ellipsis(x, y, line) >
    // Draw "..." after the line to indicate folded content
    len := /ds_strlen/line.
    ellipsis_x := x + /col_to_px/len + 10.
    /text_draw/ellipsis_x/y/EDITOR_FONT_SIZE/ED_COMMENT_R/ED_COMMENT_G/ED_COMMENT_B/"...".
<

#draw_exec_indicator(x, y, w) >
    // Draw a subtle highlight behind the current execution line
    /draw_rect/x/y/w/EDITOR_LINE_HEIGHT/40/60/40/180.
<

#draw_exec_arrow(x, y) >
    // Draw a small arrow marker (>) to indicate execution point
    /text_draw/x/y/EDITOR_FONT_SIZE/100/255/100/">".
<

#draw_error_indicator(x, y, w) >
    // Draw a red highlight behind the error line
    /draw_rect/x/y/w/EDITOR_LINE_HEIGHT/80/30/30/180.
<

#draw_editor_cursor() >
    content_y := editor_y + 25.
    line_num_width := 35.
    text_x := editor_x + line_num_width + 10.
    
    cursor_screen_line := editor_cursor_line - editor_scroll_y.
    << 0 when cursor_screen_line lt 0.
    
    // Calculate cursor position - use offset to fine-tune
    cx := text_x + /col_to_px/editor_cursor_col + EDITOR_CURSOR_OFFSET.
    cy := content_y + cursor_screen_line * EDITOR_LINE_HEIGHT - 0.
    
    // Draw cursor based on vim mode
    // Insert mode: thin line cursor (2px wide)
    /draw_rect/cx/cy/2/14/ED_CURSOR_R/ED_CURSOR_G/ED_CURSOR_B/255 when vim_mode == VIM_MODE_INSERT.
    
    // Normal mode: block cursor (character width, semi-transparent)
    char_width := EDITOR_CHAR_WIDTH_X10 / 10.
    /draw_rect/cx/cy/char_width/14/ED_CURSOR_R/ED_CURSOR_G/ED_CURSOR_B/180 when vim_mode == VIM_MODE_NORMAL.
<

#draw_editor_scrollbar() >
    // Calculate visible lines
    visible_lines := (editor_height - 40) / EDITOR_LINE_HEIGHT.
    visible_lines = 1 when visible_lines lt 1.
    
    // Only show scrollbar if content overflows
    << 0 when editor_num_lines le visible_lines.
    
    // Scrollbar dimensions
    scrollbar_width := 8.
    scrollbar_x := editor_x + editor_width - scrollbar_width - 4.
    track_y := editor_y + 25.
    track_height := editor_height - 35.
    
    // Draw track background
    /draw_rect/scrollbar_x/track_y/scrollbar_width/track_height/ED_SCROLLBAR_TRACK_R/ED_SCROLLBAR_TRACK_G/ED_SCROLLBAR_TRACK_B/150.
    
    // Calculate thumb size and position
    // Thumb height is proportional to visible/total ratio
    thumb_height := track_height * visible_lines / editor_num_lines.
    thumb_height = 20 when thumb_height lt 20.  // Minimum thumb size
    
    // Thumb position based on scroll position
    max_scroll := editor_num_lines - visible_lines.
    max_scroll = 1 when max_scroll lt 1.
    scroll_ratio := editor_scroll_y * 100 / max_scroll.  // 0-100
    available_space := track_height - thumb_height.
    thumb_y := track_y + available_space * scroll_ratio / 100.
    
    // Draw thumb
    /draw_rect/scrollbar_x/thumb_y/scrollbar_width/thumb_height/ED_SCROLLBAR_THUMB_R/ED_SCROLLBAR_THUMB_G/ED_SCROLLBAR_THUMB_B/220.
<
