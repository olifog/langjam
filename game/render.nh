// render.nh - Colors and dungeon rendering

// ============================================================================
// Display Constants
// ============================================================================

TILE_W := 10.
TILE_H := 16.

// Tile characters
CHAR_FLOOR := 46.       // '.'
CHAR_WALL_H := 45.      // '-'
CHAR_WALL_V := 124.     // '|'
CHAR_PLAYER := 64.      // '@'
CHAR_DOOR := 43.        // '+'
CHAR_CORRIDOR := 35.    // '#'
CHAR_STAIRS_DOWN := 62. // '>'
CHAR_GOLD := 36.        // '$'

// ============================================================================
// Colors
// ============================================================================

COL_GRAY_R := 170.
COL_GRAY_G := 170.
COL_GRAY_B := 170.

COL_WHITE_R := 255.
COL_WHITE_G := 255.
COL_WHITE_B := 255.

COL_GOLD_R := 255.
COL_GOLD_G := 255.
COL_GOLD_B := 0.

COL_BROWN_R := 180.
COL_BROWN_G := 100.
COL_BROWN_B := 40.

COL_CYAN_R := 0.
COL_CYAN_G := 255.
COL_CYAN_B := 255.

COL_GREEN_R := 100.
COL_GREEN_G := 255.
COL_GREEN_B := 100.

// ============================================================================
// Dungeon Rendering
// ============================================================================

#render_dungeon() >
    map_offset_x := dungeon_x.
    map_offset_y := dungeon_y + 12.
    
    // Draw tiles
    for y in 0..MAP_HEIGHT >
        for x in 0..MAP_WIDTH >
            /draw_tile/x/y/map_offset_x/map_offset_y.
        <
    <
    
    // Status
    /draw_status/map_offset_x/map_offset_y.
    
    // Message
    msg_y := map_offset_y + MAP_HEIGHT * TILE_H + 60.
    /text_draw/map_offset_x/msg_y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/last_message.
    
    // Bot Message (below game message)
    bot_msg_y := msg_y + 20.
    bot_msg_len := /ds_strlen/bot_message.
    // Cyan color for bot status
    /text_draw/map_offset_x/bot_msg_y/14/COL_CYAN_R/COL_CYAN_G/COL_CYAN_B/bot_message when bot_msg_len gt 0.
    
    // Show print value below bot message (yellow color: 255, 220, 80)
    print_y := bot_msg_y + 20.
    /text_draw/(map_offset_x)/print_y/12/255/220/80/"Print:" when bot_has_print == 1.
    is_str := bot_print_is_string.
    /text_draw/(map_offset_x + 55)/print_y/12/255/220/80/bot_print_buffer when bot_has_print == 1 and is_str == 1.
    /text_draw_int/(map_offset_x + 55)/print_y/12/255/220/80/bot_print_buffer when bot_has_print == 1 and is_str == 0.
    
    // Header
    /text_draw/map_offset_x/dungeon_y/12/COL_CYAN_R/COL_CYAN_G/COL_CYAN_B/"[DUNGEON]".
    
    // Bot status
    bot_x := map_offset_x + 100.
    /text_draw/bot_x/dungeon_y/12/COL_GREEN_R/COL_GREEN_G/COL_GREEN_B/"BOT: RUNNING" when bot_is_running == 1 and bot_has_error == 0.
    /text_draw/bot_x/dungeon_y/12/COL_GRAY_R/COL_GRAY_G/COL_GRAY_B/"BOT: STOPPED" when bot_is_running == 0 and bot_has_error == 0.
    /text_draw/bot_x/dungeon_y/12/255/80/80/"BOT: ERROR" when bot_has_error == 1.
    
<

#draw_player() >
    map_offset_x := dungeon_x.
    map_offset_y := dungeon_y + 12.

    // Draw player with interpolated position for smooth movement
    t_ms := anim_duration_scaled - anim_timer.
    t_ms = 0 when t_ms lt 0.
    
    prev_px := player_prev_x * TILE_W.
    curr_px := player_x * TILE_W.
    prev_py := player_prev_y * TILE_H.
    curr_py := player_y * TILE_H.
    
    // Calculate interpolated position
    draw_x := curr_px.
    draw_y := curr_py.
    draw_x = prev_px + (curr_px - prev_px) * t_ms / anim_duration_scaled when anim_duration_scaled gt 0.
    draw_y = prev_py + (curr_py - prev_py) * t_ms / anim_duration_scaled when anim_duration_scaled gt 0.
    
    // Attack Animation
    // Move towards target then back
    // Use half of timer for out, half for back
    att_time := player_attack_timer.
    att_dx := player_attack_dx * 5. // 5 pixels magnitude
    att_dy := player_attack_dy * 5.
    
    // Only animate if timer > 0
    // Simple linear out/in
    // If timer 10..5: Out (0 to 1)
    // If timer 5..0: In (1 to 0)
    // Actually simpler: just apply offset scaled by sin? Or 10-timer?
    // Let's do linear ramp up/down
    
    att_offset_x := 0.
    att_offset_y := 0.
    
    is_attacking := 0.
    is_attacking = 1 when att_time gt 0.
    
    // Ramp up (10 to 5)
    // val goes 0 to 5
    ramp_up := 10 - att_time.
    
    // Ramp down (5 to 0)
    // val goes 5 to 0
    ramp_down := att_time.
    
    // Pick the smaller of the two to create a triangle wave 0..5..0
    // If time=10 (start), up=0, down=10 -> 0
    // If time=5 (mid), up=5, down=5 -> 5
    // If time=0 (end), up=10, down=0 -> 0
    
    anim_val := ramp_up.
    anim_val = ramp_down when ramp_down lt ramp_up.
    
    // Scale offset (0..1.0 * magnitude)
    // Divide by 5 to normalize to 0..1 then multiply by mag 5... so just anim_val
    att_offset_x = att_dx * anim_val / 5 when is_attacking == 1.
    att_offset_y = att_dy * anim_val / 5 when is_attacking == 1.
    
    // Apply offset
    draw_x = draw_x + att_offset_x.
    draw_y = draw_y + att_offset_y.
    
    px := map_offset_x + draw_x.
    py := map_offset_y + draw_y.
    
    // Color
    col_r := COL_WHITE_R.
    col_g := COL_WHITE_G.
    col_b := COL_WHITE_B.
    
    // Hit Flash
    flash := player_hit_flash.
    
    // Decrement flash
    player_hit_flash = flash - 1 when flash gt 0.
    player_attack_timer = att_time - 1 when att_time gt 0.
    
    is_flashing := 0.
    is_flashing = 1 when flash gt 0.
    
    // Flash Red
    col_r = 255 when is_flashing == 1.
    col_g = 50 when is_flashing == 1.
    col_b = 50 when is_flashing == 1.
    
    /text_char/px/py/TILE_H/col_r/col_g/col_b/CHAR_PLAYER.
<

#draw_tile(x, y, offset_x, offset_y) >
    tile := /get_tile/x/y.
    << 0 when tile == TILE_EMPTY.
    
    sx := offset_x + x * TILE_W.
    sy := offset_y + y * TILE_H.
    
    /text_char/sx/sy/TILE_H/COL_GRAY_R/COL_GRAY_G/COL_GRAY_B/CHAR_FLOOR when tile == TILE_FLOOR.
    /text_char/sx/sy/TILE_H/COL_BROWN_R/COL_BROWN_G/COL_BROWN_B/CHAR_WALL_H when tile == TILE_WALL_H.
    /text_char/sx/sy/TILE_H/COL_BROWN_R/COL_BROWN_G/COL_BROWN_B/CHAR_WALL_V when tile == TILE_WALL_V.
    /text_char/sx/sy/TILE_H/COL_GRAY_R/COL_GRAY_G/COL_GRAY_B/CHAR_CORRIDOR when tile == TILE_CORRIDOR.
    /text_char/sx/sy/TILE_H/COL_BROWN_R/COL_BROWN_G/COL_BROWN_B/CHAR_DOOR when tile == TILE_DOOR.
    /text_char/sx/sy/TILE_H/COL_CYAN_R/COL_CYAN_G/COL_CYAN_B/CHAR_STAIRS_DOWN when tile == TILE_STAIRS.
    /text_char/sx/sy/TILE_H/COL_GOLD_R/COL_GOLD_G/COL_GOLD_B/CHAR_GOLD when tile == TILE_GOLD.
<

#draw_status(offset_x, offset_y) >
    y := offset_y + MAP_HEIGHT * TILE_H + 10.
    
    // LINE 1: Name  HP  St  AC  $
    x := offset_x.
    
    // Rodney the Wizard (NetHack style)
    /text_draw/x/y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"Rodney the Wizard".
    
    // HP:11(14) - in red
    x = x + 200.
    /text_draw/x/y/14/COL_RED_R/COL_RED_G/COL_RED_B/"HP:".
    /text_draw_int/(x + 30)/y/14/COL_RED_R/COL_RED_G/COL_RED_B/player_hp.
    
    hp_width := 15.
    hp_width = 25 when player_hp gt 9.
    
    x_brack := x + 30 + hp_width.
    /text_draw/x_brack/y/14/COL_RED_R/COL_RED_G/COL_RED_B/"(".
    /text_draw_int/(x_brack + 10)/y/14/COL_RED_R/COL_RED_G/COL_RED_B/player_max_hp.
    
    hp_max_width := 15.
    hp_max_width = 25 when player_max_hp gt 9.
    
    /text_draw/(x_brack + 10 + hp_max_width)/y/14/COL_RED_R/COL_RED_G/COL_RED_B/")".
    
    // St:18
    x = x + 110.
    /text_draw/x/y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"St:".
    /text_draw_int/(x + 25)/y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/player_str.
    
    // AC:4
    x = x + 70.
    /text_draw/x/y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"AC:".
    /text_draw_int/(x + 30)/y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/player_ac.
    
    // $:43 (current floor gold - lost on death)
    x = x + 70.
    /text_draw/x/y/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"$:".
    /text_draw_int/(x + 20)/y/14/COL_GOLD_R/COL_GOLD_G/COL_GOLD_B/player_gold.
    
    // LINE 2: BANK  BONUS  STREAK  T  restart button
    y2 := y + 20.
    x = offset_x.
    
    // BANK:100 (persistent gold for upgrades)
    /text_draw/x/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"BANK:".
    /text_draw_int/(x + 50)/y2/14/COL_GREEN_R/COL_GREEN_G/COL_GREEN_B/player_bank.
    
    // BONUS (last bonus earned)
    x = x + 110.
    /text_draw/x/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"BONUS:".
    /text_draw_int/(x + 55)/y2/14/COL_CYAN_R/COL_CYAN_G/COL_CYAN_B/dngn_bonus.
    
    // STREAK (dungeon_level - 1, floors completed)
    x = x + 100.
    streak := dungeon_level - 1.
    /text_draw/x/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"STREAK:".
    /text_draw_int/(x + 60)/y2/14/255/200/100/streak.
    
    // T (turns)
    x = x + 100.
    /text_draw/x/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/"T:".
    /text_draw_int/(x + 20)/y2/14/COL_WHITE_R/COL_WHITE_G/COL_WHITE_B/turns.
    
    // Restart button (end of line 2)
    skull_x := x + 80.
    /draw_skull_button/skull_x/y2.
<

// ============================================================================
// Skull Restart Button
// ============================================================================

restart_btn_x := 0.
restart_btn_y := 0.
restart_btn_w := 95.
restart_btn_h := 20.
restart_btn_hovered := 0.

#draw_skull_button(x, y) >
    restart_btn_x = x.
    restart_btn_y = y - 2.
    
    // Check hover
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    restart_btn_hovered = 0.
    restart_btn_hovered = 1 when mx ge x and mx lt x + restart_btn_w and my ge y - 2 and my lt y + restart_btn_h.
    
    // Button background
    bg_r := 40. bg_g := 30. bg_b := 30.
    bg_r = 80 when restart_btn_hovered == 1. bg_g = 40 when restart_btn_hovered == 1. bg_b = 40 when restart_btn_hovered == 1.
    /draw_rect/x/(y - 2)/restart_btn_w/restart_btn_h/bg_r/bg_g/bg_b/255.
    
    // Border
    border_r := 120. border_g := 80. border_b := 80.
    border_r = 200 when restart_btn_hovered == 1. border_g = 100 when restart_btn_hovered == 1. border_b = 100 when restart_btn_hovered == 1.
    /draw_rect/x/(y - 2)/restart_btn_w/1/border_r/border_g/border_b/255.
    /draw_rect/x/(y + restart_btn_h - 3)/restart_btn_w/1/border_r/border_g/border_b/255.
    /draw_rect/x/(y - 2)/1/restart_btn_h/border_r/border_g/border_b/255.
    /draw_rect/(x + restart_btn_w - 1)/(y - 2)/1/restart_btn_h/border_r/border_g/border_b/255.
    
    // Gravestone icon
    icon_x := x + 6.
    icon_y := y.
    stone_r := 140. stone_g := 140. stone_b := 150.
    stone_r = 200 when restart_btn_hovered == 1. stone_g = 200 when restart_btn_hovered == 1. stone_b = 210 when restart_btn_hovered == 1.
    
    // Main body of gravestone
    /draw_rect/(icon_x + 1)/(icon_y + 4)/10/10/stone_r/stone_g/stone_b/255.
    // Rounded top (stepped rectangles)
    /draw_rect/(icon_x + 2)/(icon_y + 2)/8/2/stone_r/stone_g/stone_b/255.
    /draw_rect/(icon_x + 3)/(icon_y)/6/2/stone_r/stone_g/stone_b/255.
    
    // RIP text on gravestone (darker)
    rip_r := 60. rip_g := 60. rip_b := 70.
    /draw_rect/(icon_x + 3)/(icon_y + 6)/2/1/rip_r/rip_g/rip_b/255.
    /draw_rect/(icon_x + 6)/(icon_y + 6)/2/1/rip_r/rip_g/rip_b/255.
    /draw_rect/(icon_x + 4)/(icon_y + 8)/4/1/rip_r/rip_g/rip_b/255.
    
    // RESTART text
    txt_r := 180. txt_g := 180. txt_b := 180.
    txt_r = 255 when restart_btn_hovered == 1. txt_g = 200 when restart_btn_hovered == 1. txt_b = 200 when restart_btn_hovered == 1.
    /text_draw/(x + 26)/(y)/14/txt_r/txt_g/txt_b/"RESTART".
    
    // Handle click
    // Handle click
    just_pressed := /input_mouse_just_pressed/.
    /full_restart/ when just_pressed == 1 and restart_btn_hovered == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when just_pressed == 1 and restart_btn_hovered == 1.
<

#full_restart() >
    // Reset to floor 1 (but keep bank)
    turns = 0.
    
    // Stop bot and reset
    /bot_stop/.
    
    // Use existing restart_game function (generates new dungeon)
    /restart_game/.
    
    last_message = "Starting fresh from floor 1.".
<


COL_RED_R := 255.
COL_RED_G := 80.
COL_RED_B := 80.

#draw_entities() >
    map_offset_x := dungeon_x.
    map_offset_y := dungeon_y + 12.
    
    for i in 0..MAX_ENTITIES >
        active := entity_active[i].
        dying := entity_is_dying[i].
        
        // Skip inactive
        continue_loop := 0.
        continue_loop = 1 when active == 0.
        
        // Handle Dying Cleanup
        flash := entity_hit_flash[i].
        
        // If dying and flash done, remove
        // cleanup := dying * (1 - (flash > 0)). // dying AND flash <= 0
        is_flash_active := 0.
        is_flash_active = 1 when flash gt 0.
        cleanup := dying * (1 - is_flash_active).
        
        entity_active[i] = 0 when cleanup == 1.
        entity_is_dying[i] = 0 when cleanup == 1.
        
        // Don't draw if we just cleaned it up
        should_draw := active * (1 - cleanup).
        
        ex := entity_x[i].
        ey := entity_y[i].
        etype := entity_type[i].
        
        sx := map_offset_x + ex * TILE_W.
        sy := map_offset_y + ey * TILE_H.
        
        // Attack Animation Jitter
        att_time := entity_attack_timer[i].
        att_dx := entity_attack_dx[i] * 5.
        att_dy := entity_attack_dy[i] * 5.
        
        att_offset_x := 0.
        att_offset_y := 0.
        
        is_attacking := 0.
        is_attacking = 1 when att_time gt 0.
        
        // Use same triangle wave logic 0..5..0
        ramp_up := 10 - att_time.
        ramp_down := att_time.
        anim_val := ramp_up.
        anim_val = ramp_down when ramp_down lt ramp_up.
        
        att_offset_x = att_dx * anim_val / 5 when is_attacking == 1.
        att_offset_y = att_dy * anim_val / 5 when is_attacking == 1.
        
        sx = sx + att_offset_x.
        sy = sy + att_offset_y.
        
        // Decrement attack timer
        entity_attack_timer[i] = att_time - 1 when att_time gt 0 and should_draw == 1.
        
        // Color selection
        r := COL_RED_R.
        g := COL_RED_G.
        b := COL_RED_B.
        
        // Green for goblins?
        is_goblin := 0.
        is_goblin = 1 when etype == 103. // 'g'
        
        r = COL_GREEN_R when is_goblin == 1.
        g = COL_GREEN_G when is_goblin == 1.
        b = COL_GREEN_B when is_goblin == 1.
        
        // Hit Flash / Death Flash Override
        // Decrement flash if > 0
        entity_hit_flash[i] = flash - 1 when flash gt 0 and should_draw == 1.
        
        is_flashing := 0.
        is_flashing = 1 when flash gt 0.
        
        // Flash Color: White for hit, Red for Dying?
        // Let's just use White for Hit.
        // For Dying, maybe Flicker Red/White?
        // Let's stick to White Flash for impact.
        
        r = 255 when is_flashing == 1.
        g = 255 when is_flashing == 1.
        b = 255 when is_flashing == 1.
        
        // If dying, maybe Force Red?
        r = 255 when dying == 1 and is_flashing == 1.
        g = 50 when dying == 1 and is_flashing == 1.
        b = 50 when dying == 1 and is_flashing == 1.
        
        /text_char/sx/sy/TILE_H/r/g/b/etype when should_draw == 1.
    <
<

#draw_tombstone() >
   // Center on screen
   cx := dungeon_x + dungeon_w / 2.
   cy := dungeon_y + dungeon_h / 2.
   
   // Box dimensions
   w := 300.
   h := 220.
   x := cx - w / 2.
   y := cy - h / 2.
   
   // Draw background (Black box)
   /draw_rect/x/y/w/h/0/0/0/230.
   
   // Draw Border
   /draw_rect/x/y/w/2/255/255/255/255.      // Top
   /draw_rect/x/(y + h - 2)/w/2/255/255/255/255. // Bottom
   /draw_rect/x/y/2/h/255/255/255/255.      // Left
   /draw_rect/(x + w - 2)/y/2/h/255/255/255/255. // Right
   
   // Text
   ty := y + 20.
   /text_draw/(cx - 40)/ty/24/200/200/200/"R.I.P.".
   
   ty = ty + 40.
   /text_draw/(x + 40)/ty/16/255/255/255/"Here lies the Wizard".
   
   ty = ty + 30.
   streak := dungeon_level - 1.
   /text_draw/(x + 40)/ty/14/200/200/200/"Streak: ".
   /text_draw_int/(x + 110)/ty/14/255/200/100/streak.
   
   ty = ty + 20.
   bank_msg := "Bank: ".
   /text_draw/(x + 40)/ty/14/200/200/200/bank_msg.
   /text_draw_int/(x + 100)/ty/14/100/255/100/player_bank.
   
   // Two buttons side by side: RETRY (same dungeon) and RESTART (new dungeon)
   ty = ty + 35.
   btn_spacing := 10.
   btn_w := 120.
   total_w := btn_w * 2 + btn_spacing.
   btn_start_x := cx - total_w / 2.
   
   /draw_death_retry_button/btn_start_x/ty.
   /draw_death_restart_button/(btn_start_x + btn_w + btn_spacing)/ty.
<

// Death screen restart button (larger, centered)
death_btn_x := 0.
death_btn_y := 0.
death_btn_w := 120.
death_btn_h := 32.
death_btn_hovered := 0.

#draw_death_restart_button(x, y) >
    death_btn_x = x.
    death_btn_y = y.
    
    // Check hover
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    death_btn_hovered = 0.
    death_btn_hovered = 1 when mx ge x and mx lt x + death_btn_w and my ge y and my lt y + death_btn_h.
    
    // Button background
    bg_r := 60. bg_g := 30. bg_b := 30.
    bg_r = 100 when death_btn_hovered == 1. bg_g = 50 when death_btn_hovered == 1. bg_b = 50 when death_btn_hovered == 1.
    /draw_rect/x/y/death_btn_w/death_btn_h/bg_r/bg_g/bg_b/255.
    
    // Border
    border_r := 150. border_g := 80. border_b := 80.
    border_r = 255 when death_btn_hovered == 1. border_g = 120 when death_btn_hovered == 1. border_b = 120 when death_btn_hovered == 1.
    /draw_rect/x/y/death_btn_w/2/border_r/border_g/border_b/255.
    /draw_rect/x/(y + death_btn_h - 2)/death_btn_w/2/border_r/border_g/border_b/255.
    /draw_rect/x/y/2/death_btn_h/border_r/border_g/border_b/255.
    /draw_rect/(x + death_btn_w - 2)/y/2/death_btn_h/border_r/border_g/border_b/255.
    
    // Gravestone icon (larger for death screen)
    icon_x := x + 12.
    icon_y := y + 4.
    stone_r := 180. stone_g := 180. stone_b := 190.
    stone_r = 230 when death_btn_hovered == 1. stone_g = 230 when death_btn_hovered == 1. stone_b = 240 when death_btn_hovered == 1.
    
    // Main body of gravestone
    /draw_rect/(icon_x + 2)/(icon_y + 6)/14/16/stone_r/stone_g/stone_b/255.
    // Rounded top (stepped rectangles)
    /draw_rect/(icon_x + 3)/(icon_y + 3)/12/3/stone_r/stone_g/stone_b/255.
    /draw_rect/(icon_x + 5)/(icon_y)/8/3/stone_r/stone_g/stone_b/255.
    
    // RIP text on gravestone (darker)
    rip_r := 80. rip_g := 80. rip_b := 90.
    /draw_rect/(icon_x + 5)/(icon_y + 9)/3/2/rip_r/rip_g/rip_b/255.
    /draw_rect/(icon_x + 10)/(icon_y + 9)/3/2/rip_r/rip_g/rip_b/255.
    /draw_rect/(icon_x + 6)/(icon_y + 13)/6/2/rip_r/rip_g/rip_b/255.
    
    // RESTART text
    txt_r := 200. txt_g := 200. txt_b := 200.
    txt_r = 255 when death_btn_hovered == 1. txt_g = 255 when death_btn_hovered == 1. txt_b = 255 when death_btn_hovered == 1.
    /text_draw/(x + 38)/(y + 8)/14/txt_r/txt_g/txt_b/"RESTART".
    
    // Handle click - restart creates NEW dungeon
    // Handle click - restart creates NEW dungeon
    just_pressed := /input_mouse_just_pressed/.
    /full_restart/ when just_pressed == 1 and death_btn_hovered == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when just_pressed == 1 and death_btn_hovered == 1.
<

// Death screen retry button (same dungeon)
retry_btn_x := 0.
retry_btn_y := 0.
retry_btn_w := 120.
retry_btn_h := 32.
retry_btn_hovered := 0.

#draw_death_retry_button(x, y) >
    retry_btn_x = x.
    retry_btn_y = y.
    
    // Check hover
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    retry_btn_hovered = 0.
    retry_btn_hovered = 1 when mx ge x and mx lt x + retry_btn_w and my ge y and my lt y + retry_btn_h.
    
    // Button background (cyan-ish for retry)
    bg_r := 30. bg_g := 50. bg_b := 60.
    bg_r = 50 when retry_btn_hovered == 1. bg_g = 80 when retry_btn_hovered == 1. bg_b = 100 when retry_btn_hovered == 1.
    /draw_rect/x/y/retry_btn_w/retry_btn_h/bg_r/bg_g/bg_b/255.
    
    // Border
    border_r := 80. border_g := 150. border_b := 150.
    border_r = 120 when retry_btn_hovered == 1. border_g = 220 when retry_btn_hovered == 1. border_b = 255 when retry_btn_hovered == 1.
    /draw_rect/x/y/retry_btn_w/2/border_r/border_g/border_b/255.
    /draw_rect/x/(y + retry_btn_h - 2)/retry_btn_w/2/border_r/border_g/border_b/255.
    /draw_rect/x/y/2/retry_btn_h/border_r/border_g/border_b/255.
    /draw_rect/(x + retry_btn_w - 2)/y/2/retry_btn_h/border_r/border_g/border_b/255.
    
    // Retry icon (circular arrow)
    icon_x := x + 12.
    icon_y := y + 6.
    arrow_r := 150. arrow_g := 200. arrow_b := 200.
    arrow_r = 200 when retry_btn_hovered == 1. arrow_g = 255 when retry_btn_hovered == 1. arrow_b = 255 when retry_btn_hovered == 1.
    
    // Simple circular arrow shape
    /draw_rect/(icon_x + 4)/(icon_y)/10/3/arrow_r/arrow_g/arrow_b/255.
    /draw_rect/(icon_x + 12)/(icon_y + 3)/3/8/arrow_r/arrow_g/arrow_b/255.
    /draw_rect/(icon_x + 4)/(icon_y + 17)/10/3/arrow_r/arrow_g/arrow_b/255.
    /draw_rect/(icon_x)/(icon_y + 6)/3/8/arrow_r/arrow_g/arrow_b/255.
    // Arrow head
    /draw_rect/(icon_x + 10)/(icon_y - 2)/3/3/arrow_r/arrow_g/arrow_b/255.
    
    // RETRY text
    txt_r := 180. txt_g := 220. txt_b := 220.
    txt_r = 220 when retry_btn_hovered == 1. txt_g = 255 when retry_btn_hovered == 1. txt_b = 255 when retry_btn_hovered == 1.
    /text_draw/(x + 38)/(y + 8)/14/txt_r/txt_g/txt_b/"RETRY".
    
    // Handle click - retry keeps SAME dungeon
    // Handle click - retry keeps SAME dungeon
    just_pressed := /input_mouse_just_pressed/.
    /do_retry/ when just_pressed == 1 and retry_btn_hovered == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when just_pressed == 1 and retry_btn_hovered == 1.
<

#do_retry() >
    // Stop bot and reset
    /bot_stop/.
    
    // Use retry_game function (regenerates same dungeon)
    /retry_game/.
<
