// tech.nh - Tech tree system with 3 independent branches
// ============================================================================
// BRANCH 1: BUFF (Sword icon) - Player power upgrades
// BRANCH 2: DIFFICULTY (Grid icon) - Dungeon complexity + bonus rewards
// BRANCH 3: LANGUAGE (Code icon) - Language feature tutorials
// ============================================================================

// ============================================================================
// Upgrade IDs
// ============================================================================

// BUFF BRANCH (IDs 0-19)
// Main branch (interspersed stats + gold)
UPGRADE_BUFF_HP_1 := 0.           // +4 Max HP (Starting node)
UPGRADE_BUFF_STR_1 := 1.          // +1 Strength
UPGRADE_BUFF_GOLD_SPAWN := 2.     // Gold piles spawn in dungeon
UPGRADE_BUFF_AC_1 := 3.           // +1 AC
UPGRADE_BUFF_HP_2 := 4.           // +4 Max HP
UPGRADE_BUFF_GOLD_SPAWN_2 := 5.   // +Gold pile value
UPGRADE_BUFF_STR_2 := 6.          // +1 Strength
UPGRADE_BUFF_GOLD_DROP := 7.      // Enemies drop gold on death
UPGRADE_BUFF_AC_2 := 8.           // +1 AC
UPGRADE_BUFF_HP_3 := 9.           // +4 Max HP
UPGRADE_BUFF_GOLD_DROP_2 := 10.   // +Gold drop value
UPGRADE_BUFF_STR_3 := 11.         // +1 Strength
// Speed branch (separate)
UPGRADE_BUFF_SPEED_5 := 12.       // Max speed 5x
UPGRADE_BUFF_SPEED_10 := 13.      // Max speed 10x
UPGRADE_BUFF_SPEED_100 := 14.     // Max speed 100x
UPGRADE_BUFF_SPEED_1000 := 15.    // Max speed 1000x

// DIFFICULTY BRANCH (IDs 20-39)
// Branching tree with player choice!
UPGRADE_DIFF_STAIRS_RANDOM := 20. // Stairs in random position (START)
UPGRADE_DIFF_ROOM_2 := 21.        // +1 room per floor
UPGRADE_DIFF_VAR_SIZE := 22.      // Variable room sizes (left path)
UPGRADE_DIFF_KOBOLDS := 23.       // Enable kobold spawning (right path)
UPGRADE_DIFF_ROOM_3 := 24.        // +1 room per floor
UPGRADE_DIFF_GOBLINS := 25.       // Enable goblin spawning
UPGRADE_DIFF_MONSTER_2 := 26.     // +1 monster per floor (merge)
UPGRADE_DIFF_ROOM_4 := 27.        // +1 room per floor
UPGRADE_DIFF_MONSTER_3 := 28.     // +1 monster per floor
UPGRADE_DIFF_ROOM_MANY := 29.     // +1 room per floor

// LANGUAGE BRANCH (IDs 40-69) - Game-oriented order
// Row 0: Iteration First (starting point)
UPGRADE_LANG_FOR := 40.           // for i in 0..10 > < (START)
// Row 1: Decisions
UPGRADE_LANG_WHEN := 41.          // when / unless
UPGRADE_LANG_COMPARISON := 42.    // lt gt le ge == !=
// Row 2: Movement, State, Math
UPGRADE_LANG_CANMOVE := 43.       // /can_move/dx/dy (from When)
UPGRADE_LANG_VARIABLES := 44.     // x := value, x = value
UPGRADE_LANG_ARITHMETIC := 45.    // + - * / %
// Row 3: Code Organization
UPGRADE_LANG_FUNCTIONS := 46.     // #name() > < and /call/
// Row 4: Control Flow
UPGRADE_LANG_BREAK := 47.         // >> and ><
UPGRADE_LANG_RETURN := 48.        // << return
// Row 5: Advanced Loops
UPGRADE_LANG_LOOP := 49.          // loop > < (after break!)
// Row 6: Data Structures
UPGRADE_LANG_ARRAYS := 50.        // [1, 2, 3], arr[i]
UPGRADE_LANG_STRUCTS := 51.       // { x: 1 }, obj->field
UPGRADE_LANG_STRINGS := 52.       // "hello"
// Row 7: Advanced Syntax
UPGRADE_LANG_IFELSE := 53.        // a if cond else b
UPGRADE_LANG_PIPES := 54.         // x | /func/
UPGRADE_LANG_BLOCKWHEN := 55.     // > ... < when cond
// Row 8: Expert
UPGRADE_LANG_PATTERN := 56.       // val | > 0 => ... <
UPGRADE_LANG_LAMBDA := 57.        // \(x) => expr
// Vision APIs (branch from CanMove)
UPGRADE_LANG_SURROUNDINGS := 59.  // check_surroundings()
UPGRADE_LANG_SCAN := 60.          // scan_area(radius)
UPGRADE_LANG_PATHFIND := 61.      // pathfind_to(x, y) - from surroundings
UPGRADE_LANG_FIND := 62.          // find_nearest(type) - from pathfind
UPGRADE_LANG_ROOM := 63.          // get_room_info() - from scan
UPGRADE_LANG_FULLMAP := 64.       // full_map_scan() - from room

// Total upgrade count
UPGRADE_COUNT := 40.

// ============================================================================
// Upgrade State (0 = locked, 1 = unlocked)
// ============================================================================

upgrades := [].

#init_upgrades() >
    for i in 0..70 >
        upgrades[i] = 0.
    <
<

#has_upgrade(id) >
    << upgrades[id].
<

#unlock_upgrade(id) >
    upgrades[id] = 1.
    /recalc_dungeon_params/.
    /apply_buff_upgrades/.
    // Update bonus display immediately
    dngn_bonus = /calculate_floor_bonus/.
<

// ============================================================================
// Upgrade Costs
// ============================================================================

#get_upgrade_cost(id) >
    // BUFF BRANCH - exponentially scaling costs
    // Costs are consistent within each row tier
    // Row 0: Starting node
    << 30 when id == UPGRADE_BUFF_HP_1.
    // Row 1: First tier choices ($100)
    << 100 when id == UPGRADE_BUFF_STR_1.
    << 100 when id == UPGRADE_BUFF_GOLD_SPAWN.
    << 100 when id == UPGRADE_BUFF_SPEED_5.
    // Row 2: Second tier ($400)
    << 400 when id == UPGRADE_BUFF_AC_1.
    << 400 when id == UPGRADE_BUFF_GOLD_SPAWN_2.
    << 400 when id == UPGRADE_BUFF_SPEED_10.
    // Row 3: Third tier ($1,500 main, $10k speed)
    << 1500 when id == UPGRADE_BUFF_HP_2.
    << 10000 when id == UPGRADE_BUFF_SPEED_100.
    // Row 4: Fourth tier ($5,000 main, $100k speed)
    << 5000 when id == UPGRADE_BUFF_STR_2.
    << 5000 when id == UPGRADE_BUFF_GOLD_DROP.
    << 100000 when id == UPGRADE_BUFF_SPEED_1000.
    // Row 5: Fifth tier ($20,000)
    << 20000 when id == UPGRADE_BUFF_AC_2.
    << 20000 when id == UPGRADE_BUFF_GOLD_DROP_2.
    // Row 6: Sixth tier ($75,000)
    << 75000 when id == UPGRADE_BUFF_HP_3.
    // Row 7: Final tier ($250,000)
    << 250000 when id == UPGRADE_BUFF_STR_3.
    
    // DIFFICULTY BRANCH - exponential cost scaling
    << 25 when id == UPGRADE_DIFF_STAIRS_RANDOM.   // Row 0 - Start
    << 60 when id == UPGRADE_DIFF_VAR_SIZE.        // Row 1
    << 150 when id == UPGRADE_DIFF_ROOM_2.         // Row 2 left
    << 150 when id == UPGRADE_DIFF_KOBOLDS.        // Row 2 right
    << 400 when id == UPGRADE_DIFF_ROOM_3.         // Row 3 left
    << 400 when id == UPGRADE_DIFF_GOBLINS.        // Row 3 right
    << 1000 when id == UPGRADE_DIFF_MONSTER_2.     // Row 4 merge
    << 2500 when id == UPGRADE_DIFF_ROOM_4.        // Row 5 left
    << 2500 when id == UPGRADE_DIFF_MONSTER_3.     // Row 5 right
    << 6000 when id == UPGRADE_DIFF_ROOM_MANY.     // Row 6 merge
    
    // LANGUAGE BRANCH - knowledge costs gold (gentle scaling)
    // Row 0: Starting point ($10)
    << 10 when id == UPGRADE_LANG_FOR.
    // Row 1: Decisions ($20)
    << 20 when id == UPGRADE_LANG_WHEN.
    << 20 when id == UPGRADE_LANG_COMPARISON.
    // Row 2: Movement, State, Math ($35)
    << 35 when id == UPGRADE_LANG_CANMOVE.
    << 35 when id == UPGRADE_LANG_VARIABLES.
    << 35 when id == UPGRADE_LANG_ARITHMETIC.
    // Row 3: Code Organization ($60)
    << 60 when id == UPGRADE_LANG_FUNCTIONS.
    // Row 4: Control Flow ($90)
    << 90 when id == UPGRADE_LANG_BREAK.
    << 90 when id == UPGRADE_LANG_RETURN.
    // Row 5: Advanced Loops ($130)
    << 130 when id == UPGRADE_LANG_LOOP.
    // Row 6: Data ($180)
    << 180 when id == UPGRADE_LANG_ARRAYS.
    << 180 when id == UPGRADE_LANG_STRUCTS.
    << 180 when id == UPGRADE_LANG_STRINGS.
    // Row 7: Advanced ($250)
    << 250 when id == UPGRADE_LANG_IFELSE.
    << 250 when id == UPGRADE_LANG_PIPES.
    << 250 when id == UPGRADE_LANG_BLOCKWHEN.
    // Row 8: Expert ($350)
    << 350 when id == UPGRADE_LANG_PATTERN.
    << 350 when id == UPGRADE_LANG_LAMBDA.
    // Vision APIs (branch from Can Move)
    << 1000 when id == UPGRADE_LANG_SURROUNDINGS.
    << 1000 when id == UPGRADE_LANG_SCAN.
    // Vision Advanced ($2500-4000)
    << 2500 when id == UPGRADE_LANG_PATHFIND.
    << 4000 when id == UPGRADE_LANG_FIND.
    << 2500 when id == UPGRADE_LANG_ROOM.
    << 4000 when id == UPGRADE_LANG_FULLMAP.
    
    << 9999. // Unknown upgrade
<

// ============================================================================
// Upgrade Prerequisites
// ============================================================================

#can_unlock_upgrade(id) >
    // Already unlocked?
    has := /has_upgrade/id.
    << 0 when has == 1.
    
    // BUFF BRANCH - branching tree with choices!
    // Layout:
    //                  HP I (start)
    //                 /    \          \
    //            STR I    Gold Spawn   Speed 5x
    //              |         |            |
    //            AC I    Gold Spawn+   Speed 10x
    //               \      /              |
    //                HP II            Speed 100x
    //               /    \                |
    //          STR II   Gold Drops    Speed 1000x
    //             |         |
    //          AC II    Gold Drops+
    //              \      /
    //               HP III
    //                 |
    //              STR III
    
    // Row 0: HP I is the starting node (no prereqs)
    << 1 when id == UPGRADE_BUFF_HP_1.
    
    // Row 1: Three choices branch from HP I
    has_hp1 := /has_upgrade/UPGRADE_BUFF_HP_1.
    << has_hp1 when id == UPGRADE_BUFF_STR_1.
    << has_hp1 when id == UPGRADE_BUFF_GOLD_SPAWN.
    << has_hp1 when id == UPGRADE_BUFF_SPEED_5.
    
    // Row 2: Stats path continues, Gold path continues, Speed continues
    has_str1 := /has_upgrade/UPGRADE_BUFF_STR_1.
    << has_str1 when id == UPGRADE_BUFF_AC_1.
    
    has_gold_spawn := /has_upgrade/UPGRADE_BUFF_GOLD_SPAWN.
    << has_gold_spawn when id == UPGRADE_BUFF_GOLD_SPAWN_2.
    
    has_speed5 := /has_upgrade/UPGRADE_BUFF_SPEED_5.
    << has_speed5 when id == UPGRADE_BUFF_SPEED_10.
    
    // Row 3: HP II requires EITHER AC I OR Gold Spawn+ (merge point)
    has_ac1 := /has_upgrade/UPGRADE_BUFF_AC_1.
    has_gold_spawn2 := /has_upgrade/UPGRADE_BUFF_GOLD_SPAWN_2.
    has_tier2_choice := has_ac1 + has_gold_spawn2.
    << 1 when id == UPGRADE_BUFF_HP_2 and has_tier2_choice gt 0.
    
    has_speed10 := /has_upgrade/UPGRADE_BUFF_SPEED_10.
    << has_speed10 when id == UPGRADE_BUFF_SPEED_100.
    
    // Row 4: Two choices branch from HP II
    has_hp2 := /has_upgrade/UPGRADE_BUFF_HP_2.
    << has_hp2 when id == UPGRADE_BUFF_STR_2.
    << has_hp2 when id == UPGRADE_BUFF_GOLD_DROP.
    
    has_speed100 := /has_upgrade/UPGRADE_BUFF_SPEED_100.
    << has_speed100 when id == UPGRADE_BUFF_SPEED_1000.
    
    // Row 5: Stats path continues, Gold path continues
    has_str2 := /has_upgrade/UPGRADE_BUFF_STR_2.
    << has_str2 when id == UPGRADE_BUFF_AC_2.
    
    has_gold_drop := /has_upgrade/UPGRADE_BUFF_GOLD_DROP.
    << has_gold_drop when id == UPGRADE_BUFF_GOLD_DROP_2.
    
    // Row 6: HP III requires EITHER AC II OR Gold Drops+ (merge point)
    has_ac2 := /has_upgrade/UPGRADE_BUFF_AC_2.
    has_gold_drop2 := /has_upgrade/UPGRADE_BUFF_GOLD_DROP_2.
    has_tier3_choice := has_ac2 + has_gold_drop2.
    << 1 when id == UPGRADE_BUFF_HP_3 and has_tier3_choice gt 0.
    
    // Row 7: STR III needs HP III
    has_hp3 := /has_upgrade/UPGRADE_BUFF_HP_3.
    << has_hp3 when id == UPGRADE_BUFF_STR_3.
    
    // DIFFICULTY BRANCH - branching tree with choices
    // Layout:
    //         Rnd Stairs (start)
    //              |
    //          Var Size
    //           /    \
    //     +1 Room   Kobolds
    //        |          |
    //    +1 Room     Goblins
    //         \       /
    //       +1 Monster (merge)
    //          /     \
    //    +1 Room   +1 Monster
    //         \       /
    //        +1 Room (merge)
    
    // Row 0: Random Stairs is the starting node (no prereqs)
    << 1 when id == UPGRADE_DIFF_STAIRS_RANDOM.
    
    // Row 1: Var Size needs Random Stairs
    has_stairs := /has_upgrade/UPGRADE_DIFF_STAIRS_RANDOM.
    << has_stairs when id == UPGRADE_DIFF_VAR_SIZE.
    
    // Row 2: +1 Room (left) or Kobolds (right) need Var Size
    has_var := /has_upgrade/UPGRADE_DIFF_VAR_SIZE.
    << has_var when id == UPGRADE_DIFF_ROOM_2.
    << has_var when id == UPGRADE_DIFF_KOBOLDS.
    
    // Row 3: +1 Room needs previous +1 Room, Goblins needs Kobolds
    has_room2 := /has_upgrade/UPGRADE_DIFF_ROOM_2.
    has_kobolds := /has_upgrade/UPGRADE_DIFF_KOBOLDS.
    << has_room2 when id == UPGRADE_DIFF_ROOM_3.
    << has_kobolds when id == UPGRADE_DIFF_GOBLINS.
    
    // Row 4: +1 Monster needs EITHER +1 Room OR Goblins (merge point)
    has_room3 := /has_upgrade/UPGRADE_DIFF_ROOM_3.
    has_goblins := /has_upgrade/UPGRADE_DIFF_GOBLINS.
    has_tier3_diff := has_room3 + has_goblins.
    << 1 when id == UPGRADE_DIFF_MONSTER_2 and has_tier3_diff gt 0.
    
    // Row 5: +1 Room or +1 Monster need previous +1 Monster
    has_mon2 := /has_upgrade/UPGRADE_DIFF_MONSTER_2.
    << has_mon2 when id == UPGRADE_DIFF_ROOM_4.
    << has_mon2 when id == UPGRADE_DIFF_MONSTER_3.
    
    // Row 6: +1 Room needs EITHER +1 Room OR +1 Monster (merge point)
    has_room4 := /has_upgrade/UPGRADE_DIFF_ROOM_4.
    has_mon3 := /has_upgrade/UPGRADE_DIFF_MONSTER_3.
    has_tier5_diff := has_room4 + has_mon3.
    << 1 when id == UPGRADE_DIFF_ROOM_MANY and has_tier5_diff gt 0.
    
    // LANGUAGE BRANCH - game-oriented prerequisites
    // Tree layout:
    //                       FOR (start)
    //                      /     \
    //                   When    Comparison
    //                  /   \         |
    //            CanMove  Variables  Arithmetic
    //               |         \      /
    //           [Vision]    Functions (merge)
    //                       /        \
    //                   Break       Return
    //                      \        /
    //                     Loop (merge)
    //                    /    |    \
    //              Arrays Structs Strings
    //                    \    |    /
    //               IfElse  Pipes  BlockWhen
    //                     \   |   /
    //                  Pattern  Lambda
    
    // Row 0: FOR (no prereq - starting node)
    << 1 when id == UPGRADE_LANG_FOR.
    
    // Row 1: When and Comparison both need For
    has_for := /has_upgrade/UPGRADE_LANG_FOR.
    << has_for when id == UPGRADE_LANG_WHEN.
    << has_for when id == UPGRADE_LANG_COMPARISON.
    
    // Row 2: CanMove needs When, Variables needs When, Arithmetic needs Comparison
    has_when := /has_upgrade/UPGRADE_LANG_WHEN.
    has_comp := /has_upgrade/UPGRADE_LANG_COMPARISON.
    << has_when when id == UPGRADE_LANG_CANMOVE.
    << has_when when id == UPGRADE_LANG_VARIABLES.
    << has_comp when id == UPGRADE_LANG_ARITHMETIC.
    
    // Row 3: Functions needs Variables OR Arithmetic (merge)
    has_vars := /has_upgrade/UPGRADE_LANG_VARIABLES.
    has_arith := /has_upgrade/UPGRADE_LANG_ARITHMETIC.
    has_row2 := has_vars + has_arith.
    << 1 when id == UPGRADE_LANG_FUNCTIONS and has_row2 gt 0.
    
    // Row 4: Break and Return both need Functions
    has_funcs := /has_upgrade/UPGRADE_LANG_FUNCTIONS.
    << has_funcs when id == UPGRADE_LANG_BREAK.
    << has_funcs when id == UPGRADE_LANG_RETURN.
    
    // Row 5: Loop needs Break OR Return (merge) - infinite loops after break!
    has_break := /has_upgrade/UPGRADE_LANG_BREAK.
    has_ret := /has_upgrade/UPGRADE_LANG_RETURN.
    has_row4 := has_break + has_ret.
    << 1 when id == UPGRADE_LANG_LOOP and has_row4 gt 0.
    
    // Row 6: Data Structures (Arrays, Structs, Strings) need Loop
    has_loop := /has_upgrade/UPGRADE_LANG_LOOP.
    << has_loop when id == UPGRADE_LANG_ARRAYS.
    << has_loop when id == UPGRADE_LANG_STRUCTS.
    << has_loop when id == UPGRADE_LANG_STRINGS.
    
    // Row 7: Advanced (If-else, Pipes, Block-when) need ANY of row 6
    has_arrays := /has_upgrade/UPGRADE_LANG_ARRAYS.
    has_structs := /has_upgrade/UPGRADE_LANG_STRUCTS.
    has_strings := /has_upgrade/UPGRADE_LANG_STRINGS.
    has_row6 := has_arrays + has_structs + has_strings.
    << 1 when id == UPGRADE_LANG_IFELSE and has_row6 gt 0.
    << 1 when id == UPGRADE_LANG_PIPES and has_row6 gt 0.
    << 1 when id == UPGRADE_LANG_BLOCKWHEN and has_row6 gt 0.
    
    // Row 8: Expert (Pattern, Lambda) need ANY of row 7
    has_ifelse := /has_upgrade/UPGRADE_LANG_IFELSE.
    has_pipes := /has_upgrade/UPGRADE_LANG_PIPES.
    has_blockwhen := /has_upgrade/UPGRADE_LANG_BLOCKWHEN.
    has_row7 := has_ifelse + has_pipes + has_blockwhen.
    << 1 when id == UPGRADE_LANG_PATTERN and has_row7 gt 0.
    << 1 when id == UPGRADE_LANG_LAMBDA and has_row7 gt 0.
    
    // Vision APIs branch from Can Move
    has_canmove := /has_upgrade/UPGRADE_LANG_CANMOVE.
    << has_canmove when id == UPGRADE_LANG_SURROUNDINGS.
    << has_canmove when id == UPGRADE_LANG_SCAN.
    
    // Surroundings -> Pathfind -> Find
    has_surroundings := /has_upgrade/UPGRADE_LANG_SURROUNDINGS.
    << has_surroundings when id == UPGRADE_LANG_PATHFIND.
    
    has_pathfind := /has_upgrade/UPGRADE_LANG_PATHFIND.
    << has_pathfind when id == UPGRADE_LANG_FIND.
    
    // Scan -> Room -> FullMap
    has_scan := /has_upgrade/UPGRADE_LANG_SCAN.
    << has_scan when id == UPGRADE_LANG_ROOM.
    
    has_room := /has_upgrade/UPGRADE_LANG_ROOM.
    << has_room when id == UPGRADE_LANG_FULLMAP.
    
    << 0. // Unknown
<

#try_purchase_upgrade(id) >
    // Check can unlock
    can := /can_unlock_upgrade/id.
    << 0 when can == 0.
    
    // Check cost
    cost := /get_upgrade_cost/id.
    << 0 when player_bank lt cost.
    
    // Purchase!
    player_bank = player_bank - cost.
    /unlock_upgrade/id.
    
    // If it's a language upgrade, show the tutorial
    is_lang := 0.
    is_lang = 1 when id ge 40 and id lt 70.
    /show_language_tutorial/id when is_lang == 1.
    
    // If it's a speed upgrade, recalculate slider position
    is_speed := 0.
    is_speed = 1 when id == UPGRADE_BUFF_SPEED_5.
    is_speed = 1 when id == UPGRADE_BUFF_SPEED_10.
    is_speed = 1 when id == UPGRADE_BUFF_SPEED_100.
    is_speed = 1 when id == UPGRADE_BUFF_SPEED_1000.
    /recalc_slider_for_new_max/ when is_speed == 1.
    
    // Check for story message triggers
    /check_message_triggers/.
    
    << 1.
<

// ============================================================================
// Apply Buff Upgrades to Player
// ============================================================================

#apply_buff_upgrades() >
    // Calculate total HP bonus (+4 per tier)
    hp_bonus := 0.
    hp_bonus = hp_bonus + 4 when /has_upgrade/UPGRADE_BUFF_HP_1 == 1.
    hp_bonus = hp_bonus + 4 when /has_upgrade/UPGRADE_BUFF_HP_2 == 1.
    hp_bonus = hp_bonus + 4 when /has_upgrade/UPGRADE_BUFF_HP_3 == 1.
    
    // Base HP is 16
    player_max_hp = 16 + hp_bonus.
    
    // Strength bonus (+1 per tier)
    str_bonus := 0.
    str_bonus = str_bonus + 1 when /has_upgrade/UPGRADE_BUFF_STR_1 == 1.
    str_bonus = str_bonus + 1 when /has_upgrade/UPGRADE_BUFF_STR_2 == 1.
    str_bonus = str_bonus + 1 when /has_upgrade/UPGRADE_BUFF_STR_3 == 1.
    
    player_str = 18 + str_bonus.
    
    // AC bonus (+1 per tier, lower AC is better in Nethack-style)
    ac_bonus := 0.
    ac_bonus = ac_bonus - 1 when /has_upgrade/UPGRADE_BUFF_AC_1 == 1.
    ac_bonus = ac_bonus - 1 when /has_upgrade/UPGRADE_BUFF_AC_2 == 1.
    
    // Base AC is 4
    player_ac = 4 + ac_bonus.
<

// ============================================================================
// Derived Dungeon Parameters (computed from DIFFICULTY upgrades)
// ============================================================================

// These are read by the dungeon generator
dng_max_rooms := 1.
dng_min_room_size := 3.
dng_max_room_size := 3.
dng_stairs_random := 0.
dng_monster_count := 0.
dng_gold_enabled := 0.
// Monster types enabled
dng_kobolds_enabled := 0.
dng_goblins_enabled := 0.

// Bonus from difficulty upgrades (starts at 0, adds linearly)
dng_bonus_from_upgrades := 0.

#recalc_dungeon_params() >
    // Base values
    dng_max_rooms = 1.
    dng_min_room_size = 3.
    dng_max_room_size = 3.
    dng_stairs_random = 0.
    dng_monster_count = 0.
    dng_kobolds_enabled = 0.
    dng_goblins_enabled = 0.
    
    // Calculate bonus from upgrades (linear addition, starts at 0)
    bonus := 0.
    
    // Stairs placement (first upgrade)
    dng_stairs_random = 1 when /has_upgrade/UPGRADE_DIFF_STAIRS_RANDOM == 1.
    bonus = bonus + 1 when /has_upgrade/UPGRADE_DIFF_STAIRS_RANDOM == 1.
    
    // Room count from difficulty upgrades (additive +1 each)
    dng_max_rooms = dng_max_rooms + 1 when /has_upgrade/UPGRADE_DIFF_ROOM_2 == 1.
    bonus = bonus + 1 when /has_upgrade/UPGRADE_DIFF_ROOM_2 == 1.
    
    dng_max_rooms = dng_max_rooms + 1 when /has_upgrade/UPGRADE_DIFF_ROOM_3 == 1.
    bonus = bonus + 1 when /has_upgrade/UPGRADE_DIFF_ROOM_3 == 1.
    
    dng_max_rooms = dng_max_rooms + 1 when /has_upgrade/UPGRADE_DIFF_ROOM_4 == 1.
    bonus = bonus + 1 when /has_upgrade/UPGRADE_DIFF_ROOM_4 == 1.
    
    dng_max_rooms = dng_max_rooms + 1 when /has_upgrade/UPGRADE_DIFF_ROOM_MANY == 1.
    bonus = bonus + 2 when /has_upgrade/UPGRADE_DIFF_ROOM_MANY == 1.
    
    // Room size (with upgrade: 2-5 interior, meaning 4x4 to 7x7 total)
    dng_min_room_size = 2 when /has_upgrade/UPGRADE_DIFF_VAR_SIZE == 1.
    dng_max_room_size = 5 when /has_upgrade/UPGRADE_DIFF_VAR_SIZE == 1.
    bonus = bonus + 1 when /has_upgrade/UPGRADE_DIFF_VAR_SIZE == 1.
    
    // Monster types (Kobolds enables 1 monster, Goblins adds variety)
    dng_kobolds_enabled = 1 when /has_upgrade/UPGRADE_DIFF_KOBOLDS == 1.
    dng_monster_count = 1 when /has_upgrade/UPGRADE_DIFF_KOBOLDS == 1.
    bonus = bonus + 2 when /has_upgrade/UPGRADE_DIFF_KOBOLDS == 1.
    
    dng_goblins_enabled = 1 when /has_upgrade/UPGRADE_DIFF_GOBLINS == 1.
    bonus = bonus + 2 when /has_upgrade/UPGRADE_DIFF_GOBLINS == 1.
    
    // Monster count upgrades (additive +1 each)
    dng_monster_count = dng_monster_count + 1 when /has_upgrade/UPGRADE_DIFF_MONSTER_2 == 1.
    bonus = bonus + 2 when /has_upgrade/UPGRADE_DIFF_MONSTER_2 == 1.
    
    dng_monster_count = dng_monster_count + 1 when /has_upgrade/UPGRADE_DIFF_MONSTER_3 == 1.
    bonus = bonus + 2 when /has_upgrade/UPGRADE_DIFF_MONSTER_3 == 1.
    
    // Gold spawning (from BUFF branch)
    dng_gold_enabled = 0.
    dng_gold_enabled = 1 when /has_upgrade/UPGRADE_BUFF_GOLD_SPAWN == 1.
    
    dng_bonus_from_upgrades = bonus.
<

// ============================================================================
// Calculate floor bonus based on difficulty
// ============================================================================

#calculate_floor_bonus() >
    // Base bonus of 1 + linear bonus from difficulty upgrades
    // Starts at 1, increases only with difficulty upgrades
    bonus := 1 + dng_bonus_from_upgrades.
    << bonus.
<

// ============================================================================
// Upgrade Names (for UI)
// ============================================================================

#get_upgrade_name(id) >
    // BUFF - Main branch
    << "More HP I" when id == UPGRADE_BUFF_HP_1.
    << "Strength I" when id == UPGRADE_BUFF_STR_1.
    << "Gold Spawn" when id == UPGRADE_BUFF_GOLD_SPAWN.
    << "Armor I" when id == UPGRADE_BUFF_AC_1.
    << "More HP II" when id == UPGRADE_BUFF_HP_2.
    << "Gold Spawn+" when id == UPGRADE_BUFF_GOLD_SPAWN_2.
    << "Strength II" when id == UPGRADE_BUFF_STR_2.
    << "Gold Drops" when id == UPGRADE_BUFF_GOLD_DROP.
    << "Armor II" when id == UPGRADE_BUFF_AC_2.
    << "More HP III" when id == UPGRADE_BUFF_HP_3.
    << "Gold Drops+" when id == UPGRADE_BUFF_GOLD_DROP_2.
    << "Strength III" when id == UPGRADE_BUFF_STR_3.
    // BUFF - Speed branch
    << "Speed 5x" when id == UPGRADE_BUFF_SPEED_5.
    << "Speed 10x" when id == UPGRADE_BUFF_SPEED_10.
    << "Speed 100x" when id == UPGRADE_BUFF_SPEED_100.
    << "Speed 1000x" when id == UPGRADE_BUFF_SPEED_1000.
    
    // DIFFICULTY
    << "Rnd Stairs" when id == UPGRADE_DIFF_STAIRS_RANDOM.
    << "+1 Room" when id == UPGRADE_DIFF_ROOM_2.
    << "Var Size" when id == UPGRADE_DIFF_VAR_SIZE.
    << "Kobolds" when id == UPGRADE_DIFF_KOBOLDS.
    << "+1 Room" when id == UPGRADE_DIFF_ROOM_3.
    << "Goblins" when id == UPGRADE_DIFF_GOBLINS.
    << "+1 Monster" when id == UPGRADE_DIFF_MONSTER_2.
    << "+1 Room" when id == UPGRADE_DIFF_ROOM_4.
    << "+1 Monster" when id == UPGRADE_DIFF_MONSTER_3.
    << "+1 Room" when id == UPGRADE_DIFF_ROOM_MANY.
    
    // LANGUAGE - Row 0 (Start)
    << "For Loop" when id == UPGRADE_LANG_FOR.
    // LANGUAGE - Row 1 (Decisions)
    << "When" when id == UPGRADE_LANG_WHEN.
    << "Compare" when id == UPGRADE_LANG_COMPARISON.
    // LANGUAGE - Row 2 (Movement, State, Math)
    << "Can Move" when id == UPGRADE_LANG_CANMOVE.
    << "Variables" when id == UPGRADE_LANG_VARIABLES.
    << "Math" when id == UPGRADE_LANG_ARITHMETIC.
    // LANGUAGE - Row 3 (Organization)
    << "Functions" when id == UPGRADE_LANG_FUNCTIONS.
    // LANGUAGE - Row 4 (Control Flow)
    << "Break" when id == UPGRADE_LANG_BREAK.
    << "Return" when id == UPGRADE_LANG_RETURN.
    // LANGUAGE - Row 5 (Advanced Loops)
    << "Loop" when id == UPGRADE_LANG_LOOP.
    // LANGUAGE - Tier 4 (Data)
    << "Arrays" when id == UPGRADE_LANG_ARRAYS.
    << "Structs" when id == UPGRADE_LANG_STRUCTS.
    << "Strings" when id == UPGRADE_LANG_STRINGS.
    // LANGUAGE - Tier 5 (Advanced)
    << "If-Else" when id == UPGRADE_LANG_IFELSE.
    << "Pipes" when id == UPGRADE_LANG_PIPES.
    << "Block ?" when id == UPGRADE_LANG_BLOCKWHEN.
    // LANGUAGE - Tier 6 (Expert)
    << "Match" when id == UPGRADE_LANG_PATTERN.
    << "Lambda" when id == UPGRADE_LANG_LAMBDA.
    // LANGUAGE - Vision APIs
    << "Surround" when id == UPGRADE_LANG_SURROUNDINGS.
    << "Scan" when id == UPGRADE_LANG_SCAN.
    // LANGUAGE - Tier 9 (Vision Advanced)
    << "Find" when id == UPGRADE_LANG_FIND.
    << "Room" when id == UPGRADE_LANG_ROOM.
    << "Pathfind" when id == UPGRADE_LANG_PATHFIND.
    << "Full Map" when id == UPGRADE_LANG_FULLMAP.
    
    << "Basics" when id == 99.

    << "???".
<

// ============================================================================
// Upgrade Descriptions (for UI)
// ============================================================================

#get_upgrade_desc(id) >
    // BUFF - Main branch
    << "+4 Maximum HP" when id == UPGRADE_BUFF_HP_1.
    << "+1 Strength" when id == UPGRADE_BUFF_STR_1.
    << "Gold piles spawn" when id == UPGRADE_BUFF_GOLD_SPAWN.
    << "-1 AC (better)" when id == UPGRADE_BUFF_AC_1.
    << "+4 Maximum HP" when id == UPGRADE_BUFF_HP_2.
    << "2x gold pile value" when id == UPGRADE_BUFF_GOLD_SPAWN_2.
    << "+1 Strength" when id == UPGRADE_BUFF_STR_2.
    << "Enemies drop gold" when id == UPGRADE_BUFF_GOLD_DROP.
    << "-1 AC (better)" when id == UPGRADE_BUFF_AC_2.
    << "+4 Maximum HP" when id == UPGRADE_BUFF_HP_3.
    << "2x gold drop value" when id == UPGRADE_BUFF_GOLD_DROP_2.
    << "+1 Strength" when id == UPGRADE_BUFF_STR_3.
    // BUFF - Speed branch
    << "Max bot speed: 5x" when id == UPGRADE_BUFF_SPEED_5.
    << "Max bot speed: 10x" when id == UPGRADE_BUFF_SPEED_10.
    << "Max bot speed: 100x" when id == UPGRADE_BUFF_SPEED_100.
    << "Max bot speed: 1000x" when id == UPGRADE_BUFF_SPEED_1000.
    
    // DIFFICULTY
    << "Stairs in random spot (+$1)" when id == UPGRADE_DIFF_STAIRS_RANDOM.
    << "+1 room per floor (+$1)" when id == UPGRADE_DIFF_ROOM_2.
    << "Room size varies 3-7 (+$1)" when id == UPGRADE_DIFF_VAR_SIZE.
    << "Kobolds spawn (+$2)" when id == UPGRADE_DIFF_KOBOLDS.
    << "+1 room per floor (+$1)" when id == UPGRADE_DIFF_ROOM_3.
    << "Goblins spawn (+$2)" when id == UPGRADE_DIFF_GOBLINS.
    << "+1 monster per floor (+$2)" when id == UPGRADE_DIFF_MONSTER_2.
    << "+1 room per floor (+$1)" when id == UPGRADE_DIFF_ROOM_4.
    << "+1 monster per floor (+$2)" when id == UPGRADE_DIFF_MONSTER_3.
    << "+1 room per floor (+$2)" when id == UPGRADE_DIFF_ROOM_MANY.
    
    // LANGUAGE - describe purpose, not syntax!
    // Row 0: Start
    << "Try each direction!" when id == UPGRADE_LANG_FOR.
    // Row 1: Decisions
    << "Do when condition met" when id == UPGRADE_LANG_WHEN.
    << "Compare values" when id == UPGRADE_LANG_COMPARISON.
    // Row 2: Movement, State, Math
    << "Check valid moves" when id == UPGRADE_LANG_CANMOVE.
    << "Store values for later" when id == UPGRADE_LANG_VARIABLES.
    << "Do math calculations" when id == UPGRADE_LANG_ARITHMETIC.
    // Row 3: Organization
    << "Reusable code blocks" when id == UPGRADE_LANG_FUNCTIONS.
    // Row 4: Control Flow
    << "Exit loops early" when id == UPGRADE_LANG_BREAK.
    << "Output from functions" when id == UPGRADE_LANG_RETURN.
    // Row 5: Advanced Loops
    << "Repeat until break" when id == UPGRADE_LANG_LOOP.
    // LANGUAGE - Tier 4
    << "Ordered collections" when id == UPGRADE_LANG_ARRAYS.
    << "Group related data" when id == UPGRADE_LANG_STRUCTS.
    << "Text and messages" when id == UPGRADE_LANG_STRINGS.
    // LANGUAGE - Tier 5
    << "Inline conditionals" when id == UPGRADE_LANG_IFELSE.
    << "Chain operations" when id == UPGRADE_LANG_PIPES.
    << "Multi-line conditions" when id == UPGRADE_LANG_BLOCKWHEN.
    // LANGUAGE - Tier 6
    << "Match value patterns" when id == UPGRADE_LANG_PATTERN.
    << "Anonymous functions" when id == UPGRADE_LANG_LAMBDA.
    // LANGUAGE - Vision APIs
    << "See 3x3 around you" when id == UPGRADE_LANG_SURROUNDINGS.
    << "Scan variable radius" when id == UPGRADE_LANG_SCAN.
    // LANGUAGE - Tier 9 (Vision Advanced)
    << "Locate nearest target" when id == UPGRADE_LANG_FIND.
    << "Current room bounds" when id == UPGRADE_LANG_ROOM.
    << "Navigate to a point" when id == UPGRADE_LANG_PATHFIND.
    << "See entire map" when id == UPGRADE_LANG_FULLMAP.
    
    << "".
<

// ============================================================================
// Language Tutorial System (Expanded with more content)
// ============================================================================

tutorial_active := 0.
tutorial_upgrade_id := 0.
tutorial_title := "".
tutorial_line_1 := "".
tutorial_line_2 := "".
tutorial_line_3 := "".
tutorial_line_4 := "".
tutorial_line_5 := "".
tutorial_line_6 := "".
tutorial_code_1 := "".
tutorial_code_2 := "".
tutorial_code_3 := "".
tutorial_code_4 := "".
tutorial_tip := "".

#show_language_tutorial(id) >
    tutorial_active = 1.
    tutorial_upgrade_id = id.
    
    // Set tutorial content based on upgrade
    /set_tutorial_variables/ when id == UPGRADE_LANG_VARIABLES.
    /set_tutorial_arithmetic/ when id == UPGRADE_LANG_ARITHMETIC.
    /set_tutorial_comparison/ when id == UPGRADE_LANG_COMPARISON.
    /set_tutorial_functions/ when id == UPGRADE_LANG_FUNCTIONS.
    /set_tutorial_return/ when id == UPGRADE_LANG_RETURN.
    /set_tutorial_when/ when id == UPGRADE_LANG_WHEN.
    /set_tutorial_canmove/ when id == UPGRADE_LANG_CANMOVE.
    /set_tutorial_loop/ when id == UPGRADE_LANG_LOOP.
    /set_tutorial_for/ when id == UPGRADE_LANG_FOR.
    /set_tutorial_break/ when id == UPGRADE_LANG_BREAK.
    /set_tutorial_arrays/ when id == UPGRADE_LANG_ARRAYS.
    /set_tutorial_structs/ when id == UPGRADE_LANG_STRUCTS.
    /set_tutorial_strings/ when id == UPGRADE_LANG_STRINGS.
    /set_tutorial_ifelse/ when id == UPGRADE_LANG_IFELSE.
    /set_tutorial_pipes/ when id == UPGRADE_LANG_PIPES.
    /set_tutorial_blockwhen/ when id == UPGRADE_LANG_BLOCKWHEN.
    /set_tutorial_patterns/ when id == UPGRADE_LANG_PATTERN.
    /set_tutorial_lambdas/ when id == UPGRADE_LANG_LAMBDA.
    // Vision APIs
    /set_tutorial_surroundings/ when id == UPGRADE_LANG_SURROUNDINGS.
    /set_tutorial_scan/ when id == UPGRADE_LANG_SCAN.
    /set_tutorial_find/ when id == UPGRADE_LANG_FIND.
    /set_tutorial_room/ when id == UPGRADE_LANG_ROOM.
    /set_tutorial_pathfind/ when id == UPGRADE_LANG_PATHFIND.
    /set_tutorial_fullmap/ when id == UPGRADE_LANG_FULLMAP.
<

#set_tutorial_variables() >
    tutorial_title = "VARIABLES".
    tutorial_line_1 = "Variables store values for later use.".
    tutorial_line_2 = "Use := to declare a NEW variable.".
    tutorial_line_3 = "Use = to assign to EXISTING variable.".
    tutorial_line_4 = "All statements end with a period (.)".
    tutorial_line_5 = "Variable names can use letters, numbers,".
    tutorial_line_6 = "and underscores. Start with letter.".
    tutorial_code_1 = "hp := 100.        // declare".
    tutorial_code_2 = "hp = hp - 10.     // assign".
    tutorial_code_3 = "player_x := 5.".
    tutorial_code_4 = "MAX_HP := 100.    // constants".
    tutorial_tip = "TIP: Use UPPERCASE for constants".
<

#set_tutorial_arithmetic() >
    tutorial_title = "ARITHMETIC".
    tutorial_line_1 = "Standard math operators work as expected.".
    tutorial_line_2 = "+ addition    - subtraction".
    tutorial_line_3 = "* multiply    / division".
    tutorial_line_4 = "% modulo (remainder after division)".
    tutorial_line_5 = "Use parentheses to control order.".
    tutorial_line_6 = "Floats use 'f' suffix: 3.14f".
    tutorial_code_1 = "sum := 5 + 3.     // 8".
    tutorial_code_2 = "diff := 10 - 4.   // 6".
    tutorial_code_3 = "prod := 6 * 7.    // 42".
    tutorial_code_4 = "rem := 17 % 5.    // 2".
    tutorial_tip = "TIP: Use () for complex expressions".
<

#set_tutorial_comparison() >
    tutorial_title = "COMPARISON".
    tutorial_line_1 = "Compare values using WORD operators.".
    tutorial_line_2 = "lt = less than    gt = greater than".
    tutorial_line_3 = "le = less or eq   ge = greater or eq".
    tutorial_line_4 = "== equals         != not equals".
    tutorial_line_5 = "Logic: and, or, not".
    tutorial_line_6 = "Returns 1 for true, 0 for false.".
    tutorial_code_1 = "is_low := hp lt 30.".
    tutorial_code_2 = "can_go := x gt 0 and x lt 10.".
    tutorial_code_3 = "alive := hp gt 0.".
    tutorial_code_4 = "same := a == b.".
    tutorial_tip = "TIP: 'not' negates: not (x == 0)".
<

#set_tutorial_functions() >
    tutorial_title = "FUNCTIONS".
    tutorial_line_1 = "Functions are defined with # prefix.".
    tutorial_line_2 = "Use > to enter the function body.".
    tutorial_line_3 = "Use < to exit the function body.".
    tutorial_line_4 = "Call functions with /name/args/".
    tutorial_line_5 = "Arguments are separated by /".
    tutorial_line_6 = "Like NetHack's extended commands!".
    tutorial_code_1 = "#greet(name) >".
    tutorial_code_2 = "    /print/name.".
    tutorial_code_3 = "<".
    tutorial_code_4 = "/greet/\"hero\".".
    tutorial_tip = "TIP: Think of / as wand casting!".
<

#set_tutorial_return() >
    tutorial_title = "RETURN".
    tutorial_line_1 = "Return a value from a function.".
    tutorial_line_2 = "Use << (like going up stairs!)".
    tutorial_line_3 = "Exits the function immediately.".
    tutorial_line_4 = "The value becomes the call result.".
    tutorial_line_5 = "Can have multiple return points.".
    tutorial_line_6 = "Early returns are great for guards!".
    tutorial_code_1 = "#double(x) > << x * 2. <".
    tutorial_code_2 = "#max(a, b) >".
    tutorial_code_3 = "    << a when a gt b.".
    tutorial_code_4 = "    << b. <".
    tutorial_tip = "TIP: << is like climbing stairs UP".
<

#set_tutorial_when() >
    tutorial_title = "WHEN / UNLESS".
    tutorial_line_1 = "Conditional execution, nh-style!".
    tutorial_line_2 = "Action comes FIRST, then condition.".
    tutorial_line_3 = "'when' runs if condition is true.".
    tutorial_line_4 = "'unless' runs if condition is false.".
    tutorial_line_5 = "Reads naturally: 'attack when ready'".
    tutorial_line_6 = "Works with any statement.".
    tutorial_code_1 = "/attack/ when hp gt 50.".
    tutorial_code_2 = "/flee/ unless cornered.".
    tutorial_code_3 = "x = 0 when reset == 1.".
    tutorial_code_4 = "<< 0 when done.".
    tutorial_tip = "TIP: Great for guard clauses!".
<

#set_tutorial_canmove() >
    tutorial_title = "CAN MOVE".
    tutorial_line_1 = "Check if movement is valid.".
    tutorial_line_2 = "/can_move/dx/dy returns 1 or 0.".
    tutorial_line_3 = "Same args as /move/dx/dy.".
    tutorial_line_4 = "Returns 1 if tile is walkable.".
    tutorial_line_5 = "Use to avoid walking into walls!".
    tutorial_line_6 = "Essential for smart bot movement.".
    tutorial_code_1 = "can := /can_move/0/-1.  // north?".
    tutorial_code_2 = "/move/0/-1 when can == 1.".
    tutorial_code_3 = "// Check before moving".
    tutorial_code_4 = "/move/1/0 when /can_move/1/0.".
    tutorial_tip = "TIP: Check before you move!".
<

#set_tutorial_loop() >
    tutorial_title = "LOOP".
    tutorial_line_1 = "Repeat code until you break out.".
    tutorial_line_2 = "loop > body < runs forever.".
    tutorial_line_3 = "Use >> to break out of the loop.".
    tutorial_line_4 = "Often combined with 'when'.".
    tutorial_line_5 = "Can also do: loop when cond > <".
    tutorial_line_6 = "This checks condition each iteration.".
    tutorial_code_1 = "loop >".
    tutorial_code_2 = "    /tick/.".
    tutorial_code_3 = "    >> when done.".
    tutorial_code_4 = "<".
    tutorial_tip = "TIP: >> is like bursting out!".
<

#set_tutorial_for() >
    tutorial_title = "FOR LOOPS".
    tutorial_line_1 = "Try each direction! Core of bot AI.".
    tutorial_line_2 = "for var in start..end > body <".
    tutorial_line_3 = "Range is [start, end) - end excluded!".
    tutorial_line_4 = "0..4 gives directions: N E S W".
    tutorial_line_5 = "Variable is scoped to the loop.".
    tutorial_line_6 = "This is your first building block!".
    tutorial_code_1 = "for i in 0..10 >".
    tutorial_code_2 = "    /print/i.".
    tutorial_code_3 = "<".
    tutorial_code_4 = "for j in 0..len > <".
    tutorial_tip = "TIP: 0..10 gives 0,1,2...9".
<

#set_tutorial_break() >
    tutorial_title = "BREAK & CONTINUE".
    tutorial_line_1 = "Control loop flow.".
    tutorial_line_2 = ">> breaks out of the loop entirely.".
    tutorial_line_3 = ">< continues to next iteration.".
    tutorial_line_4 = "Often combined with 'when'.".
    tutorial_line_5 = "Works in both loop and for.".
    tutorial_line_6 = "Think: >> exits, >< skips.".
    tutorial_code_1 = ">> when found == 1.".
    tutorial_code_2 = ">< when skip == 1.".
    tutorial_code_3 = "loop > >> when i gt 100. <".
    tutorial_code_4 = "".
    tutorial_tip = "TIP: >> out, >< around".
<

#set_tutorial_arrays() >
    tutorial_title = "ARRAYS".
    tutorial_line_1 = "Ordered collections of values.".
    tutorial_line_2 = "Create with [elem, elem, ...].".
    tutorial_line_3 = "Access with arr[index].".
    tutorial_line_4 = "Indices start at 0.".
    tutorial_line_5 = "Arrays can hold any values.".
    tutorial_line_6 = "Use for-in to iterate.".
    tutorial_code_1 = "nums := [1, 2, 3].".
    tutorial_code_2 = "first := nums[0].".
    tutorial_code_3 = "nums[1] = 99.".
    tutorial_code_4 = "empty := [].".
    tutorial_tip = "TIP: Great for pathfinding!".
<

#set_tutorial_structs() >
    tutorial_title = "STRUCTS".
    tutorial_line_1 = "Group related data together.".
    tutorial_line_2 = "Create with { key: value, ... }.".
    tutorial_line_3 = "Access fields with -> operator.".
    tutorial_line_4 = "Assign fields the same way.".
    tutorial_line_5 = "Fields can be any type.".
    tutorial_line_6 = "Perfect for game entities.".
    tutorial_code_1 = "hero := { hp: 100, x: 5 }.".
    tutorial_code_2 = "current := hero->hp.".
    tutorial_code_3 = "hero->hp = hero->hp - 10.".
    tutorial_code_4 = "hero->y = 3.".
    tutorial_tip = "TIP: Great for player/enemy state".
<

#set_tutorial_strings() >
    tutorial_title = "STRINGS".
    tutorial_line_1 = "Text values in double quotes.".
    tutorial_line_2 = "Used for messages and names.".
    tutorial_line_3 = "Can be stored in variables.".
    tutorial_line_4 = "Useful for debugging output.".
    tutorial_line_5 = "Escape with backslash.".
    tutorial_line_6 = "Works with /console_log/.".
    tutorial_code_1 = "msg := \"Hello!\".".
    tutorial_code_2 = "/console_log/msg.".
    tutorial_code_3 = "name := \"hero\".".
    tutorial_code_4 = "".
    tutorial_tip = "TIP: Use for debug messages".
<

#set_tutorial_ifelse() >
    tutorial_title = "IF-ELSE EXPRESSIONS".
    tutorial_line_1 = "Choose between two values inline.".
    tutorial_line_2 = "Syntax: value if cond else other".
    tutorial_line_3 = "This is an EXPRESSION, not statement!".
    tutorial_line_4 = "Returns one value or the other.".
    tutorial_line_5 = "Great for conditional assignment.".
    tutorial_line_6 = "Can be used anywhere values go.".
    tutorial_code_1 = "max := a if a gt b else b.".
    tutorial_code_2 = "bonus := 2 if crit else 1.".
    tutorial_code_3 = "dir := 1 if up else -1.".
    tutorial_code_4 = "".
    tutorial_tip = "TIP: value if cond else default".
<

#set_tutorial_pipes() >
    tutorial_title = "PIPES".
    tutorial_line_1 = "Chain operations elegantly.".
    tutorial_line_2 = "Value flows left to right with |".
    tutorial_line_3 = "Piped value becomes first argument.".
    tutorial_line_4 = "Can chain multiple operations.".
    tutorial_line_5 = "Makes data transformation readable.".
    tutorial_line_6 = "Works with functions and lambdas.".
    tutorial_code_1 = "5 | /double/.       // 10".
    tutorial_code_2 = "x | /add/1/ | /mul/2/.".
    tutorial_code_3 = "hp | /clamp/0/100/.".
    tutorial_code_4 = "".
    tutorial_tip = "TIP: Read left-to-right like Unix".
<

#set_tutorial_blockwhen() >
    tutorial_title = "BLOCK WHEN".
    tutorial_line_1 = "Apply condition to entire block.".
    tutorial_line_2 = "Wrap statements in > ... <".
    tutorial_line_3 = "Then add when condition after.".
    tutorial_line_4 = "All statements run or none.".
    tutorial_line_5 = "Cleaner than repeating condition.".
    tutorial_line_6 = "Great for multi-step actions.".
    tutorial_code_1 = ">".
    tutorial_code_2 = "    x = x + 1.".
    tutorial_code_3 = "    /update/.".
    tutorial_code_4 = "< when can_move == 1.".
    tutorial_tip = "TIP: Groups related actions".
<

#set_tutorial_patterns() >
    tutorial_title = "PATTERN MATCHING".
    tutorial_line_1 = "Match value against patterns.".
    tutorial_line_2 = "value | > pattern => result <".
    tutorial_line_3 = "Patterns are checked in order.".
    tutorial_line_4 = "_ is wildcard, matches anything.".
    tutorial_line_5 = "Inside _ => body, _ is the value!".
    tutorial_line_6 = "Like a switch on steroids.".
    tutorial_code_1 = "dir | >".
    tutorial_code_2 = "    0 => \"up\"".
    tutorial_code_3 = "    1 => \"down\"".
    tutorial_code_4 = "    _ => \"unknown\" <.".
    tutorial_tip = "TIP: Always end with _ catch-all".
<

#set_tutorial_lambdas() >
    tutorial_title = "LAMBDAS".
    tutorial_line_1 = "Anonymous inline functions.".
    tutorial_line_2 = "\\(params) => expression".
    tutorial_line_3 = "Perfect for piping operations.".
    tutorial_line_4 = "Can take multiple parameters.".
    tutorial_line_5 = "Can also have block body with > <".
    tutorial_line_6 = "Creates a closure over scope.".
    tutorial_code_1 = "\\(x) => x * 2.".
    tutorial_code_2 = "5 | \\(x) => x * x.   // 25".
    tutorial_code_3 = "\\(a, b) => a + b.".
    tutorial_code_4 = "".
    tutorial_tip = "TIP: \\ is like a tiny function".
<

#set_tutorial_surroundings() >
    tutorial_title = "CHECK SURROUNDINGS".
    tutorial_line_1 = "See the 3x3 area around you.".
    tutorial_line_2 = "Returns a 2D array of tiles.".
    tutorial_line_3 = "[row0, row1, row2] where each".
    tutorial_line_4 = "row is [left, center, right].".
    tutorial_line_5 = "Row 0 is above, row 2 is below.".
    tutorial_line_6 = "Returns tile chars: . # - | + $ > k g".
    tutorial_code_1 = "area := /check_surroundings/.".
    tutorial_code_2 = "above := area[0][1].  // N".
    tutorial_code_3 = "below := area[2][1].  // S".
    tutorial_code_4 = "left := area[1][0].   // W".
    tutorial_tip = "TIP: Use to detect enemies!".
<

#set_tutorial_scan() >
    tutorial_title = "SCAN AREA".
    tutorial_line_1 = "Extended vision with variable radius.".
    tutorial_line_2 = "Returns (2r+1) x (2r+1) grid.".
    tutorial_line_3 = "Radius is capped at 5.".
    tutorial_line_4 = "Center of grid is your position.".
    tutorial_line_5 = "Works like check_surroundings".
    tutorial_line_6 = "but with larger range.".
    tutorial_code_1 = "far := /scan_area/3.  // 7x7".
    tutorial_code_2 = "tile := far[3][3].    // center".
    tutorial_code_3 = "ne := far[0][6].      // far NE".
    tutorial_code_4 = "".
    tutorial_tip = "TIP: This lets you plan ahead!".
<

#set_tutorial_find() >
    tutorial_title = "FIND NEAREST".
    tutorial_line_1 = "Locate nearest entity/item.".
    tutorial_line_2 = "Pass type: monster, gold, stairs".
    tutorial_line_3 = "Also: kobold, goblin, door".
    tutorial_line_4 = "Returns {x, y, dist, type}".
    tutorial_line_5 = "or 0 if nothing found.".
    tutorial_line_6 = "Distance is Manhattan distance.".
    tutorial_code_1 = "e := /find_nearest/\"gold\".".
    tutorial_code_2 = "gx := e->x when e != 0.".
    tutorial_code_3 = "m := /find_nearest/\"monster\".".
    tutorial_code_4 = "d := m->dist when m != 0.".
    tutorial_tip = "TIP: Use this with pathfinding!".
<

#set_tutorial_room() >
    tutorial_title = "GET ROOM INFO".
    tutorial_line_1 = "Info about your current room.".
    tutorial_line_2 = "Returns {x, y, w, h, in_room}.".
    tutorial_line_3 = "x, y = room top-left corner.".
    tutorial_line_4 = "w, h = room width and height.".
    tutorial_line_5 = "in_room = 1 if in a room, 0 if".
    tutorial_line_6 = "in a corridor.".
    tutorial_code_1 = "r := /get_room_info/.".
    tutorial_code_2 = "in_room := r->in_room.".
    tutorial_code_3 = "cx := r->x + r->w / 2.".
    tutorial_code_4 = "cy := r->y + r->h / 2.".
    tutorial_tip = "TIP: Great for room navigation".
<

#set_tutorial_pathfind() >
    tutorial_title = "PATHFIND TO".
    tutorial_line_1 = "Get next move toward a target.".
    tutorial_line_2 = "Returns {dx, dy, found}.".
    tutorial_line_3 = "dx, dy = direction to move.".
    tutorial_line_4 = "found = 1 if path exists.".
    tutorial_line_5 = "Uses A* pathfinding algorithm.".
    tutorial_line_6 = "Avoids walls and monsters.".
    tutorial_code_1 = "p := /pathfind_to/10/5.".
    tutorial_code_2 = "/move/p->dx/p->dy when p->found.".
    tutorial_code_3 = "// Combine with find_nearest".
    tutorial_code_4 = "e := /find_nearest/\"stairs\".".
    tutorial_tip = "TIP: Move in the returned dir!".
<

#set_tutorial_fullmap() >
    tutorial_title = "FULL MAP SCAN".
    tutorial_line_1 = "Get the entire dungeon map.".
    tutorial_line_2 = "Returns 2D array of all tiles.".
    tutorial_line_3 = "Indexed as map[y][x].".
    tutorial_line_4 = "Expensive - use sparingly!".
    tutorial_line_5 = "Great for planning routes".
    tutorial_line_6 = "across the whole floor.".
    tutorial_code_1 = "m := /full_map_scan/.".
    tutorial_code_2 = "tile := m[5][10]. // y=5, x=10".
    tutorial_code_3 = "h := /list_len/m.     // height".
    tutorial_code_4 = "w := /list_len/m[0].  // width".
    tutorial_tip = "TIP: Cache the result!".
<

#close_tutorial() >
    tutorial_active = 0.
    tech_dragging = 0.
<

// ============================================================================
// Upgrade Branch Helpers
// ============================================================================

#get_upgrade_branch(id) >
    << 0 when id lt 20.   // BUFF
    << 1 when id lt 40.   // DIFFICULTY
    << 2 when id lt 70.   // LANGUAGE (now includes Vision APIs)
    << -1.                // Unknown
<

#get_branch_name(branch) >
    << "BUFFS" when branch == 0.
    << "DIFFICULTY" when branch == 1.
    << "LANGUAGE" when branch == 2.
    << "???".
<

// ============================================================================
// Heal on Stairs (called when descending) - ALWAYS ACTIVE
// ============================================================================

#apply_stair_heal() >
    // Stair heal is always on (no upgrade needed)
    player_hp = player_max_hp.
    << 1.
<

// ============================================================================
// Gold Drop on Kill (called when enemy dies)
// ============================================================================

#apply_gold_drop(x, y) >
    << 0 when /has_upgrade/UPGRADE_BUFF_GOLD_DROP == 0.
    // Base drop: 1-5 gold
    drop := /rng_int/5 + 1.
    // Gold Drops+ doubles the value
    drop = drop * 2 when /has_upgrade/UPGRADE_BUFF_GOLD_DROP_2 == 1.
    player_gold = player_gold + drop.
    /spawn_gold_particles/x/y.
    << drop.
<

// ============================================================================
// Gold Pile Value (based on upgrades)
// ============================================================================

#get_gold_pile_value() >
    // Base value: 1-4 gold
    value := /rng_int/4 + 1.
    // Gold Spawn+ doubles the value
    value = value * 2 when /has_upgrade/UPGRADE_BUFF_GOLD_SPAWN_2 == 1.
    << value.
<

// ============================================================================
// Max Speed (based on upgrades) - Used by slider
// ============================================================================

#get_max_speed() >
    // Base max speed is 3
    max := 3.
    
    // Each upgrade increases max speed
    max = 5 when /has_upgrade/UPGRADE_BUFF_SPEED_5 == 1.
    max = 10 when /has_upgrade/UPGRADE_BUFF_SPEED_10 == 1.
    max = 100 when /has_upgrade/UPGRADE_BUFF_SPEED_100 == 1.
    max = 1000 when /has_upgrade/UPGRADE_BUFF_SPEED_1000 == 1.
    
    << max.
<

