// ============================================================================
// Main Menu System
// ============================================================================

// Menu states
MENU_STATE_MAIN := 0.        // Main menu (New Game, Load, Settings)
MENU_STATE_LOAD := 1.        // Load game slot selection
MENU_STATE_SETTINGS := 2.    // Settings panel

menu_active := 1.            // Menu is active on game start
menu_state := 0.             // Current menu state
menu_hovered_button := -1.   // Which button is hovered (-1 = none)
menu_volume := 100.          // Volume level (0-100) - legacy, now master
menu_master_volume := 100.   // Master volume (0-100)
menu_music_volume := 100.    // Music volume (0-100)
menu_sfx_volume := 100.      // SFX volume (0-100)

// ============================================================================
// Menu Background - Scrolling Dungeons
// ============================================================================

// Grid of dungeons for seamless scrolling (2x2 grid = 4 dungeons)
MENU_DUNGEON_GRID := 2.      // 2x2 grid
MENU_DUNGEON_COUNT := 4.     // Total dungeons in grid

// Dungeon storage - each dungeon is MAP_WIDTH * MAP_HEIGHT
menu_dungeon_0 := [].
menu_dungeon_1 := [].
menu_dungeon_2 := [].
menu_dungeon_3 := [].

// Scroll state (pixels, kept in range [0, dungeon_size) for clean wrapping)
menu_scroll_x := 0.
menu_scroll_y := 0.

// Scroll speed (pixels per second) - very slow and relaxed
MENU_SCROLL_SPEED_X := 2.
MENU_SCROLL_SPEED_Y := 1.

// Scale factor for menu dungeon tiles (2x size)
MENU_TILE_SCALE := 2.

// Total size of one dungeon in pixels (calculated with scale)
menu_dungeon_pix_w := 0.
menu_dungeon_pix_h := 0.

// Special tile types for menu decorations (monsters as tiles)
MENU_TILE_KOBOLD := 100.
MENU_TILE_GOBLIN := 101.

// In-game pause popup
pause_popup_active := 0.     // Pause popup shown during gameplay
pause_popup_state := 0.      // 0 = main, 1 = settings, 2 = save slot picker
pause_popup_hovered := -1.   // Which button is hovered in popup

// Save slot info (populated from JS)
SAVE_SLOT_COUNT := 3.
save_slot_exists := [0, 0, 0].
save_slot_names := ["Empty Slot", "Empty Slot", "Empty Slot"].

// ============================================================================
// Menu Initialization
// ============================================================================

#init_menu() >
    menu_active = 1.
    menu_state = MENU_STATE_MAIN.
    menu_hovered_button = -1.
    
    // Load volume settings from storage
    stored_master := /js_get_setting/"master_volume".
    stored_music := /js_get_setting/"music_volume".
    stored_sfx := /js_get_setting/"sfx_volume".
    
    menu_master_volume = stored_master when stored_master gt 0.
    menu_master_volume = 100 when stored_master == 0.
    menu_music_volume = stored_music when stored_music gt 0.
    menu_music_volume = 100 when stored_music == 0.
    menu_sfx_volume = stored_sfx when stored_sfx gt 0.
    menu_sfx_volume = 100 when stored_sfx == 0.
    
    // Apply volume settings
    /js_set_master_volume/menu_master_volume.
    /js_set_music_volume/menu_music_volume.
    /js_set_sfx_volume/menu_sfx_volume.
    
    // Check save slots
    /refresh_save_slots/.
    
    // Initialize scrolling dungeon background
    /init_menu_dungeons/.
<

#refresh_save_slots() >
    for i in 0..SAVE_SLOT_COUNT >
        exists := /js_save_exists/i.
        save_slot_exists[i] = exists.
    <
<

// ============================================================================
// Menu Dungeon Background Generation
// ============================================================================

#init_menu_dungeons() >
    // Calculate pixel dimensions (with scale)
    menu_dungeon_pix_w = MAP_WIDTH * TILE_W * MENU_TILE_SCALE.
    menu_dungeon_pix_h = MAP_HEIGHT * TILE_H * MENU_TILE_SCALE.
    
    // Initialize scroll position
    menu_scroll_x = 0.
    menu_scroll_y = 0.
    
    // Generate 4 dungeons with max complexity
    /generate_menu_dungeon/0.
    /generate_menu_dungeon/1.
    /generate_menu_dungeon/2.
    /generate_menu_dungeon/3.
<

#generate_menu_dungeon(idx) >
    // Save current dungeon params
    old_max_rooms := dng_max_rooms.
    old_min_size := dng_min_room_size.
    old_max_size := dng_max_room_size.
    old_stairs := dng_stairs_random.
    old_monsters := dng_monster_count.
    old_kobolds := dng_kobolds_enabled.
    old_goblins := dng_goblins_enabled.
    old_gold := dng_gold_enabled.
    
    // Set max complexity for menu dungeons
    dng_max_rooms = 5.       // Many rooms
    dng_min_room_size = 2.
    dng_max_room_size = 5.   // Variable sizes (4x4 to 7x7)
    dng_stairs_random = 1.
    dng_monster_count = 0.   // No monsters in menu
    dng_kobolds_enabled = 0.
    dng_goblins_enabled = 0.
    dng_gold_enabled = 1.    // Gold piles for visual interest
    
    // Seed based on index for variety
    seed := /time_ms/ + idx * 12345.
    /rng_seed/seed.
    
    // Clear temporary dungeon storage
    size := MAP_WIDTH * MAP_HEIGHT.
    for i in 0..size >
        dungeon[i] = TILE_EMPTY.
    <
    
    // Reset room data
    room_count = 0.
    
    // Place rooms randomly
    target := dng_max_rooms.
    attempts := 0.
    max_attempts := target * 50.
    loop when room_count lt target >
        << 0 when attempts ge max_attempts.
        success := /try_place_random_room/.
        attempts = attempts + 1.
    <
    
    // Ensure at least 1 room
    /create_menu_fallback_room/ when room_count == 0.
    
    // Connect rooms with corridors
    /connect_rooms/.
    
    // Place stairs for visual interest
    /place_menu_stairs/.
    
    // Spawn gold
    /spawn_menu_gold/.
    
    // Spawn decorative monsters (visual only, stored as special tile values)
    /spawn_menu_monsters/.
    
    // Copy to appropriate menu dungeon array
    /copy_dungeon_to_menu/idx.
    
    // Restore original params
    dng_max_rooms = old_max_rooms.
    dng_min_room_size = old_min_size.
    dng_max_room_size = old_max_size.
    dng_stairs_random = old_stairs.
    dng_monster_count = old_monsters.
    dng_kobolds_enabled = old_kobolds.
    dng_goblins_enabled = old_goblins.
    dng_gold_enabled = old_gold.
<

#create_menu_fallback_room() >
    // Fallback room in center if random placement failed
    rw := dng_min_room_size + 2.
    rh := dng_min_room_size + 2.
    rx := MAP_WIDTH / 2 - rw / 2.
    ry := MAP_HEIGHT / 2 - rh / 2.
    
    /make_room/rx/ry/rw/rh.
    
    room_x[0] = rx.
    room_y[0] = ry.
    room_w[0] = rw.
    room_h[0] = rh.
    room_cx[0] = rx + rw / 2.
    room_cy[0] = ry + rh / 2.
    room_count = 1.
<

#place_menu_stairs() >
    // Put stairs in last room
    target := room_count - 1.
    target = 0 when target lt 0.
    
    trx := room_x[target].
    try := room_y[target].
    trw := room_w[target].
    trh := room_h[target].
    
    sx := trx + 1 + /rng_int/(trw - 2).
    sy := try + 1 + /rng_int/(trh - 2).
    
    /set_tile/sx/sy/TILE_STAIRS.
<

#spawn_menu_gold() >
    gold_count := room_count * 2.
    gold_count = 6 when gold_count lt 6.
    
    for k in 0..gold_count >
        target := /rng_int/room_count.
        
        trx := room_x[target].
        try := room_y[target].
        trw := room_w[target].
        trh := room_h[target].
        
        gx := trx + 1 + /rng_int/(trw - 2).
        gy := try + 1 + /rng_int/(trh - 2).
        
        tile := /get_tile/gx/gy.
        /set_tile/gx/gy/TILE_GOLD when tile == TILE_FLOOR.
    <
<

#spawn_menu_monsters() >
    // Spawn 2-4 monsters per dungeon for visual interest
    monster_count := 2 + /rng_int/3.
    
    << 0 when room_count == 0.
    
    for k in 0..monster_count >
        // Pick random room (prefer non-first room if available)
        target := /rng_int/room_count.
        target = 1 when target == 0 and room_count gt 1.
        
        trx := room_x[target].
        try := room_y[target].
        trw := room_w[target].
        trh := room_h[target].
        
        // Skip if room too small
        >< when trw lt 4.
        >< when trh lt 4.
        
        // Random position in interior
        mx := trx + 1 + /rng_int/(trw - 2).
        my := try + 1 + /rng_int/(trh - 2).
        
        tile := /get_tile/mx/my.
        
        // Only place on floor
        >< when tile != TILE_FLOOR.
        
        // Random monster type (kobold or goblin)
        mtype := MENU_TILE_KOBOLD.
        mtype = MENU_TILE_GOBLIN when /rng_int/2 == 1.
        
        /set_tile/mx/my/mtype.
    <
<

#copy_dungeon_to_menu(idx) >
    size := MAP_WIDTH * MAP_HEIGHT.
    
    for i in 0..size >
        tile := dungeon[i].
        menu_dungeon_0[i] = tile when idx == 0.
        menu_dungeon_1[i] = tile when idx == 1.
        menu_dungeon_2[i] = tile when idx == 2.
        menu_dungeon_3[i] = tile when idx == 3.
    <
<

#get_menu_tile(dungeon_idx, x, y) >
    << TILE_EMPTY when x lt 0.
    << TILE_EMPTY when y lt 0.
    << TILE_EMPTY when x ge MAP_WIDTH.
    << TILE_EMPTY when y ge MAP_HEIGHT.
    
    i := y * MAP_WIDTH + x.
    
    << menu_dungeon_0[i] when dungeon_idx == 0.
    << menu_dungeon_1[i] when dungeon_idx == 1.
    << menu_dungeon_2[i] when dungeon_idx == 2.
    << menu_dungeon_3[i] when dungeon_idx == 3.
    << TILE_EMPTY.
<

// ============================================================================
// Menu Update
// ============================================================================

#update_menu(dt) >
    << 0 when menu_active == 0.
    
    // Update scrolling background
    /update_menu_scroll/dt.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    just_pressed := /input_mouse_just_pressed/.
    
    // Capture state at start of frame to prevent multiple state updates in one frame
    current_state := menu_state.
    
    /update_menu_main/mx/my/just_pressed when current_state == MENU_STATE_MAIN.
    /update_menu_load/mx/my/just_pressed when current_state == MENU_STATE_LOAD.
    /update_menu_settings/mx/my/just_pressed when current_state == MENU_STATE_SETTINGS.
<

#update_menu_scroll(dt) >
    // Move up and to the left (scroll offset increases)
    // dt is in milliseconds - use integer math: speed * dt / 1000
    
    delta_x := MENU_SCROLL_SPEED_X * dt / 1000.
    delta_y := MENU_SCROLL_SPEED_Y * dt / 1000.
    
    // Ensure at least 1 pixel movement per frame for smooth scrolling
    delta_x = 1 when delta_x == 0 and dt gt 0.
    delta_y = 1 when delta_y == 0 and dt gt 0.
    
    // Increase scroll offset
    menu_scroll_x = menu_scroll_x + delta_x.
    menu_scroll_y = menu_scroll_y + delta_y.
    
    // Wrap at a very large value to prevent overflow
    // We use modulo in rendering so this won't cause visual discontinuity
    menu_scroll_x = menu_scroll_x - 10000000 when menu_scroll_x gt 10000000.
    menu_scroll_y = menu_scroll_y - 10000000 when menu_scroll_y gt 10000000.
<

#update_menu_main(mx, my, just_pressed) >
    // Button dimensions
    btn_w := 200.
    btn_h := 50.
    btn_x := (SCREEN_W - btn_w) / 2.
    btn_y_start := SCREEN_H / 2 - 60.
    btn_gap := 70.
    
    menu_hovered_button = -1.
    
    // Check New Game button
    new_y := btn_y_start.
    in_new := mx ge btn_x and mx lt btn_x + btn_w and my ge new_y and my lt new_y + btn_h.
    menu_hovered_button = 0 when in_new == 1.
    /menu_start_new_game/ when in_new == 1 and just_pressed == 1.
    
    // Check Load Game button
    load_y := btn_y_start + btn_gap.
    in_load := mx ge btn_x and mx lt btn_x + btn_w and my ge load_y and my lt load_y + btn_h.
    menu_hovered_button = 1 when in_load == 1.
    menu_state = MENU_STATE_LOAD when in_load == 1 and just_pressed == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when in_load == 1 and just_pressed == 1.
    
    // Check Settings button
    set_y := btn_y_start + btn_gap * 2.
    in_set := mx ge btn_x and mx lt btn_x + btn_w and my ge set_y and my lt set_y + btn_h.
    menu_hovered_button = 2 when in_set == 1.
    menu_state = MENU_STATE_SETTINGS when in_set == 1 and just_pressed == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when in_set == 1 and just_pressed == 1.
<

#menu_start_new_game() >
    /play_sound_wrapper/SOUND_UI_START.
    /js_muffle_music/.
    menu_active = 0.
    
    // Stop any running bot
    /bot_stop/.
    
    // Reset all upgrades to start fresh
    /init_upgrades/.
    
    // Reset player stats for new game
    player_hp = player_max_hp.
    player_gold = 0.
    player_bank = 0.
    dungeon_level = 1.
    player_xp_points = 0.
    player_xp_level = 1.
    player_is_dead = 0.
    turns = 0.
    
    // Generate fresh dungeon with base params (upgrades are now 0)
    /generate_dungeon/.
    dngn_bonus = /calculate_floor_bonus/.
    
    // Mark as new game so tutorial auto-starts
    ui_tut_is_new_game = 1.
    ui_tut_has_shown = 0.  // Reset so tutorial shows on each new game
    
    // Fully initialize intro state (clears old state from previous plays)
    /init_editor/.
    /init_intro/.
<

#update_menu_load(mx, my, just_pressed) >
    // Back button
    back_x := 50.
    back_y := SCREEN_H - 80.
    back_w := 100.
    back_h := 40.
    
    in_back := mx ge back_x and mx lt back_x + back_w and my ge back_y and my lt back_y + back_h.
    menu_hovered_button = 10 when in_back == 1.
    menu_state = MENU_STATE_MAIN when in_back == 1 and just_pressed == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when in_back == 1 and just_pressed == 1.
    
    // Save slot buttons
    slot_w := 300.
    slot_h := 60.
    slot_x := (SCREEN_W - slot_w) / 2.
    slot_y_start := SCREEN_H / 2 - 100.
    slot_gap := 80.
    
    for i in 0..SAVE_SLOT_COUNT >
        slot_y := slot_y_start + i * slot_gap.
        in_slot := mx ge slot_x and mx lt slot_x + slot_w and my ge slot_y and my lt slot_y + slot_h.
        menu_hovered_button = 20 + i when in_slot == 1.
        /menu_load_slot/i when in_slot == 1 and just_pressed == 1 and save_slot_exists[i] == 1.
    <
<

#menu_load_slot(slot) >
    /play_sound_wrapper/SOUND_UI_START.
    
    // Load game data from JS
    /js_load_game/slot.
    
    // Start CRT transition
    menu_active = 0.
    intro_active = 1.
    /start_boot_wait/.
<

#update_menu_settings(mx, my, just_pressed) >
    mouse_down := /input_mouse_down/.
    
    // Back button
    back_x := 50.
    back_y := SCREEN_H - 80.
    back_w := 100.
    back_h := 40.
    
    in_back := mx ge back_x and mx lt back_x + back_w and my ge back_y and my lt back_y + back_h.
    menu_hovered_button = 10 when in_back == 1.
    menu_state = MENU_STATE_MAIN when in_back == 1 and just_pressed == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when in_back == 1 and just_pressed == 1.
    /js_set_setting/"master_volume"/menu_master_volume when in_back == 1 and just_pressed == 1.
    /js_set_setting/"music_volume"/menu_music_volume when in_back == 1 and just_pressed == 1.
    /js_set_setting/"sfx_volume"/menu_sfx_volume when in_back == 1 and just_pressed == 1.
    
    // Slider dimensions
    slider_x := (SCREEN_W - 300) / 2.
    slider_w := 300.
    slider_h := 20.
    
    // Master Volume slider
    master_y := SCREEN_H / 2 - 60.
    in_master := mx ge slider_x and mx lt slider_x + slider_w and my ge master_y - 10 and my lt master_y + slider_h + 10.
    drag_master := in_master * mouse_down.
    new_master := 0.
    new_master = (mx - slider_x) * 100 / slider_w when drag_master == 1.
    new_master = 0 when new_master lt 0.
    new_master = 100 when new_master gt 100.
    menu_master_volume = new_master when drag_master == 1.
    /js_set_master_volume/menu_master_volume when drag_master == 1.
    
    // Music Volume slider
    music_y := SCREEN_H / 2.
    in_music := mx ge slider_x and mx lt slider_x + slider_w and my ge music_y - 10 and my lt music_y + slider_h + 10.
    drag_music := in_music * mouse_down.
    new_music := 0.
    new_music = (mx - slider_x) * 100 / slider_w when drag_music == 1.
    new_music = 0 when new_music lt 0.
    new_music = 100 when new_music gt 100.
    menu_music_volume = new_music when drag_music == 1.
    /js_set_music_volume/menu_music_volume when drag_music == 1.
    
    // SFX Volume slider
    sfx_y := SCREEN_H / 2 + 60.
    in_sfx := mx ge slider_x and mx lt slider_x + slider_w and my ge sfx_y - 10 and my lt sfx_y + slider_h + 10.
    drag_sfx := in_sfx * mouse_down.
    new_sfx := 0.
    new_sfx = (mx - slider_x) * 100 / slider_w when drag_sfx == 1.
    new_sfx = 0 when new_sfx lt 0.
    new_sfx = 100 when new_sfx gt 100.
    menu_sfx_volume = new_sfx when drag_sfx == 1.
    /js_set_sfx_volume/menu_sfx_volume when drag_sfx == 1.
<

// ============================================================================
// Menu Rendering
// ============================================================================

#render_menu() >
    << 0 when menu_active == 0.
    
    // Enable CRT effects for menu (classic terminal look)
    /set_skip_crt/0.
    
    // Draw scrolling dungeon background
    /render_menu_dungeon_bg/.
    
    /render_menu_main/ when menu_state == MENU_STATE_MAIN.
    /render_menu_load/ when menu_state == MENU_STATE_LOAD.
    /render_menu_settings/ when menu_state == MENU_STATE_SETTINGS.
<

// ============================================================================
// Menu Dungeon Background Rendering
// ============================================================================

#render_menu_dungeon_bg() >
    // Draw dark background first
    /draw_rect/0/0/SCREEN_W/SCREEN_H/5/5/8/255.
    
    // Dungeon size in pixels
    dw := menu_dungeon_pix_w.
    dh := menu_dungeon_pix_h.
    
    // Use modulo to get offset within one dungeon (seamless wrapping)
    offset_x := menu_scroll_x % dw.
    offset_y := menu_scroll_y % dh.
    
    // Which world tile is at top-left (for dungeon pattern selection)
    world_base_x := menu_scroll_x / dw.
    world_base_y := menu_scroll_y / dh.
    
    // How many dungeon copies needed to fill screen (plus 1 for partial visibility)
    copies_x := SCREEN_W / dw + 2.
    copies_y := SCREEN_H / dh + 2.
    
    // Draw grid of dungeon copies
    for cy in 0..copies_y >
        for cx in 0..copies_x >
            // World tile coordinates (for consistent dungeon selection)
            world_tx := world_base_x + cx.
            world_ty := world_base_y + cy.
            
            // Which dungeon to use (alternating 2x2 pattern based on WORLD position)
            dng_idx := (world_tx % 2) + (world_ty % 2) * 2.
            
            // Screen position of this dungeon copy
            px := cx * dw - offset_x.
            py := cy * dh - offset_y.
            
            // Only draw if it overlaps the screen
            visible := 1.
            visible = 0 when px + dw lt 0.
            visible = 0 when py + dh lt 0.
            visible = 0 when px gt SCREEN_W.
            visible = 0 when py gt SCREEN_H.
            
            /draw_menu_dungeon_copy/dng_idx/px/py when visible == 1.
        <
    <
<

#draw_menu_dungeon_copy(dng_idx, offset_x, offset_y) >
    // Draw all tiles of a dungeon at the given offset
    // Dimmed colors for background effect
    // Uses scaled tile size for larger appearance
    
    scaled_tw := TILE_W * MENU_TILE_SCALE.
    scaled_th := TILE_H * MENU_TILE_SCALE.
    
    for ty in 0..MAP_HEIGHT >
        for tx in 0..MAP_WIDTH >
            tile := /get_menu_tile/dng_idx/tx/ty.
            
            sx := offset_x + tx * scaled_tw.
            sy := offset_y + ty * scaled_th.
            
            // Skip if off screen (with margin for scaled size)
            >< when sx lt 0 - scaled_tw.
            >< when sy lt 0 - scaled_th.
            >< when sx gt SCREEN_W.
            >< when sy gt SCREEN_H.
            
            // Draw empty tiles as very dim dots for texture
            /draw_menu_empty_tile/sx/sy/scaled_th/tx/ty when tile == TILE_EMPTY.
            
            // Draw other tiles with dimmed colors at scaled size
            /draw_menu_tile/tile/sx/sy/scaled_th when tile != TILE_EMPTY.
        <
    <
<

#draw_menu_empty_tile(sx, sy, size, tx, ty) >
    // Very sparse dim dots for empty areas - creates subtle texture
    // Only draw on a checkerboard pattern for subtle effect
    checker := (tx + ty) % 4.
    /text_char/sx/sy/size/15/15/18/46 when checker == 0.  // '.' char (46)
<

#draw_menu_tile(tile, sx, sy, size) >
    // Dimmed versions of tile colors for background effect
    // About 30-40% brightness for subtle background
    
    // Floor - very dim gray
    /text_char/sx/sy/size/50/50/55/CHAR_FLOOR when tile == TILE_FLOOR.
    
    // Walls - dim brown
    /text_char/sx/sy/size/55/30/15/CHAR_WALL_H when tile == TILE_WALL_H.
    /text_char/sx/sy/size/55/30/15/CHAR_WALL_V when tile == TILE_WALL_V.
    
    // Corridor - dim gray
    /text_char/sx/sy/size/45/45/50/CHAR_CORRIDOR when tile == TILE_CORRIDOR.
    
    // Door - dim brown
    /text_char/sx/sy/size/55/30/15/CHAR_DOOR when tile == TILE_DOOR.
    
    // Stairs - dim cyan
    /text_char/sx/sy/size/0/60/65/CHAR_STAIRS_DOWN when tile == TILE_STAIRS.
    
    // Gold - dim yellow
    /text_char/sx/sy/size/70/70/0/CHAR_GOLD when tile == TILE_GOLD.
    
    // Monsters - dim red/green
    // Kobold 'k' (107) - dim red
    /text_char/sx/sy/size/80/30/30/107 when tile == MENU_TILE_KOBOLD.
    
    // Goblin 'g' (103) - dim green
    /text_char/sx/sy/size/40/70/40/103 when tile == MENU_TILE_GOBLIN.
<

#render_menu_bg() >
    count := /js_get_menu_art_count/.
    
    // Font settings to fit width (187 chars * 4.2px = 785px)
    // Height will overflow (139 * 6 = 834px), centered clipping top/bottom
    font_size := 7.
    line_h := 6. 
    font_id := 2. // Monospace
    
    // Width ~785px
    start_x := (SCREEN_W - 785) / 2.
    
    // Center vertically
    total_h := count * line_h.
    start_y := (SCREEN_H - total_h) / 2.
    
    // Color (dimmed dark gray for background)
    r := 40. g := 40. b := 40.
    
    for i in 0..count >
        line := /js_get_menu_art_line/i.
        y := start_y + i * line_h.
        /text_draw_font/start_x/y/font_size/r/g/b/font_id/line.
    <
<

#render_menu_main() >
    // /render_menu_bg/.
    
    // Title
    // Logo
    // Icon: centered, text: right of center?
    // Actually, image shows Icon LEFT and Text RIGHT.
    // Let's center the whole group.
    
    // Logo Text "yendor" (centered)
    lr := 255. lg := 255. lb := 255.
    
    label := "yendor".
    sz := 48.
    
    // Center it
    text_width := /text_measure/label/sz.
    tx := (SCREEN_W - text_width) / 2.
    ty := 135.
    
    /text_draw_font/tx/ty/sz/lr/lg/lb/2/label.
    
    btn_w := 200.
    btn_h := 50.
    btn_x := (SCREEN_W - btn_w) / 2.
    btn_y_start := SCREEN_H / 2 - 60.
    btn_gap := 70.
    
    // New Game button
    new_y := btn_y_start.
    new_hover := menu_hovered_button == 0.
    /draw_menu_button/btn_x/new_y/btn_w/btn_h/"New Game"/new_hover.
    
    // Load Game button
    load_y := btn_y_start + btn_gap.
    load_hover := menu_hovered_button == 1.
    /draw_menu_button/btn_x/load_y/btn_w/btn_h/"Load Game"/load_hover.
    
    // Settings button
    set_y := btn_y_start + btn_gap * 2.
    set_hover := menu_hovered_button == 2.
    /draw_menu_button/btn_x/set_y/btn_w/btn_h/"Settings"/set_hover.
<

#render_menu_load() >
    // Title - centered
    load_title := "Load Game".
    title_width := /text_measure/load_title/24.
    title_x := (SCREEN_W - title_width) / 2.
    title_y := 180.
    /text_draw_font/title_x/title_y/24/180/160/120/0/load_title.
    
    // Save slots
    slot_w := 300.
    slot_h := 60.
    slot_x := (SCREEN_W - slot_w) / 2.
    slot_y_start := SCREEN_H / 2 - 100.
    slot_gap := 80.
    
    for i in 0..SAVE_SLOT_COUNT >
        slot_y := slot_y_start + i * slot_gap.
        slot_hover := menu_hovered_button == 20 + i.
        exists := save_slot_exists[i].
        
        // Draw slot button
        r := 40. g := 45. b := 55.
        r = 60 when slot_hover == 1. g = 70 when slot_hover == 1. b = 85 when slot_hover == 1.
        r = 30 when exists == 0. g = 32 when exists == 0. b = 38 when exists == 0.
        /draw_rect/slot_x/slot_y/slot_w/slot_h/r/g/b/255.
        
        // Draw slot text
        text_x := slot_x + 20.
        text_y := slot_y + 20.
        tr := 200. tg := 200. tb := 200.
        tr = 100 when exists == 0. tg = 100 when exists == 0. tb = 100 when exists == 0.
        
        slot_num := i + 1.
        /text_draw/text_x/text_y/14/tr/tg/tb/"Slot".
        /text_draw_int/(text_x + 35)/text_y/14/tr/tg/tb/slot_num.
        
        status_x := slot_x + 80.
        /text_draw/status_x/text_y/14/tr/tg/tb/"- Save Data" when exists == 1.
        /text_draw/status_x/text_y/14/tr/tg/tb/"- Empty" when exists == 0.
    <
    
    // Back button
    /draw_menu_button/50/(SCREEN_H - 80)/100/40/"Back"/(menu_hovered_button == 10).
<

#render_menu_settings() >
    // Title - centered
    set_title := "Settings".
    title_width := /text_measure/set_title/24.
    title_x := (SCREEN_W - title_width) / 2.
    title_y := 180.
    /text_draw_font/title_x/title_y/24/180/160/120/0/set_title.
    
    // Slider dimensions
    slider_x := (SCREEN_W - 300) / 2.
    slider_w := 300.
    slider_h := 20.
    
    // Master Volume
    master_label_y := SCREEN_H / 2 - 80.
    master_y := SCREEN_H / 2 - 60.
    /text_draw/(slider_x)/master_label_y/14/200/200/200/"Master Volume".
    /draw_rect/slider_x/master_y/slider_w/slider_h/40/45/55/255.
    master_fill := slider_w * menu_master_volume / 100.
    /draw_rect/slider_x/master_y/master_fill/slider_h/80/120/180/255.
    master_handle := slider_x + master_fill - 5.
    /draw_rect/master_handle/(master_y - 3)/10/(slider_h + 6)/200/200/200/255.
    master_pct_x := slider_x + slider_w + 20.
    /text_draw_int/master_pct_x/master_y/14/200/200/200/menu_master_volume.
    /text_draw/(master_pct_x + 30)/master_y/14/200/200/200/"%".
    
    // Music Volume
    music_label_y := SCREEN_H / 2 - 20.
    music_y := SCREEN_H / 2.
    /text_draw/(slider_x)/music_label_y/14/200/200/200/"Music Volume".
    /draw_rect/slider_x/music_y/slider_w/slider_h/40/45/55/255.
    music_fill := slider_w * menu_music_volume / 100.
    /draw_rect/slider_x/music_y/music_fill/slider_h/100/180/100/255.
    music_handle := slider_x + music_fill - 5.
    /draw_rect/music_handle/(music_y - 3)/10/(slider_h + 6)/200/200/200/255.
    music_pct_x := slider_x + slider_w + 20.
    /text_draw_int/music_pct_x/music_y/14/200/200/200/menu_music_volume.
    /text_draw/(music_pct_x + 30)/music_y/14/200/200/200/"%".
    
    // SFX Volume
    sfx_label_y := SCREEN_H / 2 + 40.
    sfx_y := SCREEN_H / 2 + 60.
    /text_draw/(slider_x)/sfx_label_y/14/200/200/200/"SFX Volume".
    /draw_rect/slider_x/sfx_y/slider_w/slider_h/40/45/55/255.
    sfx_fill := slider_w * menu_sfx_volume / 100.
    /draw_rect/slider_x/sfx_y/sfx_fill/slider_h/180/100/100/255.
    sfx_handle := slider_x + sfx_fill - 5.
    /draw_rect/sfx_handle/(sfx_y - 3)/10/(slider_h + 6)/200/200/200/255.
    sfx_pct_x := slider_x + slider_w + 20.
    /text_draw_int/sfx_pct_x/sfx_y/14/200/200/200/menu_sfx_volume.
    /text_draw/(sfx_pct_x + 30)/sfx_y/14/200/200/200/"%".
    
    // Back button
    /draw_menu_button/50/(SCREEN_H - 80)/100/40/"Back"/(menu_hovered_button == 10).
<

#draw_menu_button(x, y, w, h, text, hovered) >
    // NetHack / Terminal Style Button (No Box)
    // Use Monospace font (ID 2)
    font_id := 2.
    font_size := 16.
    
    label := text.
    
    // Default color (dim grey/green)
    r := 150. g := 150. b := 150.
    
    r = 100 when hovered == 1.
    g = 255 when hovered == 1.
    b = 100 when hovered == 1.
    
    label = /ds_string_concat/"[ "/label when hovered == 1.
    label = /ds_string_concat/label/" ]" when hovered == 1.
    
    // Rough center
    // Char width approx 0.6 * 16 = 9.6px
    char_count := /ds_string_length/label.
    text_w := char_count * 10. 
    text_x := x + (w - text_w) / 2.
    text_y := y + (h - font_size) / 2.
    
    /text_draw_font/text_x/text_y/font_size/r/g/b/font_id/label.
<

// ============================================================================
// Save Game Function (called from game)
// ============================================================================

#save_game(slot) >
    // Collect save data and send to JS
    /js_save_game/slot.
    /refresh_save_slots/.
    last_message = "Game saved!".
<

// ============================================================================
// In-Game Pause Popup (opened from settings button during gameplay)
// ============================================================================

#toggle_pause_popup() >
    pause_popup_active = 1 - pause_popup_active.
    pause_popup_state = 0.
    pause_popup_hovered = -1.
    /play_sound_wrapper/SOUND_UI_CLICK.
<

#update_pause_popup(dt) >
    << 0 when pause_popup_active == 0.
    
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    just_pressed := /input_mouse_just_pressed/.
    mouse_down := /input_mouse_down/.
    
    // Capture state at start of frame to prevent multiple state updates in one frame
    current_state := pause_popup_state.
    
    /update_pause_popup_main/mx/my/just_pressed when current_state == 0.
    /update_pause_popup_settings/mx/my/just_pressed/mouse_down when current_state == 1.
    /update_pause_popup_save/mx/my/just_pressed when current_state == 2.
<

#update_pause_popup_main(mx, my, just_pressed) >
    // Popup dimensions
    popup_w := 300.
    popup_h := 250.
    popup_x := (SCREEN_W - popup_w) / 2.
    popup_y := (SCREEN_H - popup_h) / 2.
    
    pause_popup_hovered = -1.
    
    // X close button (top right)
    close_x := popup_x + popup_w - 35.
    close_y := popup_y + 10.
    close_size := 25.
    in_close := mx ge close_x and mx lt close_x + close_size and my ge close_y and my lt close_y + close_size.
    pause_popup_hovered = 0 when in_close == 1.
    pause_popup_active = 0 when in_close == 1 and just_pressed == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when in_close == 1 and just_pressed == 1.
    
    // Save Game button
    btn_w := 200.
    btn_h := 40.
    btn_x := popup_x + (popup_w - btn_w) / 2.
    btn1_y := popup_y + 70.
    
    in_save := mx ge btn_x and mx lt btn_x + btn_w and my ge btn1_y and my lt btn1_y + btn_h.
    pause_popup_hovered = 3 when in_save == 1.
    /do_quick_save/ when in_save == 1 and just_pressed == 1.
    
    // Main Menu button
    btn2_y := btn1_y + btn_h + 10.
    in_menu := mx ge btn_x and mx lt btn_x + btn_w and my ge btn2_y and my lt btn2_y + btn_h.
    pause_popup_hovered = 1 when in_menu == 1.
    /goto_main_menu_from_popup/ when in_menu == 1 and just_pressed == 1.
    
    // Settings button
    btn3_y := btn2_y + btn_h + 10.
    in_settings := mx ge btn_x and mx lt btn_x + btn_w and my ge btn3_y and my lt btn3_y + btn_h.
    pause_popup_hovered = 2 when in_settings == 1.
    pause_popup_state = 1 when in_settings == 1 and just_pressed == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when in_settings == 1 and just_pressed == 1.
<

#do_quick_save() >
    /play_sound_wrapper/SOUND_UI_CLICK.
    // Go to save slot picker instead of direct save
    pause_popup_state = 2.
    /refresh_save_slots/.
<

#goto_main_menu_from_popup() >
    /play_sound_wrapper/SOUND_UI_CLICK.
    pause_popup_active = 0.
    menu_active = 1.
    menu_state = MENU_STATE_MAIN.
    // Reset intro so New Game works properly
    intro_active = 0.
    intro_state = INTRO_STATE_NONE.
    // Refresh save slots when returning to menu
    /refresh_save_slots/.
<

#update_pause_popup_settings(mx, my, just_pressed, mouse_down) >
    popup_w := 300.
    popup_h := 320.
    popup_x := (SCREEN_W - popup_w) / 2.
    popup_y := (SCREEN_H - popup_h) / 2.
    
    pause_popup_hovered = -1.
    
    // X close button (top right)
    close_x := popup_x + popup_w - 35.
    close_y := popup_y + 10.
    close_size := 25.
    in_close := mx ge close_x and mx lt close_x + close_size and my ge close_y and my lt close_y + close_size.
    pause_popup_hovered = 0 when in_close == 1.
    pause_popup_state = 0 when in_close == 1 and just_pressed == 1.
    /js_set_setting/"master_volume"/menu_master_volume when in_close == 1 and just_pressed == 1.
    /js_set_setting/"music_volume"/menu_music_volume when in_close == 1 and just_pressed == 1.
    /js_set_setting/"sfx_volume"/menu_sfx_volume when in_close == 1 and just_pressed == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when in_close == 1 and just_pressed == 1.
    
    // Slider dimensions
    slider_w := 200.
    slider_h := 20.
    slider_x := popup_x + (popup_w - slider_w) / 2.
    
    // Master Volume slider
    master_y := popup_y + 90.
    in_master := mx ge slider_x and mx lt slider_x + slider_w and my ge master_y - 10 and my lt master_y + slider_h + 10.
    drag_master := in_master * mouse_down.
    new_master := 0.
    new_master = (mx - slider_x) * 100 / slider_w when drag_master == 1.
    new_master = 0 when new_master lt 0.
    new_master = 100 when new_master gt 100.
    menu_master_volume = new_master when drag_master == 1.
    /js_set_master_volume/menu_master_volume when drag_master == 1.
    
    // Music Volume slider
    music_y := popup_y + 160.
    in_music := mx ge slider_x and mx lt slider_x + slider_w and my ge music_y - 10 and my lt music_y + slider_h + 10.
    drag_music := in_music * mouse_down.
    new_music := 0.
    new_music = (mx - slider_x) * 100 / slider_w when drag_music == 1.
    new_music = 0 when new_music lt 0.
    new_music = 100 when new_music gt 100.
    menu_music_volume = new_music when drag_music == 1.
    /js_set_music_volume/menu_music_volume when drag_music == 1.
    
    // SFX Volume slider
    sfx_y := popup_y + 230.
    in_sfx := mx ge slider_x and mx lt slider_x + slider_w and my ge sfx_y - 10 and my lt sfx_y + slider_h + 10.
    drag_sfx := in_sfx * mouse_down.
    new_sfx := 0.
    new_sfx = (mx - slider_x) * 100 / slider_w when drag_sfx == 1.
    new_sfx = 0 when new_sfx lt 0.
    new_sfx = 100 when new_sfx gt 100.
    menu_sfx_volume = new_sfx when drag_sfx == 1.
    /js_set_sfx_volume/menu_sfx_volume when drag_sfx == 1.
<

#update_pause_popup_save(mx, my, just_pressed) >
    popup_w := 300.
    popup_h := 280.
    popup_x := (SCREEN_W - popup_w) / 2.
    popup_y := (SCREEN_H - popup_h) / 2.
    
    pause_popup_hovered = -1.
    
    // X close button (back to main popup)
    close_x := popup_x + popup_w - 35.
    close_y := popup_y + 10.
    close_size := 25.
    in_close := mx ge close_x and mx lt close_x + close_size and my ge close_y and my lt close_y + close_size.
    pause_popup_hovered = 0 when in_close == 1.
    pause_popup_state = 0 when in_close == 1 and just_pressed == 1.
    /play_sound_wrapper/SOUND_UI_CLICK when in_close == 1 and just_pressed == 1.
    
    // Save slot buttons
    slot_w := 220.
    slot_h := 50.
    slot_x := popup_x + (popup_w - slot_w) / 2.
    slot_y_start := popup_y + 70.
    slot_gap := 60.
    
    for i in 0..SAVE_SLOT_COUNT >
        slot_y := slot_y_start + i * slot_gap.
        in_slot := mx ge slot_x and mx lt slot_x + slot_w and my ge slot_y and my lt slot_y + slot_h.
        pause_popup_hovered = 20 + i when in_slot == 1.
        /do_save_to_slot/i when in_slot == 1 and just_pressed == 1.
    <
<

#do_save_to_slot(slot) >
    /play_sound_wrapper/SOUND_UI_CLICK.
    /save_game/slot.
    /refresh_save_slots/.
    // Go back to main popup
    pause_popup_state = 0.
<

#render_pause_popup() >
    << 0 when pause_popup_active == 0.
    
    // Darken background
    /draw_rect/0/0/SCREEN_W/SCREEN_H/0/0/0/150.
    
    // Popup dimensions (taller for settings with 3 sliders, or save slot picker)
    popup_w := 300.
    popup_h := 250.
    popup_h = 320 when pause_popup_state == 1.
    popup_h = 280 when pause_popup_state == 2.
    popup_x := (SCREEN_W - popup_w) / 2.
    popup_y := (SCREEN_H - popup_h) / 2.
    
    // Popup background
    /draw_rect/popup_x/popup_y/popup_w/popup_h/30/35/45/255.
    
    // Border
    /draw_rect/popup_x/popup_y/popup_w/3/80/90/110/255.
    /draw_rect/popup_x/(popup_y + popup_h - 3)/popup_w/3/80/90/110/255.
    /draw_rect/popup_x/popup_y/3/popup_h/80/90/110/255.
    /draw_rect/(popup_x + popup_w - 3)/popup_y/3/popup_h/80/90/110/255.
    
    // X close button
    close_x := popup_x + popup_w - 35.
    close_y := popup_y + 10.
    close_hover := pause_popup_hovered == 0.
    xr := 150. xg := 150. xb := 150.
    xr = 220 when close_hover == 1. xg = 100 when close_hover == 1. xb = 100 when close_hover == 1.
    /text_draw/close_x/close_y/18/xr/xg/xb/"X".
    
    /render_pause_popup_main/popup_x/popup_y/popup_w/popup_h when pause_popup_state == 0.
    /render_pause_popup_settings/popup_x/popup_y/popup_w/popup_h when pause_popup_state == 1.
    /render_pause_popup_save/popup_x/popup_y/popup_w/popup_h when pause_popup_state == 2.
<

#render_pause_popup_main(popup_x, popup_y, popup_w, popup_h) >
    // Title
    title := "PAUSED".
    title_width := /text_measure/title/20.
    title_x := popup_x + (popup_w - title_width) / 2.
    title_y := popup_y + 30.
    /text_draw/title_x/title_y/20/200/200/200/title.
    
    // Buttons
    btn_w := 200.
    btn_h := 40.
    btn_x := popup_x + (popup_w - btn_w) / 2.
    
    // Save Game button
    btn1_y := popup_y + 70.
    btn1_hover := pause_popup_hovered == 3.
    /draw_menu_button/btn_x/btn1_y/btn_w/btn_h/"Save Game"/btn1_hover.
    
    // Main Menu button
    btn2_y := btn1_y + btn_h + 10.
    btn2_hover := pause_popup_hovered == 1.
    /draw_menu_button/btn_x/btn2_y/btn_w/btn_h/"Main Menu"/btn2_hover.
    
    // Settings button
    btn3_y := btn2_y + btn_h + 10.
    btn3_hover := pause_popup_hovered == 2.
    /draw_menu_button/btn_x/btn3_y/btn_w/btn_h/"Settings"/btn3_hover.
<

#render_pause_popup_settings(popup_x, popup_y, popup_w, popup_h) >
    // Title
    title := "SETTINGS".
    title_width := /text_measure/title/20.
    title_x := popup_x + (popup_w - title_width) / 2.
    title_y := popup_y + 30.
    /text_draw/title_x/title_y/20/200/200/200/title.
    
    // Slider dimensions
    slider_w := 200.
    slider_h := 20.
    slider_x := popup_x + (popup_w - slider_w) / 2.
    
    // Master Volume
    master_label := "Master".
    master_label_width := /text_measure/master_label/14.
    master_label_x := popup_x + (popup_w - master_label_width) / 2.
    master_label_y := popup_y + 60.
    master_y := popup_y + 90.
    /text_draw/master_label_x/master_label_y/14/180/180/180/master_label.
    /draw_rect/slider_x/master_y/slider_w/slider_h/50/55/65/255.
    master_fill := slider_w * menu_master_volume / 100.
    /draw_rect/slider_x/master_y/master_fill/slider_h/80/120/180/255.
    master_handle := slider_x + master_fill - 5.
    /draw_rect/master_handle/(master_y - 3)/10/(slider_h + 6)/200/200/200/255.
    master_pct_x := slider_x + slider_w + 10.
    /text_draw_int/master_pct_x/master_y/14/200/200/200/menu_master_volume.
    /text_draw/(master_pct_x + 25)/master_y/14/200/200/200/"%".
    
    // Music Volume
    music_label := "Music".
    music_label_width := /text_measure/music_label/14.
    music_label_x := popup_x + (popup_w - music_label_width) / 2.
    music_label_y := popup_y + 130.
    music_y := popup_y + 160.
    /text_draw/music_label_x/music_label_y/14/180/180/180/music_label.
    /draw_rect/slider_x/music_y/slider_w/slider_h/50/55/65/255.
    music_fill := slider_w * menu_music_volume / 100.
    /draw_rect/slider_x/music_y/music_fill/slider_h/100/180/100/255.
    music_handle := slider_x + music_fill - 5.
    /draw_rect/music_handle/(music_y - 3)/10/(slider_h + 6)/200/200/200/255.
    music_pct_x := slider_x + slider_w + 10.
    /text_draw_int/music_pct_x/music_y/14/200/200/200/menu_music_volume.
    /text_draw/(music_pct_x + 25)/music_y/14/200/200/200/"%".
    
    // SFX Volume
    sfx_label := "SFX".
    sfx_label_width := /text_measure/sfx_label/14.
    sfx_label_x := popup_x + (popup_w - sfx_label_width) / 2.
    sfx_label_y := popup_y + 200.
    sfx_y := popup_y + 230.
    /text_draw/sfx_label_x/sfx_label_y/14/180/180/180/sfx_label.
    /draw_rect/slider_x/sfx_y/slider_w/slider_h/50/55/65/255.
    sfx_fill := slider_w * menu_sfx_volume / 100.
    /draw_rect/slider_x/sfx_y/sfx_fill/slider_h/180/100/100/255.
    sfx_handle := slider_x + sfx_fill - 5.
    /draw_rect/sfx_handle/(sfx_y - 3)/10/(slider_h + 6)/200/200/200/255.
    sfx_pct_x := slider_x + slider_w + 10.
    /text_draw_int/sfx_pct_x/sfx_y/14/200/200/200/menu_sfx_volume.
    /text_draw/(sfx_pct_x + 25)/sfx_y/14/200/200/200/"%".
<

#render_pause_popup_save(popup_x, popup_y, popup_w, popup_h) >
    // Title
    title := "SAVE GAME".
    title_width := /text_measure/title/20.
    title_x := popup_x + (popup_w - title_width) / 2.
    title_y := popup_y + 30.
    /text_draw/title_x/title_y/20/200/200/200/title.
    
    // Save slots
    slot_w := 220.
    slot_h := 50.
    slot_x := popup_x + (popup_w - slot_w) / 2.
    slot_y_start := popup_y + 70.
    slot_gap := 60.
    
    for i in 0..SAVE_SLOT_COUNT >
        slot_y := slot_y_start + i * slot_gap.
        slot_hover := pause_popup_hovered == 20 + i.
        exists := save_slot_exists[i].
        
        // Draw slot button
        r := 40. g := 45. b := 55.
        r = 60 when slot_hover == 1. g = 70 when slot_hover == 1. b = 85 when slot_hover == 1.
        /draw_rect/slot_x/slot_y/slot_w/slot_h/r/g/b/255.
        
        // Border
        br := 70. bg := 80. bb := 100.
        br = 100 when slot_hover == 1. bg = 120 when slot_hover == 1. bb = 150 when slot_hover == 1.
        /draw_rect/slot_x/slot_y/slot_w/2/br/bg/bb/255.
        /draw_rect/slot_x/(slot_y + slot_h - 2)/slot_w/2/br/bg/bb/255.
        /draw_rect/slot_x/slot_y/2/slot_h/br/bg/bb/255.
        /draw_rect/(slot_x + slot_w - 2)/slot_y/2/slot_h/br/bg/bb/255.
        
        // Draw slot text
        text_x := slot_x + 15.
        text_y := slot_y + 18.
        tr := 200. tg := 200. tb := 200.
        
        slot_num := i + 1.
        /text_draw/text_x/text_y/14/tr/tg/tb/"Slot".
        /text_draw_int/(text_x + 35)/text_y/14/tr/tg/tb/slot_num.
        
        status_x := slot_x + 80.
        /text_draw/status_x/text_y/14/120/200/120/"- Overwrite" when exists == 1.
        /text_draw/status_x/text_y/14/150/150/150/"- Empty" when exists == 0.
    <
<
