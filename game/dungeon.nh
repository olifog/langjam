// dungeon.nh - Dungeon map data and procedural generation
// ============================================================================
// Map Constants
// ============================================================================

MAP_WIDTH := 50.
MAP_HEIGHT := 20.

// Tile types
TILE_EMPTY := 0.
TILE_FLOOR := 1.
TILE_WALL_H := 2.
TILE_WALL_V := 3.
TILE_CORRIDOR := 4.
TILE_DOOR := 5.
TILE_STAIRS := 6.
TILE_GOLD := 7.

// ============================================================================
// Dungeon Map
// ============================================================================

dungeon := [].

// ============================================================================
// Room Storage (for organic generation)
// ============================================================================

// Room data: each room has x, y, w, h, center_x, center_y
room_x := [].
room_y := [].
room_w := [].
room_h := [].
room_cx := [].
room_cy := [].
room_count := 0.

// Expansion points: walls that can grow corridors
expand_x := [].
expand_y := [].
expand_dir := [].  // 0=right, 1=left, 2=down, 3=up
expand_room := []. // Which room this expansion point belongs to
expand_count := 0.
expand_used := []. // 1 if this expansion point has been tried

// ============================================================================
// Dungeon Access
// ============================================================================

#get_tile(x, y) >
    << TILE_EMPTY when x lt 0.
    << TILE_EMPTY when y lt 0.
    << TILE_EMPTY when x ge MAP_WIDTH.
    << TILE_EMPTY when y ge MAP_HEIGHT.
    idx := y * MAP_WIDTH + x.
    << dungeon[idx].
<

#set_tile(x, y, val) >
    << 0 when x lt 0.
    << 0 when y lt 0.
    << 0 when x ge MAP_WIDTH.
    << 0 when y ge MAP_HEIGHT.
    idx := y * MAP_WIDTH + x.
    dungeon[idx] = val.
<

// ============================================================================
// Direction Helpers
// ============================================================================

#get_delta_x(dir) >
    ret := 0.
    ret = 1 when dir == 0.      // Right
    ret = 0 - 1 when dir == 1.  // Left
    // Up/Down are x=0
    << ret.
<

#get_delta_y(dir) >
    ret := 0.
    ret = 1 when dir == 2.      // Down
    ret = 0 - 1 when dir == 3.  // Up
    // Right/Left are y=0
    << ret.
<

// ============================================================================
// Room Drawing
// ============================================================================

#make_room(rx, ry, rw, rh) >
    // Draw floor
    for dy in 1..(rh - 1) >
        for dx in 1..(rw - 1) >
            /set_tile/(rx + dx)/(ry + dy)/TILE_FLOOR.
        <
    <
    
    // Draw horizontal walls
    for dx in 0..rw >
        /set_tile/(rx + dx)/ry/TILE_WALL_H.
        /set_tile/(rx + dx)/(ry + rh - 1)/TILE_WALL_H.
    <
    
    // Draw vertical walls
    for dy in 1..(rh - 1) >
        /set_tile/rx/(ry + dy)/TILE_WALL_V.
        /set_tile/(rx + rw - 1)/(ry + dy)/TILE_WALL_V.
    <
<

// ============================================================================
// Overlap Detection
// ============================================================================

#check_area_clear(rx, ry, rw, rh) >
    // Check if area is all empty (with 1 tile padding)
    px := rx - 1.
    py := ry - 1.
    pw := rw + 2.
    ph := rh + 2.
    
    for dy in 0..ph >
        for dx in 0..pw >
            cx := px + dx.
            cy := py + dy.
            
            // Allow out of bounds (counts as clear)
            in_bounds := 1.
            in_bounds = 0 when cx lt 0.
            in_bounds = 0 when cy lt 0.
            in_bounds = 0 when cx ge MAP_WIDTH.
            in_bounds = 0 when cy ge MAP_HEIGHT.
            
            tile := TILE_EMPTY.
            tile = /get_tile/cx/cy when in_bounds == 1.
            
            << 0 when tile != TILE_EMPTY.
        <
    <
    << 1.
<

// ============================================================================
// Expansion Point Management
// ============================================================================

#add_expansion_points(room_idx, rx, ry, rw, rh) >
    // Add each wall midpoint as potential expansion
    
    // Right wall (dir = 0)
    expand_x[expand_count] = rx + rw - 1.
    expand_y[expand_count] = ry + rh / 2.
    expand_dir[expand_count] = 0.
    expand_room[expand_count] = room_idx.
    expand_used[expand_count] = 0.
    expand_count = expand_count + 1.
    
    // Left wall (dir = 1)
    expand_x[expand_count] = rx.
    expand_y[expand_count] = ry + rh / 2.
    expand_dir[expand_count] = 1.
    expand_room[expand_count] = room_idx.
    expand_used[expand_count] = 0.
    expand_count = expand_count + 1.
    
    // Bottom wall (dir = 2)
    expand_x[expand_count] = rx + rw / 2.
    expand_y[expand_count] = ry + rh - 1.
    expand_dir[expand_count] = 2.
    expand_room[expand_count] = room_idx.
    expand_used[expand_count] = 0.
    expand_count = expand_count + 1.
    
    // Top wall (dir = 3)
    expand_x[expand_count] = rx + rw / 2.
    expand_y[expand_count] = ry.
    expand_dir[expand_count] = 3.
    expand_room[expand_count] = room_idx.
    expand_used[expand_count] = 0.
    expand_count = expand_count + 1.
<

#pick_unused_expansion() >
    // Pick a random unused expansion point
    // Returns index or -1 if none available
    
    // Count unused
    unused_count := 0.
    for i in 0..expand_count >
        used := expand_used[i].
        unused_count = unused_count + 1 when used == 0.
    <
    
    << -1 when unused_count == 0.
    
    // Pick random unused
    pick := /rng_int/unused_count.
    current := 0.
    
    for i in 0..expand_count >
        used := expand_used[i].
        is_unused := 0.
        is_unused = 1 when used == 0.
        
        is_pick := 0.
        is_pick = 1 when current == pick.
        
        found := is_unused * is_pick.
        << i when found == 1.
        
        current = current + 1 when is_unused == 1.
    <
    
    << -1.
<

// ============================================================================
// Corridor Digging
// ============================================================================

#dig_corridor(start_x, start_y, dir, length) >
    // Dig a corridor and return end position packed as y*1000+x
    // Also creates door at start
    
    dx := /get_delta_x/dir.
    dy := /get_delta_y/dir.
    
    cx := start_x.
    cy := start_y.
    
    // Create door at starting wall
    /set_tile/cx/cy/TILE_DOOR.
    
    // Dig corridor tiles
    for i in 0..length >
        cx = cx + dx.
        cy = cy + dy.
        
        // Check bounds
        valid := 1.
        valid = 0 when cx lt 1.
        valid = 0 when cy lt 1.
        valid = 0 when cx ge MAP_WIDTH - 1.
        valid = 0 when cy ge MAP_HEIGHT - 1.
        
        /set_tile/cx/cy/TILE_CORRIDOR when valid == 1.
    <
    
    << cy * 1000 + cx.
<

// ============================================================================
// Room Addition (Organic Expansion)
// ============================================================================

#try_add_room() >
    // Try to add a room by expanding from existing structure
    // Returns 1 on success, 0 on failure
    
    // Pick expansion point
    exp_idx := /pick_unused_expansion/.
    << 0 when exp_idx == -1.
    
    // Mark as used
    expand_used[exp_idx] = 1.
    
    // Get expansion data
    ex := expand_x[exp_idx].
    ey := expand_y[exp_idx].
    dir := expand_dir[exp_idx].
    
    // Random corridor length (3-6)
    corridor_len := /rng_int/4 + 3.
    
    // Calculate room dimensions
    size_range := dng_max_room_size - dng_min_room_size + 1.
    rw := /rng_int/size_range + dng_min_room_size.
    rh := /rng_int/size_range + dng_min_room_size.
    
    // Add 2 for walls
    rw = rw + 2.
    rh = rh + 2.
    
    // Calculate corridor end position
    dx := /get_delta_x/dir.
    dy := /get_delta_y/dir.
    
    end_x := ex + dx * (corridor_len + 1).
    end_y := ey + dy * (corridor_len + 1).
    
    // Calculate room position based on direction
    // Room should be centered on corridor end
    rx := end_x.
    ry := end_y.
    
    // Adjust room position based on direction
    // Right (dir=0): room starts at end_x, centered on end_y
    rx = end_x when dir == 0.
    ry = end_y - rh / 2 when dir == 0.
    
    // Left (dir=1): room ends at end_x, centered on end_y
    rx = end_x - rw + 1 when dir == 1.
    ry = end_y - rh / 2 when dir == 1.
    
    // Down (dir=2): room starts at end_y, centered on end_x
    rx = end_x - rw / 2 when dir == 2.
    ry = end_y when dir == 2.
    
    // Up (dir=3): room ends at end_y, centered on end_x
    rx = end_x - rw / 2 when dir == 3.
    ry = end_y - rh + 1 when dir == 3.
    
    // Check bounds
    valid := 1.
    valid = 0 when rx lt 0.
    valid = 0 when ry lt 0.
    valid = 0 when rx + rw ge MAP_WIDTH.
    valid = 0 when ry + rh ge MAP_HEIGHT.
    
    << 0 when valid == 0.
    
    // Check area is clear
    clear := /check_area_clear/rx/ry/rw/rh.
    << 0 when clear == 0.
    
    // Success! Create the room and corridor
    
    // Dig corridor first
    /dig_corridor/ex/ey/dir/corridor_len.
    
    // Make room
    /make_room/rx/ry/rw/rh.
    
    // Create door where corridor meets room
    door_x := rx.
    door_y := ry + rh / 2.
    door_x = rx + rw - 1 when dir == 1.
    door_y = ry + rh / 2 when dir == 1.
    door_x = rx + rw / 2 when dir == 2.
    door_y = ry when dir == 2.
    door_x = rx + rw / 2 when dir == 3.
    door_y = ry + rh - 1 when dir == 3.
    
    /set_tile/door_x/door_y/TILE_DOOR.
    
    // Store room data
    room_x[room_count] = rx.
    room_y[room_count] = ry.
    room_w[room_count] = rw.
    room_h[room_count] = rh.
    room_cx[room_count] = rx + rw / 2.
    room_cy[room_count] = ry + rh / 2.
    
    // Add expansion points for new room
    /add_expansion_points/room_count/rx/ry/rw/rh.
    
    room_count = room_count + 1.
    
    << 1.
<

// ============================================================================
// Starting Room Creation
// ============================================================================

#create_starting_room() >
    // Create the first room, centered in map
    
    // Calculate room size
    size_range := dng_max_room_size - dng_min_room_size + 1.
    rw := /rng_int/size_range + dng_min_room_size.
    rh := /rng_int/size_range + dng_min_room_size.
    
    // Add 2 for walls
    rw = rw + 2.
    rh = rh + 2.
    
    // Center in map
    rx := MAP_WIDTH / 2 - rw / 2.
    ry := MAP_HEIGHT / 2 - rh / 2.
    
    // Make room
    /make_room/rx/ry/rw/rh.
    
    // Store room data
    room_x[0] = rx.
    room_y[0] = ry.
    room_w[0] = rw.
    room_h[0] = rh.
    room_cx[0] = rx + rw / 2.
    room_cy[0] = ry + rh / 2.
    room_count = 1.
    
    // Add expansion points
    expand_count = 0.
    /add_expansion_points/0/rx/ry/rw/rh.
    
    // Set player start position (center of room)
    player_x = room_cx[0].
    player_y = room_cy[0].
    player_prev_x = player_x.
    player_prev_y = player_y.
    anim_timer = 0.
<

// ============================================================================
// Stairs Placement
// ============================================================================

#place_stairs() >
    // Place stairs based on upgrade state
    
    // Get starting room data
    rx := room_x[0].
    ry := room_y[0].
    rw := room_w[0].
    rh := room_h[0].
    
    sx := 0.
    sy := 0.
    
    // Default: fixed position (top-right of starting room interior)
    sx = rx + rw - 2.
    sy = ry + 1.
    
    // If random stairs unlocked, pick random spot in room
    random_stairs := dng_stairs_random.
    
    // If multiple rooms, always put stairs in last room (furthest)
    target_room := 0.
    target_room = room_count - 1 when room_count gt 1.
    
    // Get target room data
    trx := room_x[target_room].
    try := room_y[target_room].
    trw := room_w[target_room].
    trh := room_h[target_room].
    
    // Calculate interior bounds
    int_x := trx + 1.
    int_y := try + 1.
    int_w := trw - 2.
    int_h := trh - 2.
    
    // Random or fixed placement
    use_random := random_stairs.
    use_random = 1 when target_room gt 0. // Always random if not starting room
    
    // Random position (not on player)
    found := 0.
    tries := 0.
    loop when tries lt 50 >
        // Pick random spot in target room interior
        sx = int_x + /rng_int/int_w when use_random == 1.
        sy = int_y + /rng_int/int_h when use_random == 1.
        
        // For fixed (starting room, no random upgrade): top-right
        sx = trx + trw - 2 when use_random == 0.
        sy = try + 1 when use_random == 0.
        
        // Check not on player
        on_player := 0.
        on_player_x := 0. on_player_y := 0.
        on_player_x = 1 when sx == player_x.
        on_player_y = 1 when sy == player_y.
        on_player = on_player_x * on_player_y.
        
        found = 1 when on_player == 0.
        
        // Fixed placement always succeeds on first try (can't be on player if room > 3x3 or different room)
        found = 1 when use_random == 0.
        
        tries = tries + 1 when found == 0.
        tries = 100 when found == 1.
    <
    
    /set_tile/sx/sy/TILE_STAIRS.
<

// ============================================================================
// Gold Spawning
// ============================================================================

#spawn_gold_piles() >
    << 0 when dng_gold_enabled == 0.
    
    // Spawn gold in rooms (not starting room)
    gold_count := room_count * 2.
    gold_count = 3 when gold_count lt 3.
    gold_count = 10 when gold_count gt 10.
    
    for k in 0..gold_count >
        // Pick random room (prefer non-starting rooms)
        target := /rng_int/room_count.
        target = 1 when target == 0 and room_count gt 1.
        
        // Get room bounds
        trx := room_x[target].
        try := room_y[target].
        trw := room_w[target].
        trh := room_h[target].
        
        // Random position in interior
        gx := trx + 1 + /rng_int/(trw - 2).
        gy := try + 1 + /rng_int/(trh - 2).
        
        // Only place on floor
        tile := /get_tile/gx/gy.
        /set_tile/gx/gy/TILE_GOLD when tile == TILE_FLOOR.
    <
<

// ============================================================================
// Main Dungeon Generation
// ============================================================================

#generate_dungeon() >
    // Generate new seed and save it
    dungeon_seed = /time_ms/.
    /rng_seed/dungeon_seed.
    /do_generate_dungeon/.
<

#regenerate_dungeon() >
    // Regenerate with same seed (for retry)
    /rng_seed/dungeon_seed.
    /do_generate_dungeon/.
<

#do_generate_dungeon() >
    // Recalculate params from tech tree (NOT from dungeon level)
    /recalc_dungeon_params/.
    
    // Clear map
    size := MAP_WIDTH * MAP_HEIGHT.
    for i in 0..size >
        dungeon[i] = TILE_EMPTY.
    <
    
    // Reset room data
    room_count = 0.
    expand_count = 0.
    
    // Phase 1: Create starting room
    /create_starting_room/.
    
    // Phase 2: Add additional rooms (based on tech tree upgrades ONLY)
    target_rooms := dng_max_rooms.
    attempts := 0.
    max_attempts := target_rooms * 20. // Allow many retries
    
    loop when room_count lt target_rooms >
        << 0 when attempts ge max_attempts.
        
        success := /try_add_room/.
        attempts = attempts + 1.
    <
    
    // Phase 3: Place stairs
    /place_stairs/.
    
    // Phase 4: Spawn gold
    /spawn_gold_piles/.
    
    // Phase 5: Spawn monsters
    /spawn_random_monsters/.
<

// ============================================================================
// Monster Spawning (respects tech tree)
// ============================================================================

#spawn_random_monsters() >
    /init_entities/.
    
    << 0 when dng_monster_count == 0.
    
    for i in 0..dng_monster_count >
        // Random Type (only kobolds for now)
        type := ENTITY_KOBOLD.
        
        // Random Position in non-starting room
        sx := 0. sy := 0.
        found := 0.
        
        tries := 0.
        loop when tries lt 100 >
            // Pick random room (prefer non-starting)
            target := /rng_int/room_count.
            target = 1 when target == 0 and room_count gt 1.
            
            // Get room bounds
            trx := room_x[target].
            try := room_y[target].
            trw := room_w[target].
            trh := room_h[target].
            
            // Random position in interior
            rx := trx + 1 + /rng_int/(trw - 2).
            ry := try + 1 + /rng_int/(trh - 2).
            
            tile := /get_tile/rx/ry.
            is_floor := 0.
            is_floor = 1 when tile == TILE_FLOOR.
            
            // Check player collision
            is_player := 0.
            is_player_x := 0. is_player_y := 0.
            is_player_x = 1 when rx == player_x.
            is_player_y = 1 when ry == player_y.
            is_player = is_player_x * is_player_y.
            
            // Check entity collision
            collision := /get_entity_at/rx/ry.
            is_occupied := 0.
            is_occupied = 1 when collision != -1.
            
            valid := is_floor * (1 - is_player).
            valid = valid * (1 - is_occupied).
            
            sx = rx when valid == 1.
            sy = ry when valid == 1.
            found = 1 when valid == 1.
            
            tries = 100 when found == 1.
            tries = tries + 1.
        <
        
        /spawn_entity/type/sx/sy when found == 1.
    <
<
